
AVRASM ver. 2.2.7  C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm Mon Dec 21 05:56:39 2020

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
                                 
                                 .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 .def temp = r16 ; temporal registter for some actions
                                 .def temp2 = r17
                                 .def temp3 = r18
                                 .def temp4 = r19
                                 .def tempInter = r20
                                 .def eventsFlags0 = r21
                                 .def eventsFlags1 = r22
                                 .def tempFlag = r23
                                 .def statesFlags0 = r24
                                 
                                 .equ speaker_pin_number = 5
                                 .equ speaker_pin_position = 0b00000100 ; speaker will be connected on 5th pin of portD
                                 
                                 .equ engine_flap_pin_num = 7 ; engine cooler flap will be contolled by the electrical magnet
                                 .equ engine_flap_pin_pos = 0b10000000
                                 
                                 .equ outside_flap_pin_num = 6 ; the same for outside flap
                                 .equ outside_flap_pin_pos = 0b01000000
                                 
                                 .equ debug_pin_position = 0b00100000 ; will use this pin to show something idk
                                 .equ debug_pin_number = 5
                                 
                                 .equ heater_pin_number = 0
                                 .equ heater_pin_position = 0b000000001
                                 .equ cooler_pin_number = 1
                                 .equ cooler_pin_position = 0b000000010
                                 
                                 .equ frontAirbagsTriggerPinNumber = 4
                                 .equ frontAirbagsTriggerPinPosition = 0b00010000
                                 .equ sideAirbagsTriggerPinNumber = 3
                                 .equ sideAirbagsTriggerPinPosition =  0b00001000
                                 .equ maxAllowedSideAcceleration = 40
                                 .equ maxAllowedForwardAcceleration = 100
                                 .equ maxAllowedBackwardAcceleration = 70
                                 .equ accelerationCheckingFreq = 128 + 64 + 32 + 16 + 8 + 4 + 2
                                 
                                 .equ insideThermalSensorNum = 0
                                 .equ outsideThermalSensorNum = 1
                                 .equ engineThermalSensorNum = 2
                                 .equ steeringWheelSensorNum = 3
                                 .equ seat0ThermalSensorNum = 4 ; TODO can be done without these 4 lines of code
                                 .equ seat1ThermalSensorNum = 5
                                 .equ seat2ThermalSensorNum = 6
                                 .equ seat3ThermalSensorNum = 7 
                                 .equ seat0FlapControl = 8
                                 .equ seat1FlapControl = 9
                                 .equ seat2FlapControl = 10
                                 .equ seat3FlapControl = 11
                                 .equ accelerationFrontSensorZ = 12
                                 .equ accelerationFrontSensorX = 13
                                 .equ accelerationRearSensorX = 14
                                 .equ lolkekcheburek = 15
                                 
                                 .equ tccr0_setup_byte = 0b00000101 ; select speed for timer0
                                 .equ assr_setup_byte =  0b00001000 ; select async oscilator (slower speed and independent from main clock)
                                 .equ tccr1b_setup_byte = 0b00000101 ; seelect speed for timer1
                                 .equ tccr2_setup_byte = 0b00000101 ; select speed for timer2
                                 .equ tccr3b_setup_byte = 0b00000011 ; select speed for timer3
                                 .equ timsk_setup_byte = 0b01000101 ; enable timer2, tiemr1 and timer0 interruption on overflowz
                                 .equ etimsk_setup_byte = 0b00000100 ; enable temer3 interruption on overflow
                                 
                                 .equ ch0 = 0
                                 .equ ch1 = 1
                                 .equ ch2 = 2
                                 .equ ch3 = 3
                                 .equ ch4 = 4
                                 .equ ch5 = 5
                                 .equ ch6 = 6
                                 .equ ch7 = 7
                                 .equ ch8 = 8
                                 .equ ch9 = 9
                                 .equ chA = 10
                                 .equ chB = 11
                                 .equ chC = 12
                                 .equ chD = 13
                                 .equ chE = 14
                                 .equ chF = 15
                                 .equ chGrad = 16
                                 .equ chMinus = 17
                                 .equ chR = 18
                                 .equ chSpace = 19
                                 
                                 .equ soundSignalsDelay = 128 + 64 + 32 + 16 ; (lower number bigger delays)
                                 	.equ tone0 = 0 + 128 + 64 + 32 + 16 + 8 + 4 ; (lower number -lower tone)
                                  	.equ tone1 = 0 + 128 + 64 + 32 + 16 + 8 + 4 + 2
                                 
                                 .equ displayDataSwitchingFreq = 128 + 64 + 32 ; bigger number - faster switching
                                 
                                 .equ checkOutsideTemperatureFreq = 128 + 64 + 32 + 16 
                                 
                                 .equ condFanSpeed = 249; higher number - higher speed
                                 	
                                 
                                 	; states flags 0
                                 	.equ sf_sound_enabled =				0b10000000
                                 	.equ sf_sound_enabled_n =			7
                                 	.equ sf_warning_signal_enabled =	0b01000000
                                 	.equ sf_warning_signal_enabled_n =  6
                                 	.equ sf_click_signal_enabled  =		0b00100000
                                 	.equ sf_click_signal_enabled_n =	5
                                 	.equ sf_accept_signal_enabled =		0b00010000
                                 	.equ sf_accept_signal_enabled_n =	4
                                 	.equ sf_cancel_signal_enabled =		0b00001000
                                 	.equ sf_cancel_signal_enabled_n =	3
                                 	.equ sf_conditioner_enabled =		0b00000100
                                 	.equ sf_conditioner_enabled_n =		2
                                 	.equ sf_engine_cooler_flap_state =	0b00000010
                                 	.equ sf_engine_cooler_flap_state_n = 1
                                 	.equ sf_display_error_message =		0b00000001
                                 	.equ sf_display_error_message_n =	0
                                 
                                 	; eventsFlags0
                                 	.equ ef_update_sound_wave_state =	0b10000000
                                 	.equ ef_update_sound_wave_state_n =	7
                                 	.equ ef_update_sound_type =			0b01000000
                                 	.equ ef_update_sound_type_n =		6
                                 	.equ ef_handle_input =				0b00100000
                                 	.equ ef_handle_input_n =			5
                                 	.equ ef_update_7seg_screen =		0b00010000
                                 	.equ ef_update_7seg_screen_n =		4
                                 	.equ ef_read_analog_sensors =		0b00001000
                                 	.equ ef_read_analog_sensors_n =		3
                                 	.equ ef_save_target_temperature =	0b00000100
                                 	.equ ef_save_target_temperature_n = 2
                                 	.equ ef_update_heater =				0b00000010
                                 	.equ ef_update_heater_n =			1
                                 	.equ ef_update_conditioner_fan =	0b00000001
                                 	.equ ef_update_conditioner_fan_n =	0
                                 
                                 
                                 	; events flags1
                                 	.equ ef_load_target_temp =			0b10000000
                                 	.equ ef_load_target_temp_n =		7
                                 	.equ ef_update_program_timers =		0b01000000
                                 	.equ ef_update_program_timers_n =	6
                                 	.equ ef_update_flaps =				0b00100000
                                 	.equ ef_update_flaps_n =			5
                                 	.equ ef_increment_tachometer =		0b00010000
                                 	.equ ef_increment_tachometer_n =	4
                                 	.equ ef_update_tachometer =			0b00001000
                                 	.equ ef_update_tachometer_n =		3
                                 	.equ ef_check_engine_temperature =	0b00000100
                                 	.equ ef_check_engine_temperature_n = 2
                                 	.equ ef_switch_display_data =		0b00000010
                                 	.equ ef_switch_display_data_n =		1
                                 	.equ ef_handle_current_key =		0b00000001
                                 	.equ ef_handle_current_key_n =		0
                                 
                                 	; events falgs 2
                                 	.equ ef_check_outside_temperature =		0b10000000
                                 	.equ ef_check_outside_temperature_n =   7
                                 	.equ ef_check_acceleration =			0b01000000
                                 	.equ ef_check_acceleration_n =			6
                                 
                                 
                                 //addreses in eeprom where usefull data will be saved
                                 .equ targetTempSavingAddr = 0
                                 
                                 
                                 .dseg
                                 	analogValuesTable:
000100                           		.byte 16 ; there will be stored all the data from all 8 thermal sensors
                                 	SevenSegScrBuff:
000110                           		.byte 8 ; reserve 8 bytes for 7 segment dysplay buffer
                                 	currentSensorNum:
000118                           		.byte 1 ; there will be stored number of thermalSensor we wanna save data from
                                 	curPos7Seg:
000119                           		.byte 1 ; position of currently printing glyph on 7seg display
                                 	
                                 	currentDisplayData:
00011a                           		.byte 1 ; 0 - temperatures, 1 - tachometer
                                 	switchDisplayDataTimerH:
00011b                           		.byte 1 ;
                                 	switchDisplayDataTimerL:
00011c                           		.byte 1 ;
                                 
                                 	targetTemperature:
00011d                           		.byte 1 ; reserve  1 byte to keep temperature while running\
                                 	updateConditionerTimer:
00011e                           		.byte 1
                                 	flapsUpdateTimer:
00011f                           		.byte 1
                                 	currentControlledFlap:
000120                           		.byte 1
                                 	conditionerFanTimer0:
000121                           		.byte 1 ; reserve 2 bytes to store current conditioner fan timer
                                 	conditionerFanTimer1:
000122                           		.byte 1
                                 	conditionerFanState:
000123                           		.byte 1 ; reserve 1 byte to know fan "rotation" (not quite but who cares)
                                 	checkOutsideTemperatureTimerH:
000124                           		.byte 1
                                 	checkOutsideTemperatureTimerL:
000125                           		.byte 1
                                 
                                 	tachometerTimerH:
000126                           		.byte 1
                                 	tachometerTimerL:
000127                           		.byte 1
                                 	tachometerCounter:
000128                           		.byte 1
                                 	engineSpeed:
000129                           		.byte 1
                                 	checkEngineTemperatureTimer:
00012a                           		.byte 1
                                 
                                 	currentTone:
00012b                           		.byte 1 ; there will be stored current note of sound
                                 
                                 	currentKey:
00012c                           		.byte 1 ; there will be storred a number of the last pressed key
                                 	handleCurrentKeyTimer:
00012d                           		.byte 1
                                 
                                 	checkAccelerationTimer:
00012e                           		.byte 1 
                                 
                                 	eventsFlags2:
00012f                           		.byte 1
                                 
                                 .cseg
                                 	.org 0
000000 940c 005c                 		jmp reset
                                 
                                 	
                                 		.org $0002
000002 940c 0506                 			jmp extInt0Handler
                                 		.org $0004
000004 940c 050a                 			jmp extInt1Handler
                                 		.org $0014
000014 940c 0516                 			jmp timer2OvfHandler
                                 		.org $001C
00001c 940c 0512                 			jmp timer1OvfHandler
                                 		.org $0020
000020 940c 050e                 			jmp timer0OvfHandler
                                 		.org $002a
00002a 940c 051e                 			jmp adcConvertionHandler
                                 		.org $003a 
00003a 940c 051a                 			jmp timer3OvfHandler
                                 
                                 
                                 	.org $0050 ; start program almost right after all intrruptions vectors
                                 
                                 	charTable7seg: 
                                 		//main simbols for 7seg display
000050 9f03
000051 0d25                      		.db 0b00000011 /*0*/, 0b10011111 /*1*/, 0b00100101 /*2*/, 0b00001101 /*3*/
000052 4999
000053 1f41                      		.db	0b10011001 /*4*/, 0b01001001 /*5*/, 0b01000001 /*6*/, 0b00011111 /*7*/
000054 0901
000055 c111                      		.db	0b00000001 /*8*/, 0b00001001 /*9*/, 0b00010001 /*a*/, 0b11000001 /*b*/
000056 8561
000057 7161                      		.db	0b01100001 /*c*/, 0b10000101 /*d*/, 0b01100001 /*e*/, 0b01110001 /*f*/
                                 
                                 		//extra simbols for 7seg display
000058 fd39
000059 ff73                      		.db	0b00111001 /*grad*/, 0b11111101 /*minus*/, 0b01110011 /*r*/, 0xff /*space*/
                                 
                                 	errorString7: 
00005a 120e
00005b 1312                      		.db chE, chR, chR, chSpace
                                 	
                                 
                                 	reset:
                                 
00005c e100                      		ldi temp, high(ramend) ; setting up stack pointer
00005d bf0e                      		out sph, temp
00005e ef0f                      		ldi temp, low(ramend)
00005f bf0d                      		out spl, temp
                                 
                                 		; setting up ports
000060 e908                      		ldi temp, 0b10011000 ; 0,1,2-in (read column), 3,4 - out (select row), 7 - out (check all buttons)
000061 bb0a                      		out ddra, temp
000062 e800                      		ldi temp, 0b10000000 ; enable continuous check if any button is pressed
000063 bb0b                      		out porta, temp
                                 
000064 ee00                      		ldi temp, 0b11100000 ; set last hree bits of portB to be output
000065 bb07                      		out ddrb, temp
                                 
000066 ef0f                      		ldi temp, 0b11111111 ; set all pins of portC to be output
000067 bb04                      		out ddrc, temp
                                 
000068 e004                      		ldi temp, speaker_pin_position
000069 e810                      		ldi temp2, engine_flap_pin_pos
00006a 2b01                      		or temp, temp2
00006b e410                      		ldi temp2, outside_flap_pin_pos
00006c 2b01                      		or temp, temp2
00006d bb01                      		out ddrd, temp
                                 
00006e ef0f                      		ldi temp, 0xff ;heater, cooler, 2,3 - flap state, 4-7 step engines (fans)
00006f b902                      		out ddre, temp
                                 
000070 ef0e                      		ldi temp, 0b11111110 ; 0 - thermSensors in, 1-4 selected thermalSensor, 6-7 selected flap
000071 9300 0061                 		sts ddrf, temp
                                 
                                 
                                 		//setting up external interrupts
000073 e003                      		ldi temp, 0b00000011 ; enable external intrruption int0, int1
000074 bf09                      		out eimsk, temp
                                 
000075 e00f                      		ldi temp, 0b00001111 ; set ext interrupt0 and interrupt1 on rising edge
000076 9300 006a                 		sts eicra, temp
                                 
                                 		//setting up timers
000078 e005                      		ldi temp, tccr0_setup_byte
000079 bf03                      		out tccr0, temp ; set timer0 speed
00007a e008                      		ldi temp, assr_setup_byte
00007b bf00                      		out assr, temp ; select async oscilator ( timer0 will be super slow and independent from main clock)
                                 
00007c e005                      		ldi temp, tccr1b_setup_byte ; setting up timer1 speed
00007d bd0e                      		out tccr1b, temp;
00007e ef0f                      		ldi temp, 0xff ; reset timer
00007f e010                      		ldi temp2, 0x00
000080 bd0d                      		out tcnt1h, temp
000081 bd1c                      		out tcnt1l, temp2
                                 
000082 e005                      		ldi temp, tccr2_setup_byte
000083 bd05                      		out tccr2, temp ; set timer2 speed
                                 
000084 e003                      		ldi temp, tccr3b_setup_byte ; setting up timer3 speed
000085 9300 008a                 		sts tccr3b, temp
                                 
000087 e405                      		ldi temp, timsk_setup_byte
000088 bf07                      		out timsk, temp ; enable interupts on timers overflowing
                                 
000089 e004                      		ldi temp, etimsk_setup_byte
00008a 9300 007d                 		sts etimsk, temp
                                 
                                 
00008c e600                      		ldi temp, 0b01100000 ; use external cap in adc, left adjust the result
00008d b907                      		out admux, temp
                                 
00008e ed0f                      		ldi temp, 0b11011111 ; en adc, start conv, , clear int flag, enable interuptions, setup prescaler
00008f b906                      		out adcsra, temp
                                 
                                 	
000090 6860                      		sbr eventsFlags1, ef_load_target_temp ; try to load target temp on start
                                 
000091 9478                      		sei ;  allow interrupts
                                 
                                 
                                 	backgroundProcess:
000092 fd56                      		sbrc eventsFlags0, ef_update_sound_type_n
000093 940e 031b                 			call updateSoundType
000095 fd57                      		sbrc eventsFlags0, ef_update_sound_wave_state_n
000096 940e 0374                 			call updateWaveState
000098 fd55                      		sbrc eventsFlags0, ef_handle_input_n
000099 940e 0384                 			call readInput
00009b fd54                      		sbrc eventsFlags0, ef_update_7seg_screen_n
00009c 940e 03ca                 			call update7segScreen
00009e fd53                      		sbrc eventsFlags0, ef_read_analog_sensors_n
00009f 940e 04c4                 			call readAnalogSensors
0000a1 fd52                      		sbrc eventsFlags0, ef_save_target_temperature_n
0000a2 940e 0246                 			call saveTargetTemperature
0000a4 fd51                      		sbrc eventsFlags0, ef_update_heater_n
0000a5 940e 0280                 			call updateConditioner
0000a7 fd50                      		sbrc eventsFlags0, ef_update_conditioner_fan_n
0000a8 940e 02e2                 			call updateConditionerFan
                                 
0000aa fd67                      		sbrc eventsFlags1, ef_load_target_temp_n
0000ab 940e 0254                 			call loadTargetTemperature
0000ad fd66                      		sbrc eventsFlags1, ef_update_program_timers_n
0000ae 940e 014d                 			call updateProgramTimers 
0000b0 fd65                      		sbrc eventsFlags1, ef_update_flaps_n
0000b1 940e 02f7                 			call updateFlaps
0000b3 fd63                      		sbrc eventsFlags1, ef_update_tachometer_n
0000b4 940e 04e1                 			call updateTachometer
0000b6 fd64                      		sbrc eventsFlags1, ef_increment_tachometer_n
0000b7 940e 04f3                 			call incrementTachometerCounter
0000b9 fd62                      		sbrc eventsFlags1, ef_check_engine_temperature_n
0000ba 940e 0260                 			call checkEngineTemperature
0000bc fd61                      		sbrc eventsFlags1, ef_switch_display_data_n
0000bd 940e 03ac                 			call switchDisplayData
0000bf fd60                      		sbrc eventsFlags1, ef_handle_current_key_n
0000c0 940e 0109                 			call handleCurrentKey
                                 
0000c2 e0b1                      		ldi xh, high(eventsFlags2)
0000c3 e2af                      		ldi xl, low(eventsFlags2) 
0000c4 917c                      		ld tempFlag, x
0000c5 fd77                      		sbrc tempFlag, ef_check_outside_temperature_n
0000c6 940e 026f                 			call checkOutsideTemperature
0000c8 fd76                      		sbrc tempFlag, ef_check_acceleration_n
0000c9 940e 00cd                 			call checkAcceleration
                                 
0000cb 940c 0092                  	jmp backgroundProcess
                                 
                                 	checkAcceleration:
0000cd 7b7f                      		cbr tempFlag, ef_check_acceleration
0000ce 9370 012f                 		sts eventsFlags2, tempFlag
                                 
0000d0 e0b1                      		ldi xh, high(analogValuesTable)
0000d1 e0a0                      		ldi xl, low(analogValuesTable)
0000d2 e00c                      		ldi temp, accelerationFrontSensorZ
0000d3 0fa0                      		add xl, temp
0000d4 911c                      		ld temp2, x
                                 
0000d5 331a                      		cpi temp2, 128 - maxAllowedBackwardAcceleration
0000d6 f0b0                      			brlo frontCollision
                                 		
                                 		checkRearCollision:
0000d7 3e14                      			cpi temp2, 128 + maxAllowedForwardAcceleration
0000d8 f4c0                      				brsh rearCollision
                                 
                                 		
                                 
                                 		checkFrontLeftCollision:
0000d9 e0b1                      		ldi xh, high(analogValuesTable)
0000da e0a0                      		ldi xl, low(analogValuesTable)
0000db e00d                      		ldi temp, accelerationFrontSensorX
0000dc 0fa0                      		add xl, temp
0000dd 912c                      		ld temp3, x
                                 
                                 		
0000de 3a28                      		cpi temp3, 128 + maxAllowedSideAcceleration
0000df f4b0                      			brsh frontLeftCollision
                                 		
                                 		checkFrontRightCollision:
0000e0 3528                      			cpi temp3, 128 - maxAllowedSideAcceleration
0000e1 f0c8                      				brlo frontRightCollision
                                 
                                 		checkBackLeftCollision:
0000e2 e0b1                      		ldi xh, high(analogValuesTable)
0000e3 e0a0                      		ldi xl, low(analogValuesTable)
0000e4 e00e                      		ldi temp, accelerationRearSensorX
0000e5 0fa0                      		add xl, temp
0000e6 913c                      		ld temp4, x
                                 
0000e7 3a38                      		cpi temp4, 128 + maxAllowedSideAcceleration
0000e8 f4b8                      			brsh backLeftCollision
                                 
                                 		checkBackRightCollision:
0000e9 3538                      			cpi temp4, 128 - maxAllowedSideAcceleration
0000ea f0d0                      				brlo backRightCollision
0000eb 940c 0108                 				jmp endCheckCollision
                                 
                                 		frontCollision:
0000ed 940e 0139                 			call enableWarningSignal
0000ef 940c 00d7                 			jmp checkRearCollision
                                 
                                 		rearCollision:
0000f1 9a94                      			sbi portd, frontAirbagsTriggerPinNumber
0000f2 940e 0139                 			call enableWarningSignal
0000f4 940c 00d9                 			jmp checkFrontLeftCollision
                                 
                                 		frontLeftCollision:
0000f6 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
0000f7 940e 0139                 			call enableWarningSignal
0000f9 940c 00e0                 			jmp checkFrontRightCollision
                                 
                                 		frontRightCollision:
0000fb 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
0000fc 940e 0139                 			call enableWarningSignal
0000fe 940c 00e2                 			jmp checkBackLeftCollision
                                 
                                 		backLeftCollision:
000100 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
000101 940e 0139                 			call enableWarningSignal
000103 940c 00e9                 			jmp checkBackRightCollision
                                 
                                 		backRightCollision:
000105 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
000106 940e 0139                 			call enableWarningSignal
                                 
                                 		endCheckCollision:
000108 9508                      	ret
                                 
                                 	handleCurrentKey:
000109 7f6e                      		cbr eventsFlags1, ef_handle_current_key
00010a e0b1                      		ldi xh, high(currentKey)
00010b e2ac                      		ldi xl, low(currentKey)
00010c 910c                      		ld temp, x
00010d 310c                      		cpi temp, 28
00010e f041                      			breq callRizeTemperature
00010f 3104                      		cpi temp, 20
000110 f051                      			breq callLowerTemperature
000111 300c                      		cpi temp, 12
000112 f061                      			breq callHandleCancelKey
000113 3109                      		cpi temp, 25
000114 f071                      			breq callSwitchConditioner
000115 940c 0125                 			jmp handleCurrentKeyEnd
                                 
                                 		callRizeTemperature:
000117 940e 020d                 			call rizeTemperature
000119 940c 0125                 			jmp handleCurrentKeyEnd
                                 
                                 		callLowerTemperature:
00011b 940e 021f                 			call lowerTemperature
00011d 940c 0125                 			jmp handleCurrentKeyEnd
                                 
                                 		callHandleCancelKey:
00011f 940e 0126                 			call handleCancelKey
000121 940c 0125                 			jmp handleCurrentKeyEnd
                                 
                                 		callSwitchConditioner:
000123 940e 0231                 			call switchConditioner
                                 
                                 		handleCurrentKeyEnd:
000125 9508                      	ret
                                 
                                 
                                 	handleCancelKey:
000126 fd86                      		sbrc statesFlags0, sf_warning_signal_enabled_n
000127 940c 012b                 			jmp cancelWarning
000129 940c 0132                 			jmp endHandleCancelKey
                                 
                                 		cancelWarning:
00012b e000                      			ldi temp, 0
00012c 9300 012c                 			sts currentKey, temp ; current key is handled. so clear it
00012e 940e 013f                 			call disableWarningSignal
000130 940e 0149                 			call enableCancelSignal
                                 
                                 		endHandleCancelKey:
                                 
000132 9508                      	ret
                                 
                                 	resetSoundState:
000133 7d8f                      		cbr statesFlags0, sf_click_signal_enabled
000134 7e8f                      		cbr statesFlags0, sf_accept_signal_enabled
000135 7f87                      		cbr statesFlags0, sf_cancel_signal_enabled
000136 7b8f                      		cbr statesFlags0, sf_warning_signal_enabled
000137 778f                      		cbr statesFlags0, sf_sound_enabled
000138 9508                      	ret
                                 
                                 	enableWarningSignal:
000139 fd86                      		sbrc statesFlags0, sf_warning_signal_enabled_n
00013a 9508                      			ret ; return emmediately if it is already enabled
00013b 940e 0133                 		call resetSoundState
00013d 6480                      		sbr statesFlags0, sf_warning_signal_enabled
00013e 9508                      	ret
                                 
                                 	disableWarningSignal:
00013f 7b8f                      		cbr statesFlags0, sf_warning_signal_enabled
000140 9508                      	ret
                                 
                                 	enableClickSignal:
000141 940e 0133                 		call resetSoundState
000143 6280                      		sbr statesFlags0, sf_click_signal_enabled
000144 9508                      	ret
                                 
                                 	enableAcceptSignal:
000145 940e 0133                 		call resetSoundState
000147 6180                      		sbr statesFlags0, sf_accept_signal_enabled
000148 9508                      	ret
                                 
                                 	enableCancelSignal:
000149 940e 0133                 		call resetSoundState
00014b 6088                      		sbr statesFlags0, sf_cancel_signal_enabled
00014c 9508                      	ret
                                 
                                 	updateProgramTimers:
00014d ef0f                      		ldi temp, 0xff ; preset timer to change overflowing freq
00014e ef10                      		ldi temp2, 0xf0
00014f 9300 0089                 		sts tcnt3h, temp
000151 9310 0088                 		sts tcnt3l, temp2
                                 
000153 7b6f                      		cbr eventsFlags1, ef_update_program_timers
                                 
000154 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000155 940c 018d                 			jmp updTachTimer
                                 		
000157 e0b1                      		ldi xh, high(updateConditionerTimer) ; get timer from ram
000158 e1ae                      		ldi xl, low(updateConditionerTimer)
000159 910c                      		ld temp, x
00015a 9503                      		inc temp
00015b 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
00015c f011                      			breq setConditionerFlag
00015d 940c 0161                 			jmp saveConditionerTimer
                                 
                                 		setConditionerFlag:
00015f 6052                      			sbr eventsFlags0, ef_update_heater ; create "update_heater" task
                                 
000160 e000                      			ldi temp, 0 ; reset heater update timer
                                 
                                 		saveConditionerTimer:
000161 9300 011e                 			sts updateConditionerTimer, temp ;and save it to ram
                                 
                                 		; CONDITIONER FAN ;
000163 e0b1                      		ldi xh, high(conditionerFanTimer0) ; get temperature from ram
000164 e2a1                      		ldi xl, low(conditionerFanTimer0)
000165 910c                      		ld temp, x
000166 3f0f                      		cpi temp, 255 
000167 f029                      			breq checkCondFanTimer1	
000168 9503                      			inc temp
000169 9300 0121                 			sts conditionerFanTimer0, temp
00016b 940c 0181                 			jmp endUpdateCondFanTimer
                                 
                                 		checkCondFanTimer1:
00016d ec00                      			ldi temp, 128 + 64
00016e 9300 0121                 			sts conditionerFantimer0, temp
000170 e0b1                      			ldi xh, high(conditionerFanTimer1)
000171 e2a2                      			ldi xl, low(conditionerFanTimer1)
000172 910c                      			ld temp, x
                                 
000173 3f0f                      			cpi temp, 255
000174 f029                      				breq setUpdateCondFanFlag
000175 9503                      				inc temp
000176 9300 0122                 				sts conditionerFanTimer1, temp
000178 940c 0181                 				jmp endUpdateCondFanTimer
                                 				
                                 				
                                 
                                 		setUpdateCondFanFlag:
00017a 6051                      			sbr eventsFlags0, ef_update_conditioner_fan ; start upate fan task
                                 
00017b ec00                      			ldi temp, 128 + 64
00017c 9300 0121                 			sts conditionerFanTimer0, temp ; reset timer
00017e ef09                      			ldi temp, condFanSpeed
00017f 9300 0122                 			sts conditionerFanTimer1, temp
                                 		
                                 		endUpdateCondFanTimer:
                                 
                                 
                                 
                                 		////////////udpate flaps timer ///////////
000181 e0b1                      		ldi xh, high(flapsUpdateTimer) ; get flaps timer from ram
000182 e1af                      		ldi xl, low(flapsUpdateTimer)
000183 910c                      		ld temp, x
000184 9503                      		inc temp
000185 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
000186 f011                      			breq setUpdateFlapsFlag
000187 940c 018b                 			jmp saveUpdateFlapsTimer
                                 
                                 		setUpdateFlapsFlag:
000189 6260                      			sbr eventsFlags1, ef_update_flaps ; create "update_flaps" task
                                 
00018a e000                      			ldi temp, 0 ; reset flaps update timer
                                 
                                 		saveUpdateFlapsTimer:
00018b 9300 011f                 			sts flapsUpdateTimer, temp ;and save it to ram
                                 
                                 
                                 		
                                 		updTachTimer:
00018d e0b1                      		ldi xh, high(tachometerTimerL)
00018e e2a7                      		ldi xl, low(tachometerTimerL)
00018f 910c                      		ld temp, x
000190 9503                      		inc temp
000191 3f0f                      		cpi temp, 255 
000192 f011                      			breq incrementTachTimerH
000193 940c 01a0                 			jmp saveTachTimerL
                                 
                                 		incrementTachTimerH:
000195 e000                      			ldi temp, 0
000196 9300 0127                 			sts tachometerTimerL, temp
                                 
000198 e0b1                      			ldi xh, high(tachometerTimerH)
000199 e2a6                      			ldi xl, low(tachometerTimerH)
00019a 910c                      			ld temp, x
00019b 9503                      			inc temp
00019c 3f0f                      			cpi temp, 255
00019d f051                      				breq resetTachTimer
00019e 940c 01a4                 				jmp saveTachTimerH
                                 
                                 		saveTachTimerL:
0001a0 9300 0127                 			sts tachometerTimerL, temp
0001a2 940c 01af                 			jmp endTachTimerUpdate
                                 
                                 		saveTachTimerH:
0001a4 9300 0126                 			sts tachometerTimerH, temp
0001a6 940c 01af                 			jmp endTachTimerUpdate
                                 
                                 		resetTachTimer:
0001a8 ef0c                      			ldi temp, 128 + 64 + 32 + 16 + 8 + 4
0001a9 9300 0126                 			sts tachometerTimerH, temp
0001ab e000                      			ldi temp, 0
0001ac 9300 0127                 			sts tachometerTimerL, temp
                                 			
0001ae 6068                      			sbr eventsFlags1, ef_update_tachometer
                                 		
                                 		endTachTimerUpdate:
                                 
                                 
                                 		//////////// switch displayed data timer ///////////////////
0001af e0b1                      		ldi xh, high(switchDisplayDataTimerL) ; get timer from ram
0001b0 e1ac                      		ldi xl, low(switchDisplayDataTimerL)
0001b1 910c                      		ld temp, x
0001b2 9503                      		inc temp
0001b3 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001b4 f021                      			breq incSwitchDisplayDataTimerH
0001b5 9300 011c                 			sts switchDisplayDataTimerL, temp
0001b7 940c 01c8                 			jmp endDisplayDataTimerUpdate
                                 
                                 		incSwitchDisplayDataTimerH:
0001b9 e000                      			ldi temp, 0
0001ba 9300 011c                 			sts switchDisplayDataTimerL, temp
                                 
0001bc e0b1                      			ldi xh, high(switchDisplayDataTimerH)
0001bd e1ab                      			ldi xl, low(switchDisplayDataTimerH)
0001be 910c                      			ld temp, x
0001bf 9503                      			inc temp
0001c0 3f0f                      			cpi temp, 255
0001c1 f011                      				breq setSwitchDisplayDataFlag
0001c2 940c 01c6                 				jmp saveSwitchDisplayDataTimerH
                                 
                                 			setSwitchDisplayDataFlag:
0001c4 6062                      				sbr eventsFlags1, ef_switch_display_data
                                 
                                 				resetDisplayDataTimerH:
0001c5 ee00                      				ldi temp, displayDataSwitchingFreq ; reset  timer
                                 
                                 			saveSwitchDisplayDataTimerH:
0001c6 9300 011b                 				sts switchDisplayDataTimerH, temp ;and save it to ram
                                 		
                                 		endDisplayDataTimerUpdate:
                                 
                                 
                                 		
                                 		////////////udpate check engine temperature timer ///////////
0001c8 e0b1                      		ldi xh, high(checkEngineTemperatureTimer) ; get flaps timer from ram
0001c9 e2aa                      		ldi xl, low(checkEngineTemperatureTimer)
0001ca 910c                      		ld temp, x
0001cb 9503                      		inc temp
0001cc 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001cd f011                      			breq setCheckEngineTemperatureFlag
0001ce 940c 01d2                 			jmp saveCheckEngineTemperatureTimer
                                 
                                 		setCheckEngineTemperatureFlag:
0001d0 6064                      			sbr eventsFlags1, ef_check_engine_temperature ; create "update_flaps" task
                                 
0001d1 e000                      			ldi temp, 0 ; reset flaps update timer
                                 
                                 		saveCheckEngineTemperatureTimer:
0001d2 9300 012a                 			sts checkEngineTemperatureTimer, temp ;and save it to ram
                                 
                                 		endCheckEngineTemperatureTimerUpdate:
                                 
                                 		//////// handle the last pressed key timer //////////
0001d4 e0b1                      		ldi xh, high(handleCurrentKeyTimer)
0001d5 e2ad                      		ldi xl, low(handleCurrentKeyTimer)
0001d6 910c                      		ld temp, x
0001d7 9503                      		inc temp
0001d8 3f0e                      		cpi temp, 254
0001d9 f410                      			brsh setHandleCurrentKeyFlag
0001da 940c 01de                 			jmp saveHandleCurrentKeyTimer
                                 
                                 		setHandleCurrentKeyFlag:
0001dc 6061                      			sbr eventsFlags1, ef_handle_current_key
0001dd e000                      			ldi temp, 0
                                 
                                 		saveHandleCurrentKeyTimer:
0001de 9300 012d                 			sts handleCurrentKeyTimer, temp
                                 
                                 		endHandleCrrentKeyTimerUpdate:
                                 
                                 
                                 		////////// outside temp checking timer//////////
0001e0 e0b1                      		ldi xh, high(eventsFlags2)
0001e1 e2af                      		ldi xl, low(eventsFlags2)
0001e2 917c                      		ld tempFlag, x
0001e3 e0b1                      		ldi xh, high(checkOutsideTemperatureTimerL) ; get timer from ram
0001e4 e2a5                      		ldi xl, low(checkOutsideTemperatureTimerL)
0001e5 910c                      		ld temp, x
0001e6 9503                      		inc temp
0001e7 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001e8 f021                      			breq incCheckOutsideTemperatureTimerH
0001e9 9300 0125                 			sts checkOutsideTemperatureTimerL, temp
0001eb 940c 01fe                 			jmp endCheckOutsideTemperatreTimerUpdate
                                 
                                 		incCheckOutsideTemperatureTimerH:
0001ed e000                      			ldi temp, 0
0001ee 9300 0125                 			sts checkOutsideTemperatureTimerL, temp
                                 
0001f0 e0b1                      			ldi xh, high(CheckOutsideTemperatureTimerH)
0001f1 e2a4                      			ldi xl, low(CheckOutsideTemperatureTimerH)
0001f2 910c                      			ld temp, x
0001f3 9503                      			inc temp
0001f4 3f0f                      			cpi temp, 255
0001f5 f011                      				breq setCheckOutsideTemperatreFlag
0001f6 940c 01fc                 				jmp saveCheckOutsideTemperatreTimerH
                                 
                                 			setCheckOutsideTemperatreFlag:
0001f8 6870                      				sbr tempFlag, ef_check_outside_temperature
0001f9 9370 012f                 				sts eventsFlags2, tempFlag
                                 
                                 				resetCheckOutsideTemperatreTimerH:
0001fb ef00                      				ldi temp, checkOutsideTemperatureFreq ; reset  timer
                                 
                                 			saveCheckOutsideTemperatreTimerH:
0001fc 9300 0124                 				sts CheckOutsideTemperatureTimerH, temp ;and save it to ram
                                 		
                                 		endCheckOutsideTemperatreTimerUpdate:
                                 
                                 
                                 		//////// check accelerations timer //////////
0001fe e0b1                      		ldi xh, high(checkAccelerationTimer)
0001ff e2ae                      		ldi xl, low(checkAccelerationTimer)
000200 910c                      		ld temp, x
000201 9503                      		inc temp
000202 3f0e                      		cpi temp, 254
000203 f410                      			brsh setCheckAccelerationFlag
000204 940c 020a                 			jmp saveCheckAccelerationTimer
                                 
                                 		setCheckAccelerationFlag:
000206 6470                      			sbr tempFlag, ef_check_acceleration
000207 9370 012f                 			sts eventsFlags2, tempFlag
000209 e000                      			ldi temp, 0
                                 
                                 		saveCheckAccelerationTimer:
00020a 9300 012e                 			sts checkAccelerationTimer, temp
                                 
                                 		endCheckAccelerationUpdate:
                                 
                                 
00020c 9508                      	ret
                                 
                                 
                                 	rizeTemperature:
00020d ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
00020e 9508                      			ret
                                 		
00020f 940e 0141                 		call enableClickSignal ; make click sound
000211 e000                      		ldi temp, 0
000212 9300 012c                 		sts currentKey, temp
000214 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000215 e1ad                      		ldi xl, low(targetTemperature)
000216 910c                      		ld temp, x
000217 9503                      		inc temp ; increment temperature
                                 		
000218 310f                      		cpi temp, 31 ; limit temperature to 30 grad
000219 f008                      			brlo saveTemperatureToRam
00021a e10e                      			ldi temp, 30
                                 
                                 		saveTemperatureToRam:
00021b 9300 011d                 			sts targetTemperature, temp ;and save it to ram
                                 
00021d 6054                      		sbr eventsFlags0, ef_save_target_temperature
00021e 9508                      	ret
                                 
                                 	lowerTemperature:
00021f ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000220 9508                      			ret
                                 		
000221 940e 0141                 		call enableClickSignal ; make click sound
                                 
000223 e000                      		ldi temp, 0
000224 9300 012c                 		sts currentKey, temp
000226 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000227 e1ad                      		ldi xl, low(targetTemperature)
000228 910c                      		ld temp, x
000229 950a                      		dec temp ; decrement temperature
                                 
00022a 300a                      		cpi temp, 10 ; limit temperature to 30 grad
00022b f77c                      			brge saveTemperatureToRam
00022c e00a                      			ldi temp, 10
                                 
00022d 9300 011d                 		sts targetTemperature, temp ;and save it to ram
                                 
00022f 6054                      		sbr eventsFlags0, ef_save_target_temperature
000230 9508                      	ret
                                 
                                 	switchConditioner:
000231 e000                      		ldi temp, 0
000232 9300 012c                 		sts currentKey, temp
000234 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n
000235 940c 0239                 			jmp cond_en
000237 940c 023e                 			jmp cond_dis
                                 
                                 		cond_en:
000239 6084                      			sbr statesFlags0, sf_conditioner_enabled
00023a 940e 0145                 			call enableAcceptSignal
00023c 940c 0245                 			jmp endSwitchConditioner
                                 		cond_dis:
00023e 7f8b                      			cbr statesFlags0, sf_conditioner_enabled
00023f 940e 0149                 			call enableCancelSignal
000241 9818                      			cbi porte, heater_pin_number
000242 9819                      			cbi porte, cooler_pin_number
000243 940c 0245                 			jmp endSwitchConditioner
                                 		endSwitchConditioner:
000245 9508                      	ret
                                 
                                 
                                 
                                 	saveTargetTemperature:
000246 99e1                      		sbic eecr, eewe ; wait for completion of previous write
000247 940c 0253                 			jmp endWritingAttempt
000249 e000                      		ldi temp, targetTempSavingAddr ; setup address where to wirte
00024a bb0f                      		out eearh, temp
00024b bb0e                      		out eearl, temp
                                 		
00024c e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
00024d e1ad                      		ldi xl, low(targetTemperature)
00024e 910c                      		ld temp, x
                                 
00024f bb0d                      		out eedr, temp ; store data to data register
000250 9ae2                      		sbi eecr, eemwe ; write logical one to eemwe
000251 9ae1                      		sbi eecr, eewe ; start eeprom write by setting eewe
                                 
000252 7f5b                      		cbr eventsFlags0, ef_save_target_temperature ; end writing task
                                 
                                 		endWritingAttempt:
                                 
000253 9508                      	ret
                                 
                                 	loadTargetTemperature:
000254 99e1                      		sbic eecr, eewe ; wait for completion of previous write
000255 940c 025f                 			jmp endReadAttempt
000257 e000                      		ldi temp, targetTempSavingAddr
000258 bb0f                      		out eearh, temp
000259 bb0e                      		out eearl, temp
00025a 9ae0                      		sbi  eecr, eere ; start eeprom read by writing eere
00025b b30d                      		in temp, eedr ; read data from data register
00025c 9300 011d                 		sts targetTemperature, temp
                                 
00025e 776f                      		cbr eventsFlags1, ef_load_target_temp ; end loading task if it success
                                 		
                                 		endReadAttempt:
00025f 9508                      	ret
                                 
                                 	checkEngineTemperature:
000260 7f6b                      		cbr eventsFlags1, ef_check_engine_temperature
000261 e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
000262 e0a0                      		ldi xl, low(analogValuesTable)
000263 e032                      		ldi temp4, engineThermalSensorNum
000264 0fa3                      		add xl, temp4
000265 910c                      		ld temp, x
                                 
000266 3f08                      		cpi temp, 128 + 120 ; if engine temperature is more than 120C
000267 f420                      			brsh enableEngineTempWarning
000268 3300                      		cpi temp, 128 - 80 ; if enginge temperature is strangely low then warning too
000269 f010                      			brlo enableEngineTempWarning
00026a 940c 026e                 			jmp endEngineTemperatureCheck
                                 			
                                 		enableEngineTempWarning:
00026c 940e 0139                 			call enableWarningSignal
                                 
                                 		endEngineTemperatureCheck:
00026e 9508                      	ret
                                 
                                 	checkOutsideTemperature:
00026f 777f                      		cbr tempFlag, ef_check_outside_temperature
000270 9370 012f                 		sts eventsFlags2, tempFlag
                                 
000272 e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
000273 e0a0                      		ldi xl, low(analogValuesTable)
000274 e031                      		ldi temp4, outsideThermalSensorNum
000275 0fa3                      		add xl, temp4
000276 910c                      		ld temp, x
                                 
000277 3c06                      		cpi temp, 128 + 70 ; if  temperature is more then 70C than warning
000278 f420                      			brsh enableOutsideTempWarning
000279 3300                      		cpi temp, 128 - 80 ; if temperature lower then -80 than warning
00027a f010                      			brlo enableOutsideTempWarning
00027b 940c 027f                 			jmp endOutsideTemperatureCheck
                                 			
                                 		enableOutsideTempWarning:
00027d 940e 0139                 			call enableWarningSignal
                                 
                                 		endOutsideTemperatureCheck:
00027f 9508                      	ret
                                 
                                 	updateConditioner:
000280 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000281 9508                      			ret
000282 7f5d                      		cbr eventsFlags0, ef_update_heater
                                 
000283 e0b1                      		ldi xh, high(targetTemperature) ; get target temperature from ram
000284 e1ad                      		ldi xl, low(targetTemperature)
000285 910c                      		ld temp, x
                                 
000286 310f                      		cpi temp, 31
000287 f480                      			brsh condTemperatureWarning
000288 300a                      		cpi temp, 10
000289 f070                      			brlo condTemperatureWarning
                                 
00028a e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
00028b e0a0                      		ldi xl, low(analogValuesTable)
00028c 911c                      		ld temp2, x
                                 
                                 		
                                 
00028d e0b1                      		ldi xh, high(analogValuesTable) ; get outside temperature from ram
00028e e0a0                      		ldi xl, low(analogValuesTable)
00028f e031                      		ldi temp4, outsideThermalSensorNum
000290 0fa3                      		add xl, temp4
000291 913c                      		ld temp4, x
                                 
000292 3c16                      		cpi temp2, 128 + 70 ; + 70C
000293 f420                      			brsh condTemperatureWarning
000294 3310                      		cpi temp2, 128 - 80
000295 f010                      			brlo condTemperatureWarning ; -80C
000296 940c 029a                 		jmp updateHeater
                                 
                                 		condTemperatureWarning:
000298 940e 0139                 			call enableWarningSignal
                                 
                                 		updateHeater:
00029a 3810                      		cpi temp2, 128 ; if temperature is minus then enable heater emmediately 
00029b f048                      			brlo enableHeater
00029c 5810                      			subi temp2, 128
                                 		
00029d 1710                      		cp temp2, temp
00029e f030                      			brlo enableHeater
00029f 940c 02a1                 			jmp disableHeater
                                 
                                 		disableHeater: ; ye ye ye useless, but just for code readability
0002a1 9818                      			cbi porte, heater_pin_number
0002a2 9a19                      			sbi porte, cooler_pin_number
0002a3 940c 02a7                 			jmp endUpdateConditioner
                                 
                                 		enableHeater:
0002a5 9a18                      			sbi porte, heater_pin_number
0002a6 9819                      			cbi porte, cooler_pin_number
                                 
                                 		; TODO add hummidity sensor and regulate it
                                 
                                 		endUpdateConditioner: 
0002a7 940e 02ac                 		call resolveEngineFlap
0002a9 940e 02c7                 		call resolveOutsideFlap
0002ab 9508                      	ret
                                 
                                 	resolveEngineFlap:
0002ac e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
0002ad e0a0                      		ldi xl, low(analogValuesTable)
0002ae 910c                      		ld temp, x
                                 
0002af e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
0002b0 e0a0                      		ldi xl, low(analogValuesTable)
0002b1 e032                      		ldi temp4, engineThermalSensorNum
0002b2 0fa3                      		add xl, temp4
0002b3 911c                      		ld temp2, x	
                                 
0002b4 1701                      		cp temp, temp2
0002b5 f038                      			brlo checkIfNeedWarmup
0002b6 940c 02b8                 			jmp checkIfNeedCooldown
                                 
                                 		checkIfNeedCooldown:
0002b8 9919                      			sbic porte, cooler_pin_number
0002b9 940c 02c2                 				jmp openEngineFlap
0002bb 940c 02c5                 				jmp closeEngineFlap
                                 
                                 		checkIfNeedWarmup:
0002bd 9918                      			sbic porte, heater_pin_number
0002be 940c 02c2                 				jmp openEngineFlap
0002c0 940c 02c5                 				jmp closeEngineFlap
                                 
                                 		openEngineFlap:
0002c2 9a97                      			sbi portd, engine_flap_pin_num
0002c3 940c 02c6                 			jmp endResolveEngineFlap
                                 
                                 		closeEngineFlap:
0002c5 9897                      			cbi portd, engine_flap_pin_num
                                 
                                 		endResolveEngineFlap:
0002c6 9508                      	ret
                                 
                                 	resolveOutsideFlap:
0002c7 e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
0002c8 e0a0                      		ldi xl, low(analogValuesTable)
0002c9 910c                      		ld temp, x
                                 
0002ca e0b1                      		ldi xh, high(analogValuesTable) ; get outside temperature from ram
0002cb e0a0                      		ldi xl, low(analogValuesTable)
0002cc e031                      		ldi temp4, outsideThermalSensorNum
0002cd 0fa3                      		add xl, temp4
0002ce 911c                      		ld temp2, x	
                                 
0002cf 1701                      		cp temp, temp2
0002d0 f038                      			brlo checkIfNeedWarmupFromOutside
0002d1 940c 02d3                 			jmp checkIfNeedCooldownFromOutside
                                 
                                 		checkIfNeedCooldownFromOutside:
0002d3 9919                      			sbic porte, cooler_pin_number
0002d4 940c 02dd                 				jmp openOutsideFlap
0002d6 940c 02e0                 				jmp closeOutsideFlap
                                 
                                 		checkIfNeedWarmupFromOutside:
0002d8 9918                      			sbic porte, heater_pin_number
0002d9 940c 02dd                 				jmp openOutsideFlap
0002db 940c 02e0                 				jmp closeOutsideFlap
                                 
                                 		openOutsideFlap:
0002dd 9a96                      			sbi portd, outside_flap_pin_num
0002de 940c 02e1                 			jmp endResolveOutsideFlap
                                 
                                 		closeOutsideFlap:
0002e0 9896                      			cbi portd, outside_flap_pin_num
                                 
                                 		endResolveOutsideFlap:
                                 
0002e1 9508                      	ret
                                 
                                 	updateConditionerFan:
0002e2 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
0002e3 9508                      			ret
0002e4 7f5e                      		cbr eventsFlags0, ef_update_conditioner_fan
                                 
0002e5 e0b1                      		ldi xh, high(conditionerFanState) ; get fan state from ram
0002e6 e2a3                      		ldi xl, low(conditionerFanState)
0002e7 910c                      		ld temp, x
0002e8 3000                      		cpi temp, 0
0002e9 f029                      			breq resetCondFanState
                                 
0002ea 9506                      		lsr temp
0002eb 3008                      		cpi temp, 0b00001000 ; if we are trying to lightup pin not connected to fan then reset it 
0002ec f011                      			breq resetCondFanState
0002ed 940c 02f0                 			jmp saveCondFanState
                                 		resetCondFanState:
0002ef e800                      			ldi temp, 0b10000000
                                 		saveCondFanState:
0002f0 9300 0123                 			sts conditionerFanState, temp ;and save it to ram	
0002f2 b113                      			in temp2, porte ; get current state of prote (to not broke other stuff connected to this port)
0002f3 701f                      			andi temp2, 0b00001111
0002f4 2b10                      			or temp2, temp ; out new fan state to porte
0002f5 b913                      			out porte, temp2
0002f6 9508                      	ret
                                 
                                 	updateFlaps:
0002f7 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
0002f8 9508                      			ret
0002f9 7d6f                      		cbr eventsFlags1, ef_update_flaps
                                 
0002fa e0f1                      		ldi zh, high(currentControlledFlap) ; get the number of a flap we wanna update now
0002fb e2e0                      		ldi zl, low(currentControlledFlap)
0002fc 8100                      		ld temp, z
                                 
0002fd e0b1                      		ldi xh, high(analogValuesTable) ; get current state of needed flap control from ram
0002fe e0a0                      		ldi xl, low(analogValuesTable)
0002ff e028                      		ldi temp3, 8 ; flaps controlls data begins from 8th byte
000300 0fa2                      		add xl, temp3 
000301 0fa0                      		add xl, temp ; ofset to current flap control byte
                                 	
000302 911c                      		ld temp2, x
                                 
000303 7c10                      		andi temp2, 0b11000000 ; leave only two most significant byts (every falp will have only 4 possible states)
000304 9512                      		swap temp2
                                 
000305 b121                      		in temp3, pine ; get the contents from porte
000306 7f23                      		andi temp3, 0b11110011 ; clear two pins controlling the flaps to rewrite them in next two commands
000307 2b21                      		or temp3, temp2 ; and combine it with the date we wanno output
000308 b923                      		out porte, temp3 ; then... output
                                 
000309 b120                      		in temp3, pinf ; the same trick with two pins of portf (selecting one of our 4 flaps)
00030a 732f                      		andi temp3, 0b00111111 
00030b 2f10                      		mov temp2, temp
00030c 9512                      		swap temp2
00030d 0f11                      		lsl temp2
00030e 0f11                      		lsl temp2
00030f 2b21                      		or temp3, temp2
000310 9320 0062                 		sts portf, temp3
                                 
000312 9503                      		inc temp
                                 		
000313 3004                      		cpi temp, 4 ; if next selected falp as "non existing" 5th flap then fump to first one 
000314 f410                      			brsh jumpToFirstFlap
000315 940c 0318                 			jmp saveNextFlapNum
                                 		
                                 		jumpToFirstFlap:
000317 e000                      			ldi temp, 0
                                 
                                 		saveNextFlapNum:
000318 9300 0120                 			sts currentControlledFlap, temp
00031a 9508                      	ret
                                 
                                 
                                 	updateSoundType:
00031b 7b5f                      		cbr eventsFlags0, ef_update_sound_type
                                 
00031c ef00                      		ldi temp, soundSignalsDelay ; reset timer immediately
00031d bf02                      		out tcnt0, temp
                                 		
00031e fd86                      		sbrc statesFlags0, sf_warning_signal_enabled_n
00031f 940c 032b                 			jmp updateWarningSignal ; if warning signal is enabled then update it
000321 fd85                      		sbrc statesFlags0, sf_click_signal_enabled_n
000322 940c 0337                 			jmp updateClickSignal
000324 fd84                      		sbrc statesFlags0, sf_accept_signal_enabled_n
000325 940c 0344                 			jmp updateAcceptSignal
000327 fd83                      		sbrc statesFlags0, sf_cancel_signal_enabled_n
000328 940c 035c                 			jmp updateCancelSignal
00032a 9508                      		ret	
                                 
                                 		updateWarningSignal:	
00032b ff87                      			sbrs statesFlags0, sf_sound_enabled_n
00032c 940c 0330                 				jmp warningSound_case_0
00032e 940c 0335                 				jmp warningSound_case_1
                                 				warningSound_case_0:
000330 ef0c                      					ldi temp, tone0
000331 9300 012b                 					sts currentTone, temp ; set sound tone
000333 6880                      					sbr statesFlags0, sf_sound_enabled ; enable sound
000334 9508                      				ret
                                 
                                 				warningSound_case_1:
000335 778f                      					cbr statesFlags0, sf_sound_enabled ; disable sound
000336 9508                      				ret
                                 
                                 		updateClickSignal:
000337 ff87                      			sbrs statesFlags0, sf_sound_enabled_n
000338 940c 033c                 				jmp clickSound_case_0 ; if we haven't clicked yet than click
00033a 940c 0341                 				jmp clickSound_case_1 ; otherwise end lcick signal
                                 
                                 				clickSound_case_0:
00033c ef0c                      					ldi temp, tone0
00033d 9300 012b                 					sts currentTone, temp ; set low sound tone  
00033f 6880                      					sbr statesFlags0, sf_sound_enabled ; enable sound
000340 9508                      				ret
                                 
                                 				clickSound_case_1:
000341 7d8f                      					cbr statesFlags0, sf_click_signal_enabled ; end click sound
000342 778f                      					cbr statesFlags0, sf_sound_enabled ; disable sound
000343 9508                      				ret
                                 
                                 		updateAcceptSignal:
000344 ff87                      			sbrs statesFlags0, sf_sound_enabled_n
000345 940c 0349                 				jmp acceptSound_case0 ; if sound is not enabled yet than enable it and set tone low
000347 940c 034e                 				jmp acceptSound_case1 ; otherwise if tone low then make it high. if tone high than end accept signal
                                 
                                 				acceptSound_case0:	
000349 ef0c                      					ldi temp, tone0		
00034a 9300 012b                 					sts currentTone, temp ; set low sound tone  
00034c 6880                      					sbr statesFlags0, sf_sound_enabled ; enable sound
00034d 9508                      				ret
                                 
                                 				acceptSound_case1:
00034e e0b1                      					ldi xh, high(currentTone)
00034f e2ab                      					ldi xl, low(currentTone)
000350 910c                      					ld temp, x
                                 
000351 3f0c                      					cpi temp, tone0
000352 f011                      						breq acceptSound_case2 ; if tone is low make it high
000353 940c 0359                 						jmp acceptSound_case3 ; otherwise end signal
                                 						acceptSound_case2:
000355 ef0e                      							ldi temp, tone1
000356 9300 012b                 							sts currentTone, temp ; set high sound tone  
000358 9508                      						ret
                                 						acceptSound_case3:
000359 778f                      							cbr statesFlags0, sf_sound_enabled	; disable sound
00035a 7e8f                      							cbr statesFlags0, sf_accept_signal_enabled ; end accept signal
00035b 9508                      						ret
                                 
                                 		updateCancelSignal:
00035c ff87                      			sbrs statesFlags0, sf_sound_enabled_n
00035d 940c 0361                 				jmp cancelSound_case0 ; if sound is not enabled yet than enable it and set tone low
00035f 940c 0366                 				jmp cancelSound_case1 ; otherwise if tone low then make it high. if tone high than end accept signal
                                 
                                 				cancelSound_case0:
000361 ef0e                      					ldi temp, tone1			
000362 9300 012b                 					sts currentTone, temp ; set high sound tone  
000364 6880                      					sbr statesFlags0, sf_sound_enabled ; enable sound
000365 9508                      				ret
                                 
                                 				cancelSound_case1:
000366 e0b1                      					ldi xh, high(currentTone)
000367 e2ab                      					ldi xl, low(currentTone)
000368 910c                      					ld temp, x
                                 
000369 3f0e                      					cpi temp, tone1
00036a f011                      						breq cancelSound_case2 ; if tone high make it low
00036b 940c 0371                 						jmp cancelSound_case3 ; otherwise end signal
                                 						cancelSound_case2:
00036d ef0c                      							ldi temp, tone0
00036e 9300 012b                 							sts currentTone, temp ; set sound tone  
000370 9508                      						ret
                                 						cancelSound_case3:
000371 778f                      							cbr statesFlags0, sf_sound_enabled	; disable sound
000372 7f87                      							cbr statesFlags0, sf_cancel_signal_enabled ; end accept signal
000373 9508                      						ret
                                 
                                 
                                 
                                 	updateWaveState:
000374 775f                      		cbr eventsFlags0, ef_update_sound_wave_state
                                 
000375 e0b1                      		ldi xh, high(currentTone)
000376 e2ab                      		ldi xl, low(currentTone)
000377 910c                      		ld temp, x
                                 
000378 bd04                      		out tcnt2, temp ; reset timer2 immediately to prevent bad sound
                                 
000379 ff87                      		sbrs statesFlags0, sf_sound_enabled_n ; if we should not prodice some sound
00037a 9518                      			reti ; do nothing
00037b 9b95                      			sbis portd, speaker_pin_number ; if this pin is low
00037c 940c 0380                 				jmp speakerWaveUp ; then make it high
00037e 940c 0382                 				jmp speakerWaveDown ; otherwise make it low
                                 
                                 			speakerWaveUp:
000380 9a95                      				sbi portd, speaker_pin_number ; make it high
000381 9518                      				reti
                                 			speakerWaveDown:
000382 9895                      				cbi portd, speaker_pin_number ; make it low
000383 9518                      				reti
                                 				; result sound wave 				____	  ____	    ____	  ____
                                 				; will be something like that:	___|	|____|	  |____|    |____|    |____
                                 
                                 
                                 	readInput:
000384 b709                      		in temp, eimsk ; disable external intrruption int0
000385 7f0e                      		andi temp, 0b11111110
000386 bf09                      		out eimsk, temp
                                 
000387 7d5f                      		cbr eventsFlags0, ef_handle_input
                                 		
000388 e000                      		ldi temp, 0b00000000 ; check first row
000389 bb0b                      		out porta, temp
00038a b309                      		in temp, pina ; get pressed button
                                 		
00038b 940e 039c                 		call checkInput
                                 
00038d e008                      		ldi temp, 0b00001000 ; check 2nd row
00038e bb0b                      		out porta, temp
00038f b309                      		in temp, pina 
                                 
000390 940e 039c                 		call checkInput
                                 
000392 e100                      		ldi temp, 0b00010000 ; check third row
000393 bb0b                      		out porta, temp
000394 b309                      		in temp, pina 
                                 
000395 940e 039c                 		call checkInput
                                 
000397 e108                      		ldi temp, 0b00011000 ; check the last row
000398 bb0b                      		out porta, temp
000399 b309                      		in temp, pina ; 
                                 
00039a 940c 03a3                 		jmp endReadingInput
                                 
                                 		checkInput:
00039c 2f10                      			mov temp2, temp
00039d 7017                      			andi temp2, 0b00000111 ; check only three bits indicating pressed button
00039e 3010                      			cpi temp2, 0
00039f f409                      			brne clearReturnAddr	
0003a0 9508                      		ret
                                 
                                 		clearReturnAddr:
0003a1 911f                      			pop temp2 ; removing returning addr from stack
0003a2 911f                      			pop temp2
                                 		endReadingInput:
0003a3 9300 012c                 			sts currentKey, temp ; finally save pressed key
0003a5 e800                      			ldi temp, 0b10000000 ; enable continuous keyboard checking
0003a6 bb0b                      			out porta, temp 
                                 			
0003a7 b709                      			in temp, eimsk
0003a8 e011                      			ldi temp2, 0b00000001
0003a9 2b01                      			or temp, temp2 ; enable external intrruption int0
0003aa bf09                      			out eimsk, temp
0003ab 9508                      	ret
                                 
                                 	switchDisplayData:
0003ac 7f6d                      		cbr eventsFlags1, ef_switch_display_data
                                 
0003ad fd86                      		sbrc statesFlags0, sf_warning_signal_enabled_n
0003ae 940c 03b3                 			jmp checkDisplayErrorMessage
0003b0 7f8e                      			cbr statesFlags0, sf_display_error_message
0003b1 940c 03bb                 			jmp normalDataSwitch
                                 
                                 		checkDisplayErrorMessage:
0003b3 ff80                      			sbrs statesFlags0, sf_display_error_message_n
0003b4 940c 03b8                 				jmp switchThroughError
0003b6 940c 03bb                 				jmp normalDataSwitch			
                                 
                                 		switchThroughError:
0003b8 6081                      			sbr statesFlags0, sf_display_error_message
0003b9 940c 03c9                 			jmp endSwitchingDisplayData
                                 
                                 		normalDataSwitch:
0003bb 7f8e                      			cbr statesFlags0, sf_display_error_message
0003bc e0b1                      		ldi xh, high(currentDisplayData) ; get "number" of type of data we wanna to be displayed
0003bd e1aa                      				ldi xl, low(currentDisplayData)
0003be 910c                      				ld temp, x
                                 
0003bf 3001                      				cpi temp, 1
0003c0 f428                      					brsh goToFirstData
                                 					;else next data
0003c1 9503                      					inc temp
0003c2 9300 011a                 					sts currentDisplayData, temp
0003c4 940c 03c9                 					jmp endSwitchingDisplayData
                                 
                                 					goToFirstData:
0003c6 e000                      						ldi temp, 0
0003c7 9300 011a                 						sts currentDisplayData, temp
                                 		
                                 		endSwitchingDisplayData:
                                 
0003c9 9508                      	ret
                                 
                                 	update7segScreen:
0003ca 7e5f                      		cbr eventsFlags0, ef_update_7seg_screen
                                 
0003cb ef0f                      		ldi temp, 0xff 
0003cc ef10                      		ldi temp2, 0xf0
0003cd bd0d                      		out tcnt1h, temp
0003ce bd1c                      		out tcnt1l, temp2
                                 		
0003cf e0b1                      		ldi xh, high(curPos7Seg) ; get pereviously printed display indicator from ram
0003d0 e1a9                      		ldi xl, low(curPos7Seg)
0003d1 912c                      		ld temp3, x
                                 
0003d2 9523                      		inc temp3
                                 
0003d3 3028                      		cpi temp3, 8
0003d4 f410                      			brsh jumpToFirst7seg
0003d5 940c 03f2                 			jmp printGlyph
                                 
                                 		jumpToFirst7seg:
0003d7 e020                      			ldi temp3, 0 ; select first indicator
0003d8 940e 0408                 			call clear7SegScrBuffer
0003da e0b1                      			ldi xh, high(currentDisplayData)
0003db e1aa                      			ldi xl, low(currentDisplayData)
0003dc 910c                      			ld temp, x
0003dd fd80                      			sbrc statesFlags0, sf_display_error_message_n
0003de 940c 03f0                 				jmp selectErrorMessage
0003e0 3000                      			cpi temp, 0
0003e1 f011                      				breq selectTemperaturesData ; TODO prevent failing compairing after SBR command in interruption handler
0003e2 3001                      			cpi temp, 1
0003e3 f041                      				breq selectTachometerData
                                 
                                 			selectTemperaturesData:
0003e4 940e 0454                 				call printEngineTemperature
0003e6 940e 043f                 				call printCurrentTemperature
0003e8 940e 042f                 				call printTargetTemperature
0003ea 940c 03f2                 				jmp endJumpToFirstSegment
                                 
                                 			selectTachometerData:
0003ec 940e 041c                 				call printTachometerValue
0003ee 940c 03f2                 				jmp endJumpToFirstSegment
                                 
                                 			selectErrorMessage:
0003f0 940e 046e                 				call printErrorMessage
                                 
                                 			endJumpToFirstSegment:
                                 
                                 
                                 		printGlyph:
0003f2 9320 0119                 			sts curPos7Seg, temp3
                                 
                                 			; get number of a glyph 
0003f4 e0b1                      			ldi xh, high(SevenSegScrBuff)
0003f5 e1a0                      			ldi xl, low(SevenSegScrBuff)
0003f6 0fa2                      			add  xl, temp3
                                 
0003f7 910c                      			ld temp, x
                                 
0003f8 e0f0                      			ldi zh,0
0003f9 eae0                      			ldi zl, charTable7seg * 2
                                 
0003fa 0fe0                      			add zl, temp
0003fb 9104                      			lpm temp, z
                                 
0003fc 3021                      			cpi temp3, 1
0003fd f021                      				breq printDot
0003fe 3024                      			cpi temp3, 4
0003ff f011                      				breq printDot
000400 940c 0403                 				jmp moveGlyphToscreen
                                 			
                                 			printDot:
000402 7f0e                      				andi temp, 0b11111110
                                 
                                 			moveGlyphToScreen:
000403 9522                      			swap temp3
000404 0f22                      			lsl temp3
000405 bb28                      			out portb, temp3 ; select place on display
                                 
000406 bb05                      			out portc, temp ; print glyph
000407 9508                      	ret
                                 
                                 	clear7SegScrBuffer:
000408 e0f0                      		ldi zh, 0
000409 eae0                      		ldi zl, charTable7seg * 2
00040a e103                      		ldi temp, chSpace ; load space glyph
                                 		;add zl, temp
                                 		;lpm temp, z
                                 
00040b 9300 0110                 		sts SevenSegScrBuff + 0, temp ; clear unused display indicators
00040d 9300 0111                 		sts SevenSegScrBuff + 1, temp
00040f 9300 0112                 		sts SevenSegScrBuff + 2, temp
000411 9300 0113                 		sts SevenSegScrBuff + 3, temp
000413 9300 0114                 		sts SevenSegScrBuff + 4, temp
000415 9300 0115                 		sts SevenSegScrBuff + 5, temp
000417 9300 0116                 		sts SevenSegScrBuff + 6, temp
000419 9300 0117                 		sts SevenSegScrBuff + 7, temp
00041b 9508                      	ret
                                 
                                 	printTachometerValue:
00041c e0b1                      		ldi xh, high(engineSpeed) ; get engineSpeed from ram
00041d e2a9                      		ldi xl, low(engineSpeed)
00041e 910c                      		ld temp, x
                                 	
00041f 940e 047d                 		call convertBinToDec
000421 2f10                      		mov temp2, temp
000422 701f                      		andi temp2, 0b00001111 ; select low page
000423 9310 0112                 		sts SevenSegScrBuff + 2 , temp2 ; place the actual glyph number in a buffer
                                 
000425 7f00                      		andi temp, 0b11110000 ; select high page
000426 9502                      		swap temp
000427 9300 0111                 		sts SevenSegScrBuff + 1, temp ; place the actual glyph nubmer in a buffer
                                 
000429 e000                      		ldi temp, ch0
00042a 9300 0113                 		sts SevenSegScrBuff + 3, temp
00042c 9300 0114                 		sts SevenSegScrBuff + 4, temp
00042e 9508                      	ret
                                 
                                 	
                                 	printTargetTemperature:
00042f ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000430 9508                      			ret
000431 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000432 e1ad                      		ldi xl, low(targetTemperature)
000433 910c                      		ld temp, x
                                 	
000434 940e 047d                 		call convertBinToDec
000436 2f10                      		mov temp2, temp
000437 701f                      		andi temp2, 0b00001111 ; select low page
000438 9310 0114                 		sts SevenSegScrBuff + 4, temp2 ; place the actual glyph number in a buffer
                                 
00043a 7f00                      		andi temp, 0b11110000 ; select high page
00043b 9502                      		swap temp
00043c 9300 0113                 		sts SevenSegScrBuff + 3, temp ; place the actual glyph nubmer in a buffer
00043e 9508                      	ret
                                 
                                 	printCurrentTemperature:
00043f e0b1                      		ldi xh, high(analogValuesTable) ; get temperature from ram
000440 e0a0                      		ldi xl, low(analogValuesTable)
000441 910c                      		ld temp, x
                                 
000442 3800                      		cpi temp, 128 ; check right at the beggining if this number negative
000443 f420                      			brsh convertTemperature
                                 
                                 		negateTemperature:
000444 e111                      			ldi temp2,  chMinus ; "-" glyph number in a table
000445 9310 0115                 			sts SevenSegScrBuff + 5, temp2
000447 9500                      			com temp
                                 			
                                 		convertTemperature:
000448 5800                      			subi temp, 128
000449 940e 047d                 			call convertBinToDec
                                 	
00044b 2f10                      			mov temp2, temp
00044c 701f                      			andi temp2, 0b00001111 ; select low page
00044d 9310 0117                 			sts SevenSegScrBuff + 7, temp2 ; place the actual glyph number in a buffer
                                 
00044f 7f00                      			andi temp, 0b11110000 ; select high page
000450 9502                      			swap temp
000451 9300 0116                 			sts SevenSegScrBuff + 6, temp ; place the actual glyph nubmer in a buffer
000453 9508                      	ret
                                 
                                 	printEngineTemperature:
000454 e0b1                      		ldi xh, high(analogValuesTable) ; get temperature from ram
000455 e0a0                      		ldi xl, low(analogValuesTable)
000456 e002                      		ldi temp, 2
000457 0fa0                      		add xl, temp
000458 910c                      		ld temp, x
                                 		
000459 3800                      		cpi temp, 128
00045a f068                      		 brlo printEngineTempNegative
                                 
00045b 5800                      		subi temp, 128
00045c 940e 047d                 		call convertBinToDec
                                 	
00045e 2f10                      		mov temp2, temp
00045f 701f                      		andi temp2, 0b00001111 ; select low page
000460 9310 0111                 		sts SevenSegScrBuff + 1, temp2 ; place the actual glyph number in a buffer
                                 
000462 7f00                      		andi temp, 0b11110000 ; select high page
000463 9502                      		swap temp
000464 9300 0110                 		sts SevenSegScrBuff, temp ; place the actual glyph nubmer in a buffer
000466 940c 046d                 		jmp endEngineTempPrinting
                                 
                                 		printEngineTempNegative:
000468 e101                      			ldi temp, chMinus ; load "minus" gliph number
000469 9300 0110                 			sts SevenSegScrBuff, temp
00046b 9300 0111                 			sts SevenSegScrBuff + 1, temp
                                 
                                 		endEngineTempPrinting:
00046d 9508                      	ret
                                 
                                 	printErrorMessage:	
00046e e00e                      		ldi temp, chE
00046f 9300 0110                 		sts SevenSegScrBuff, temp
000471 e102                      		ldi temp, chR
000472 9300 0111                 		sts SevenSegScrBuff + 1, temp
000474 9300 0112                 		sts SevenSegScrBuff + 2, temp
000476 e000                      		ldi temp, ch0
000477 9300 0113                 		sts sevenSegScrBuff + 3, temp
000479 e102                      		ldi temp, chR
00047a 9300 0114                 		sts sevenSegScrBuff + 4, temp
00047c 9508                      	ret
                                 
                                 	convertBinToDec:
00047d 3604                      		cpi temp, 100 ; check right at the beggining if this number is to big to display it on the screen
00047e f5d8                      		brsh btdMax
00047f e010                      		ldi temp2, 0 ; yeeeeeee no looooopsss ahahahhachchahhhacha
000480 300a                      			cpi temp, 10
000481 f414                      			brge increaseTens0
000482 940c 04c0                 				jmp setLowPage
                                 		increaseTens0:
000484 500a                      			subi temp, 10
000485 9513                      			inc temp2
000486 300a                      			cpi temp, 10
000487 f414                      			brge increaseTens1
000488 940c 04c0                 				jmp setLowPage
                                 		increaseTens1:
00048a 500a                      			subi temp, 10
00048b 9513                      			inc temp2
00048c 300a                      			cpi temp, 10
00048d f414                      			brge increaseTens2
00048e 940c 04c0                 				jmp setLowPage
                                 		increaseTens2:
000490 500a                      			subi temp, 10
000491 9513                      			inc temp2
000492 300a                      			cpi temp, 10
000493 f414                      			brge increaseTens3
000494 940c 04c0                 				jmp setLowPage
                                 		increaseTens3:
000496 500a                      			subi temp, 10
000497 9513                      			inc temp2
000498 300a                      			cpi temp, 10
000499 f414                      			brge increaseTens4
00049a 940c 04c0                 				jmp setLowPage
                                 		increaseTens4:
00049c 500a                      			subi temp, 10
00049d 9513                      			inc temp2
00049e 300a                      			cpi temp, 10
00049f f414                      			brge increaseTens5
0004a0 940c 04c0                 				jmp setLowPage
                                 		increaseTens5:
0004a2 500a                      			subi temp, 10
0004a3 9513                      			inc temp2
0004a4 300a                      			cpi temp, 10
0004a5 f414                      			brge increaseTens6
0004a6 940c 04c0                 				jmp setLowPage
                                 		increaseTens6:
0004a8 500a                      			subi temp, 10
0004a9 9513                      			inc temp2
0004aa 300a                      			cpi temp, 10
0004ab f414                      			brge increaseTens7
0004ac 940c 04c0                 				jmp setLowPage
                                 		increaseTens7:
0004ae 500a                      			subi temp, 10
0004af 9513                      			inc temp2
0004b0 300a                      			cpi temp, 10
0004b1 f414                      			brge increaseTens8
0004b2 940c 04c0                 				jmp setLowPage
                                 		increaseTens8:
0004b4 500a                      			subi temp, 10
0004b5 9513                      			inc temp2
0004b6 301a                      			cpi temp2, 10
0004b7 f414                      				brge btdMax
0004b8 940c 04c0                 				jmp setLowPage
                                 		btdMax:
0004ba e019                      			ldi temp2, 9
0004bb 2f01                      			mov temp, temp2
0004bc 9502                      			swap temp
0004bd 0f01                      			add temp, temp2
                                 			
0004be 940c 04c3                 			jmp endBTDConv
                                 
                                 		setLowPage:
0004c0 9502                      			swap temp ; move low number to high page
0004c1 0f01                      			add temp, temp2 ; save hig number to low page
0004c2 9502                      			swap temp
                                 
                                 		endBTDConv:	
0004c3 9508                      	ret
                                 
                                 
                                 	readAnalogSensors:
0004c4 7f57                      		cbr eventsFlags0, ef_read_analog_sensors
                                 
0004c5 e0b1                      		ldi xh, high(currentSensorNum) ; get the nubmer of thermal sensor we wanna read from
0004c6 e1a8                      		ldi xl, low(currentSensorNum)
0004c7 911c                      		ld temp2, x
                                 
0004c8 e0f1                      		ldi zh, high(analogValuesTable) ; seting up addres of the beginning of temperatuers table
0004c9 e0e0                      		ldi zl, low(analogValuesTable)
                                 
0004ca 0fe1                      		add zl, temp2 ; apply offset to store data to correct place in a table
                                 
0004cb b104                      		in temp, adcl
0004cc b105                      		in temp, adch
0004cd 8300                      		st z, temp ; and finally store it
                                 
0004ce 9513                      		inc temp2 ; select next sensor value to be readen in the next iterration
                                 
                                 		
0004cf 3110                      		cpi temp2, 16 ; if next sensor is "non existing" 17th sensor then return to first one
0004d0 f414                      			brge jumpToFirstSensor
0004d1 940c 04d4                 			jmp saveNextSensorNumber ; else just save the next sensor nubmer
                                 
                                 		jumpToFirstSensor:
0004d3 e010                      			ldi temp2, 0
                                 
                                 		saveNextSensorNumber:
0004d4 9310 0118                 			sts currentSensorNum, temp2
0004d6 0f11                      			lsl temp2
0004d7 b100                      			in temp, pinf ; get content of portf
0004d8 7e01                      			andi temp, 0b11100001 ; clear 4 bits to rewrite them later
0004d9 2b10                      			or temp2, temp
0004da 9310 0062                 			sts portf, temp2
                                 
0004dc e600                      		ldi temp, 0b01100000 ; and restart adc after all
0004dd b907                      		out admux, temp
0004de ed0e                      		ldi temp, 0b11011110
0004df b906                      		out adcsra, temp
0004e0 9508                      	ret
                                 
                                 	updateTachometer:
0004e1 7f67                      		cbr eventsFlags1, ef_update_tachometer
                                 		
0004e2 e0b1                      		ldi xh, high(tachometerCounter) ; get value counted by tachometer counter durring 0.1 sec
0004e3 e2a8                      		ldi xl, low(tachometerCounter)
0004e4 910c                      		ld temp, x
                                 		;inc temp ; some kind of trikky compensation
                                 
0004e5 e016                      		ldi temp2, 6
0004e6 9f01                      		mul temp, temp2 ; because it is 6*10 seconds in one minute
0004e7 2d00                      		mov temp, r0 ; get product low (numbers will not be to big)
                                 
                                 		
                                 
0004e8 3600                      		cpi temp, 96
0004e9 f410                      			brsh tachometerMax
0004ea 940c 04ed                 			jmp saveEngineSpeed
                                 
                                 		tachometerMax:
0004ec e603                      			ldi temp, 99
                                 		saveEngineSpeed:
0004ed 9300 0129                 			sts engineSpeed, temp
0004ef e000                      			ldi temp, 0
0004f0 9300 0128                 			sts tachometerCounter, temp
0004f2 9508                      	ret
                                 
                                 	incrementTachometerCounter:
0004f3 7e6f                      		cbr eventsFlags1, ef_increment_tachometer
                                 
0004f4 b709                      		in temp, eimsk ; disable external intrruption int1
0004f5 7f0d                      		andi temp, 0b11111101
0004f6 bf09                      		out eimsk, temp
                                 
0004f7 e0b1                      		ldi xh, high(tachometerCounter)
0004f8 e2a8                      		ldi xl, low(tachometerCounter)
0004f9 910c                      		ld temp, x
                                 		
0004fa 3f0f                      		cpi temp, 255
0004fb f029                      			breq endIncTachCounter
0004fc 940c 04fe                 			jmp incTachCounter
                                 
                                 		incTachCounter:
0004fe 9503                      			inc temp
0004ff 9300 0128                 			sts tachometerCounter, temp
                                 		
                                 		endIncTachCounter:
000501 b709                      			in temp, eimsk
000502 e012                      			ldi temp2, 0b00000010
000503 2b01                      			or temp, temp2 ; enable external intrruption int1
000504 bf09                      			out eimsk, temp
000505 9508                      	ret
                                 	
                                 
                                 	////////////INTERRUPTIONS HANDLERS/////////////
                                 	extInt0Handler:
000506 b74f                      		in tempInter, sreg
000507 6250                      		sbr eventsFlags0, ef_handle_input
000508 bf4f                      		out sreg, tempInter
000509 9518                      	reti
                                 
                                 	extInt1Handler:
00050a b74f                      		in tempInter, sreg
00050b 6160                      		sbr eventsFlags1, ef_increment_tachometer
00050c bf4f                      		out sreg, tempInter
00050d 9518                      	reti
                                 
                                 	timer0OvfHandler:
00050e b74f                      		in tempInter, sreg
00050f 6450                      		sbr eventsFlags0, ef_update_sound_type
000510 bf4f                      		out sreg, tempInter
000511 9518                      	reti
                                 
                                 	timer1OvfHandler:
000512 b74f                      		in tempInter, sreg
000513 6150                      		sbr eventsFlags0, ef_update_7seg_screen
000514 bf4f                      		out sreg, tempInter
000515 9518                      	reti
                                 
                                 	timer2OvfHandler: 
000516 b74f                      		in tempInter, sreg
000517 6850                      		sbr eventsFlags0, ef_update_sound_wave_state
000518 bf4f                      		out sreg, tempInter
000519 9518                      	reti
                                 
                                 	timer3OvfHandler:
00051a b74f                      		in tempInter, sreg
00051b 6460                      		sbr eventsFlags1, ef_update_program_timers
00051c bf4f                      		out sreg, tempInter
00051d 9518                      	reti
                                 
                                 	adcConvertionHandler:	
00051e b74f                      		in tempInter, sreg
00051f 6058                      		sbr eventsFlags0, ef_read_analog_sensors
000520 bf4f                      		out sreg, tempInter


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :  47 y  :   0 z  :   3 r0 :   1 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 350 r17:  85 r18:  24 r19:  14 r20:  14 
r21:  25 r22:  24 r23:  12 r24:  48 r25:   0 r26:  59 r27:  47 r28:   0 
r29:   0 r30:   6 r31:   4 
Registers used: 16 out of 35 (45.7%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  16 adiw  :   0 and   :   0 
andi  :  17 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  24 brge  :  12 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  13 brlt  :   0 brmi  :   0 
brne  :   1 brpl  :   0 brsh  :  15 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  56 cbi   :   7 cbr   :  34 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   1 cp    :   3 cpc   :   0 
cpi   :  62 cpse  :   0 dec   :   1 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  22 inc   :  28 
jmp   : 105 ld    :  48 ldd   :   0 ldi   : 197 lds   :   0 lpm   :   2 
lsl   :   4 lsr   :   1 mov   :   8 movw  :   0 mul   :   1 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   8 ori   :   0 out   :  49 
pop   :   2 push  :   0 rcall :   0 ret   :  54 reti  :  10 rjmp  :   0 
rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 sbi   :  13 sbic  :   6 
sbis  :   1 sbiw  :   0 sbr   :  29 sbrc  :  26 sbrs  :  14 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   :  82 sub   :   0 subi  :  12 swap  :  10 tst   :   0 wdr   :   0 

Instructions used: 40 out of 114 (35.1%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000a44   2476     24   2500  131072   1.9%
[.dseg] 0x000100 0x000130      0     48     48    4096   1.2%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
