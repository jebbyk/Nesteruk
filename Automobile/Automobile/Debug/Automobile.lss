
AVRASM ver. 2.2.7  C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm Mon Dec 21 23:30:33 2020

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
                                 
                                 .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 .def temp = r16 ; temporal registter for some actions
                                 .def temp2 = r17
                                 .def temp3 = r18
                                 .def temp4 = r19
                                 .def tempInter = r20
                                 .def tempInter2 = r22
                                 .def eventsFlags0 = r21
                                 .def tempFlag = r23
                                 .def tempFlag2 = r24
                                 
                                 .equ speaker_pin_number = 5
                                 .equ speaker_pin_position = 0b00000100 ; speaker will be connected on 5th pin of portD
                                 
                                 .equ engine_flap_pin_num = 7 ; engine cooler flap will be contolled by the electrical magnet
                                 .equ engine_flap_pin_pos = 0b10000000
                                 
                                 .equ outside_flap_pin_num = 6 ; the same for outside flap
                                 .equ outside_flap_pin_pos = 0b01000000
                                 
                                 .equ debug_pin_position = 0b00100000 ; will use this pin to show something idk
                                 .equ debug_pin_number = 5
                                 
                                 .equ heater_pin_number = 0
                                 .equ heater_pin_position = 0b000000001
                                 .equ cooler_pin_number = 1
                                 .equ cooler_pin_position = 0b000000010
                                 
                                 .equ frontAirbagsTriggerPinNumber = 4
                                 .equ frontAirbagsTriggerPinPosition = 0b00010000
                                 .equ sideAirbagsTriggerPinNumber = 3
                                 .equ sideAirbagsTriggerPinPosition =  0b00001000
                                 .equ maxAllowedSideAcceleration = 40
                                 .equ maxAllowedForwardAcceleration = 100
                                 .equ maxAllowedBackwardAcceleration = 70
                                 .equ accelerationCheckingFreq = 128 + 64 + 32 + 16 + 8 + 4 + 2
                                 
                                 .equ insideThermalSensorNum = 0
                                 .equ outsideThermalSensorNum = 1
                                 .equ engineThermalSensorNum = 2
                                 .equ steeringWheelSensorNum = 3
                                 .equ seat0ThermalSensorNum = 4 ; TODO can be done without these 4 lines of code
                                 .equ seat1ThermalSensorNum = 5
                                 .equ seat2ThermalSensorNum = 6
                                 .equ seat3ThermalSensorNum = 7 
                                 .equ seat0FlapControl = 8
                                 .equ seat1FlapControl = 9
                                 .equ seat2FlapControl = 10
                                 .equ seat3FlapControl = 11
                                 .equ accelerationFrontSensorZ = 12
                                 .equ accelerationFrontSensorX = 13
                                 .equ accelerationRearSensorX = 14
                                 .equ lolkekcheburek = 15
                                 
                                 .equ tccr0_setup_byte = 0b00000101 ; select speed for timer0
                                 .equ assr_setup_byte =  0b00001000 ; select async oscilator (slower speed and independent from main clock)
                                 .equ tccr1b_setup_byte = 0b00000101 ; seelect speed for timer1
                                 .equ tccr2_setup_byte = 0b00000101 ; select speed for timer2
                                 .equ tccr3b_setup_byte = 0b00000011 ; select speed for timer3
                                 .equ timsk_setup_byte = 0b01000101 ; enable timer2, tiemr1 and timer0 interruption on overflowz
                                 .equ etimsk_setup_byte = 0b00000100 ; enable temer3 interruption on overflow
                                 
                                 .equ ch0 = 0
                                 .equ ch1 = 1
                                 .equ ch2 = 2
                                 .equ ch3 = 3
                                 .equ ch4 = 4
                                 .equ ch5 = 5
                                 .equ ch6 = 6
                                 .equ ch7 = 7
                                 .equ ch8 = 8
                                 .equ ch9 = 9
                                 .equ chA = 10
                                 .equ chB = 11
                                 .equ chC = 12
                                 .equ chD = 13
                                 .equ chE = 14
                                 .equ chF = 15
                                 .equ chGrad = 16
                                 .equ chMinus = 17
                                 .equ chR = 18
                                 .equ chSpace = 19
                                 
                                 .equ soundSignalsDelay = 128 + 64 + 32 + 16 ; (lower number bigger delays)
                                 	.equ tone0 = 0 + 128 + 64 + 32 + 16 + 8 + 4 ; (lower number -lower tone)
                                  	.equ tone1 = 0 + 128 + 64 + 32 + 16 + 8 + 4 + 2
                                 
                                 .equ displayDataSwitchingFreq = 128 + 64 + 32 ; bigger number - faster switching
                                 
                                 .equ checkOutsideTemperatureFreq = 128 + 64 + 32 + 16 
                                 
                                 .equ condFanSpeed = 249; higher number - higher speed
                                 	
                                 
                                 	; states flags 0
                                 	.equ sf_sound_enabled =				0b10000000
                                 	.equ sf_sound_enabled_n =			7
                                 	.equ sf_warning_signal_enabled =	0b01000000
                                 	.equ sf_warning_signal_enabled_n =  6
                                 	.equ sf_click_signal_enabled  =		0b00100000
                                 	.equ sf_click_signal_enabled_n =	5
                                 	.equ sf_accept_signal_enabled =		0b00010000
                                 	.equ sf_accept_signal_enabled_n =	4
                                 	.equ sf_cancel_signal_enabled =		0b00001000
                                 	.equ sf_cancel_signal_enabled_n =	3
                                 	.equ sf_conditioner_enabled =		0b00000100
                                 	.equ sf_conditioner_enabled_n =		2
                                 	.equ sf_engine_cooler_flap_state =	0b00000010
                                 	.equ sf_engine_cooler_flap_state_n = 1
                                 	.equ sf_display_error_message =		0b00000001
                                 	.equ sf_display_error_message_n =	0
                                 
                                 	; eventsFlags0
                                 	.equ ef_update_sound_wave_state =	0b10000000
                                 	.equ ef_update_sound_wave_state_n =	7
                                 	.equ ef_update_sound_type =			0b01000000
                                 	.equ ef_update_sound_type_n =		6
                                 	.equ ef_handle_input =				0b00100000
                                 	.equ ef_handle_input_n =			5
                                 	.equ ef_update_7seg_screen =		0b00010000
                                 	.equ ef_update_7seg_screen_n =		4
                                 	.equ ef_read_analog_sensors =		0b00001000
                                 	.equ ef_read_analog_sensors_n =		3
                                 	.equ ef_save_target_temperature =	0b00000100
                                 	.equ ef_save_target_temperature_n = 2
                                 	.equ ef_update_heater =				0b00000010
                                 	.equ ef_update_heater_n =			1
                                 	.equ ef_update_conditioner_fan =	0b00000001
                                 	.equ ef_update_conditioner_fan_n =	0
                                 
                                 
                                 	; events flags1
                                 	.equ ef_load_target_temp =			0b10000000
                                 	.equ ef_load_target_temp_n =		7
                                 	.equ ef_update_program_timers =		0b01000000
                                 	.equ ef_update_program_timers_n =	6
                                 	.equ ef_update_flaps =				0b00100000
                                 	.equ ef_update_flaps_n =			5
                                 	.equ ef_increment_tachometer =		0b00010000
                                 	.equ ef_increment_tachometer_n =	4
                                 	.equ ef_update_tachometer =			0b00001000
                                 	.equ ef_update_tachometer_n =		3
                                 	.equ ef_check_engine_temperature =	0b00000100
                                 	.equ ef_check_engine_temperature_n = 2
                                 	.equ ef_switch_display_data =		0b00000010
                                 	.equ ef_switch_display_data_n =		1
                                 	.equ ef_handle_current_key =		0b00000001
                                 	.equ ef_handle_current_key_n =		0
                                 
                                 	; events falgs 2
                                 	.equ ef_check_outside_temperature =		0b10000000
                                 	.equ ef_check_outside_temperature_n =   7
                                 	.equ ef_check_acceleration =			0b01000000
                                 	.equ ef_check_acceleration_n =			6
                                 
                                 
                                 //addreses in eeprom where usefull data will be saved
                                 .equ targetTempSavingAddr = 0
                                 
                                 
                                 .dseg
                                 	analogValuesTable:
000100                           		.byte 16 ; there will be stored all the data from all 8 thermal sensors
                                 	SevenSegScrBuff:
000110                           		.byte 8 ; reserve 8 bytes for 7 segment dysplay buffer
                                 	currentSensorNum:
000118                           		.byte 1 ; there will be stored number of thermalSensor we wanna save data from
                                 	curPos7Seg:
000119                           		.byte 1 ; position of currently printing glyph on 7seg display
                                 	
                                 	currentDisplayData:
00011a                           		.byte 1 ; 0 - temperatures, 1 - tachometer
                                 	switchDisplayDataTimerH:
00011b                           		.byte 1 ;
                                 	switchDisplayDataTimerL:
00011c                           		.byte 1 ;
                                 
                                 	targetTemperature:
00011d                           		.byte 1 ; reserve  1 byte to keep temperature while running\
                                 	updateConditionerTimer:
00011e                           		.byte 1
                                 	flapsUpdateTimer:
00011f                           		.byte 1
                                 	currentControlledFlap:
000120                           		.byte 1
                                 	conditionerFanTimer0:
000121                           		.byte 1 ; reserve 2 bytes to store current conditioner fan timer
                                 	conditionerFanTimer1:
000122                           		.byte 1
                                 	conditionerFanState:
000123                           		.byte 1 ; reserve 1 byte to know fan "rotation" (not quite but who cares)
                                 	checkOutsideTemperatureTimerH:
000124                           		.byte 1
                                 	checkOutsideTemperatureTimerL:
000125                           		.byte 1
                                 
                                 	tachometerTimerH:
000126                           		.byte 1
                                 	tachometerTimerL:
000127                           		.byte 1
                                 	tachometerCounter:
000128                           		.byte 1
                                 	engineSpeed:
000129                           		.byte 1
                                 	checkEngineTemperatureTimer:
00012a                           		.byte 1
                                 
                                 	currentTone:
00012b                           		.byte 1 ; there will be stored current note of sound
                                 
                                 	currentKey:
00012c                           		.byte 1 ; there will be storred a number of the last pressed key
                                 	handleCurrentKeyTimer:
00012d                           		.byte 1
                                 
                                 	checkAccelerationTimer:
00012e                           		.byte 1 
                                 
                                 	eventsFlags1:
00012f                           		.byte 1
                                 	eventsFlags2:
000130                           		.byte 1
                                 	statesFlags0:
000131                           		.byte 1
                                 
                                 .cseg
                                 	.org 0
000000 940c 005c                 		jmp reset
                                 
                                 	
                                 		.org $0002
000002 940c 05a9                 			jmp extInt0Handler
                                 		.org $0004
000004 940c 05ad                 			jmp extInt1Handler
                                 		.org $0014
000014 940c 05be                 			jmp timer2OvfHandler
                                 		.org $001C
00001c 940c 05ba                 			jmp timer1OvfHandler
                                 		.org $0020
000020 940c 05b6                 			jmp timer0OvfHandler
                                 		.org $002a
00002a 940c 05cb                 			jmp adcConvertionHandler
                                 		.org $003a 
00003a 940c 05c2                 			jmp timer3OvfHandler
                                 
                                 
                                 	.org $0050 ; start program almost right after all intrruptions vectors
                                 
                                 	charTable7seg: 
                                 		//main simbols for 7seg display
000050 9f03
000051 0d25                      		.db 0b00000011 /*0*/, 0b10011111 /*1*/, 0b00100101 /*2*/, 0b00001101 /*3*/
000052 4999
000053 1f41                      		.db	0b10011001 /*4*/, 0b01001001 /*5*/, 0b01000001 /*6*/, 0b00011111 /*7*/
000054 0901
000055 c111                      		.db	0b00000001 /*8*/, 0b00001001 /*9*/, 0b00010001 /*a*/, 0b11000001 /*b*/
000056 8561
000057 7161                      		.db	0b01100001 /*c*/, 0b10000101 /*d*/, 0b01100001 /*e*/, 0b01110001 /*f*/
                                 
                                 		//extra simbols for 7seg display
000058 fd39
000059 ff73                      		.db	0b00111001 /*grad*/, 0b11111101 /*minus*/, 0b01110011 /*r*/, 0xff /*space*/
                                 
                                 	errorString7: 
00005a 120e
00005b 1312                      		.db chE, chR, chR, chSpace
                                 	
                                 
                                 	reset:
                                 
00005c e100                      		ldi temp, high(ramend) ; setting up stack pointer
00005d bf0e                      		out sph, temp
00005e ef0f                      		ldi temp, low(ramend)
00005f bf0d                      		out spl, temp
                                 
                                 		; setting up ports
000060 e908                      		ldi temp, 0b10011000 ; 0,1,2-in (read column), 3,4 - out (select row), 7 - out (check all buttons)
000061 bb0a                      		out ddra, temp
000062 e800                      		ldi temp, 0b10000000 ; enable continuous check if any button is pressed
000063 bb0b                      		out porta, temp
                                 
000064 ee00                      		ldi temp, 0b11100000 ; set last hree bits of portB to be output
000065 bb07                      		out ddrb, temp
                                 
000066 ef0f                      		ldi temp, 0b11111111 ; set all pins of portC to be output
000067 bb04                      		out ddrc, temp
                                 
000068 e004                      		ldi temp, speaker_pin_position
000069 e810                      		ldi temp2, engine_flap_pin_pos
00006a 2b01                      		or temp, temp2
00006b e410                      		ldi temp2, outside_flap_pin_pos
00006c 2b01                      		or temp, temp2
00006d bb01                      		out ddrd, temp
                                 
00006e ef0f                      		ldi temp, 0xff ;heater, cooler, 2,3 - flap state, 4-7 step engines (fans)
00006f b902                      		out ddre, temp
                                 
000070 ef0e                      		ldi temp, 0b11111110 ; 0 - thermSensors in, 1-4 selected thermalSensor, 6-7 selected flap
000071 9300 0061                 		sts ddrf, temp
                                 
                                 
                                 		//setting up external interrupts
000073 e003                      		ldi temp, 0b00000011 ; enable external intrruption int0, int1
000074 bf09                      		out eimsk, temp
                                 
000075 e00f                      		ldi temp, 0b00001111 ; set ext interrupt0 and interrupt1 on rising edge
000076 9300 006a                 		sts eicra, temp
                                 
                                 		//setting up timers
000078 e005                      		ldi temp, tccr0_setup_byte
000079 bf03                      		out tccr0, temp ; set timer0 speed
00007a e008                      		ldi temp, assr_setup_byte
00007b bf00                      		out assr, temp ; select async oscilator ( timer0 will be super slow and independent from main clock)
                                 
00007c e005                      		ldi temp, tccr1b_setup_byte ; setting up timer1 speed
00007d bd0e                      		out tccr1b, temp;
00007e ef0f                      		ldi temp, 0xff ; reset timer
00007f e010                      		ldi temp2, 0x00
000080 bd0d                      		out tcnt1h, temp
000081 bd1c                      		out tcnt1l, temp2
                                 
000082 e005                      		ldi temp, tccr2_setup_byte
000083 bd05                      		out tccr2, temp ; set timer2 speed
                                 
000084 e003                      		ldi temp, tccr3b_setup_byte ; setting up timer3 speed
000085 9300 008a                 		sts tccr3b, temp
                                 
000087 e405                      		ldi temp, timsk_setup_byte
000088 bf07                      		out timsk, temp ; enable interupts on timers overflowing
                                 
000089 e004                      		ldi temp, etimsk_setup_byte
00008a 9300 007d                 		sts etimsk, temp
                                 
                                 
00008c e600                      		ldi temp, 0b01100000 ; use external cap in adc, left adjust the result
00008d b907                      		out admux, temp
                                 
00008e ed0f                      		ldi temp, 0b11011111 ; en adc, start conv, , clear int flag, enable interuptions, setup prescaler
00008f b906                      		out adcsra, temp
                                 
                                 		
000090 e0f1                      		ldi zh, high(eventsFlags1)
000091 e2ef                      		ldi zl, low(eventsFlags1)
000092 8180                      		ld tempFlag2, z
000093 6880                      		sbr tempFlag2, ef_load_target_temp ; try to load target temp on start
000094 9380 012f                 		sts eventsFlags1, tempFlag2
                                 
000096 9478                      		sei ;  allow interrupts
                                 
                                 
                                 	backgroundProcess:
000097 fd56                      		sbrc eventsFlags0, ef_update_sound_type_n
000098 940e 038a                 			call updateSoundType
00009a fd57                      		sbrc eventsFlags0, ef_update_sound_wave_state_n
00009b 940e 03f6                 			call updateWaveState
00009d fd55                      		sbrc eventsFlags0, ef_handle_input_n
00009e 940e 0409                 			call readInput
0000a0 fd54                      		sbrc eventsFlags0, ef_update_7seg_screen_n
0000a1 940e 045d                 			call update7segScreen
0000a3 fd53                      		sbrc eventsFlags0, ef_read_analog_sensors_n
0000a4 940e 055d                 			call readAnalogSensors
0000a6 fd52                      		sbrc eventsFlags0, ef_save_target_temperature_n
0000a7 940e 029d                 			call saveTargetTemperature
0000a9 fd51                      		sbrc eventsFlags0, ef_update_heater_n
0000aa 940e 02e1                 			call updateConditioner
0000ac fd50                      		sbrc eventsFlags0, ef_update_conditioner_fan_n
0000ad 940e 0346                 			call updateConditionerFan
                                 
0000af e0b1                      		ldi xh, high(eventsFlags1)
0000b0 e2af                      		ldi xl, low(eventsFlags1)
0000b1 917c                      		ld tempFlag, x
0000b2 fd77                      		sbrc tempFlag, ef_load_target_temp_n
0000b3 940e 02ab                 			call loadTargetTemperature
0000b5 fd76                      		sbrc tempFlag, ef_update_program_timers_n
0000b6 940e 0176                 			call updateProgramTimers 
0000b8 fd75                      		sbrc tempFlag, ef_update_flaps_n
0000b9 940e 035e                 			call updateFlaps
0000bb fd73                      		sbrc tempFlag, ef_update_tachometer_n
0000bc 940e 057a                 			call updateTachometer
0000be fd74                      		sbrc tempFlag, ef_increment_tachometer_n
0000bf 940e 0591                 			call incrementTachometerCounter
0000c1 fd72                      		sbrc tempFlag, ef_check_engine_temperature_n
0000c2 940e 02bc                 			call checkEngineTemperature
0000c4 fd71                      		sbrc tempFlag, ef_switch_display_data_n
0000c5 940e 0431                 			call switchDisplayData
0000c7 fd70                      		sbrc tempFlag, ef_handle_current_key_n
0000c8 940e 0111                 			call handleCurrentKey
                                 
0000ca e0b1                      		ldi xh, high(eventsFlags2)
0000cb e3a0                      		ldi xl, low(eventsFlags2) 
0000cc 917c                      		ld tempFlag, x
0000cd fd77                      		sbrc tempFlag, ef_check_outside_temperature_n
0000ce 940e 02d0                 			call checkOutsideTemperature
0000d0 fd76                      		sbrc tempFlag, ef_check_acceleration_n
0000d1 940e 00d5                 			call checkAcceleration
                                 
0000d3 940c 0097                  	jmp backgroundProcess
                                 
                                 	checkAcceleration:
0000d5 7b7f                      		cbr tempFlag, ef_check_acceleration
0000d6 9370 0130                 		sts eventsFlags2, tempFlag
                                 
0000d8 e0b1                      		ldi xh, high(analogValuesTable)
0000d9 e0a0                      		ldi xl, low(analogValuesTable)
0000da e00c                      		ldi temp, accelerationFrontSensorZ
0000db 0fa0                      		add xl, temp
0000dc 911c                      		ld temp2, x
                                 
0000dd 331a                      		cpi temp2, 128 - maxAllowedBackwardAcceleration
0000de f0b0                      			brlo frontCollision
                                 		
                                 		checkRearCollision:
0000df 3e14                      			cpi temp2, 128 + maxAllowedForwardAcceleration
0000e0 f4c0                      				brsh rearCollision
                                 
                                 		
                                 
                                 		checkFrontLeftCollision:
0000e1 e0b1                      		ldi xh, high(analogValuesTable)
0000e2 e0a0                      		ldi xl, low(analogValuesTable)
0000e3 e00d                      		ldi temp, accelerationFrontSensorX
0000e4 0fa0                      		add xl, temp
0000e5 912c                      		ld temp3, x
                                 
                                 		
0000e6 3a28                      		cpi temp3, 128 + maxAllowedSideAcceleration
0000e7 f4b0                      			brsh frontLeftCollision
                                 		
                                 		checkFrontRightCollision:
0000e8 3528                      			cpi temp3, 128 - maxAllowedSideAcceleration
0000e9 f0c8                      				brlo frontRightCollision
                                 
                                 		checkBackLeftCollision:
0000ea e0b1                      		ldi xh, high(analogValuesTable)
0000eb e0a0                      		ldi xl, low(analogValuesTable)
0000ec e00e                      		ldi temp, accelerationRearSensorX
0000ed 0fa0                      		add xl, temp
0000ee 913c                      		ld temp4, x
                                 
0000ef 3a38                      		cpi temp4, 128 + maxAllowedSideAcceleration
0000f0 f4b8                      			brsh backLeftCollision
                                 
                                 		checkBackRightCollision:
0000f1 3538                      			cpi temp4, 128 - maxAllowedSideAcceleration
0000f2 f0d0                      				brlo backRightCollision
0000f3 940c 0110                 				jmp endCheckCollision
                                 
                                 		frontCollision:
0000f5 940e 0149                 			call enableWarningSignal
0000f7 940c 00df                 			jmp checkRearCollision
                                 
                                 		rearCollision:
0000f9 9a94                      			sbi portd, frontAirbagsTriggerPinNumber
0000fa 940e 0149                 			call enableWarningSignal
0000fc 940c 00e1                 			jmp checkFrontLeftCollision
                                 
                                 		frontLeftCollision:
0000fe 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
0000ff 940e 0149                 			call enableWarningSignal
000101 940c 00e8                 			jmp checkFrontRightCollision
                                 
                                 		frontRightCollision:
000103 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
000104 940e 0149                 			call enableWarningSignal
000106 940c 00ea                 			jmp checkBackLeftCollision
                                 
                                 		backLeftCollision:
000108 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
000109 940e 0149                 			call enableWarningSignal
00010b 940c 00f1                 			jmp checkBackRightCollision
                                 
                                 		backRightCollision:
00010d 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
00010e 940e 0149                 			call enableWarningSignal
                                 
                                 		endCheckCollision:
000110 9508                      	ret
                                 
                                 	handleCurrentKey:
000111 e0f1                      		ldi zh, high(eventsFlags1)
000112 e2ef                      		ldi zl, low(eventsFlags1)
000113 8180                      		ld tempFlag2, z
000114 7f8e                      		cbr tempFlag2, ef_handle_current_key
000115 9380 012f                 		sts eventsFlags1, tempFlag2
                                 
000117 e0b1                      		ldi xh, high(currentKey)
000118 e2ac                      		ldi xl, low(currentKey)
000119 910c                      		ld temp, x
00011a 310c                      		cpi temp, 28
00011b f041                      			breq callRizeTemperature
00011c 3104                      		cpi temp, 20
00011d f051                      			breq callLowerTemperature
00011e 300c                      		cpi temp, 12
00011f f061                      			breq callHandleCancelKey
000120 3109                      		cpi temp, 25
000121 f071                      			breq callSwitchConditioner
000122 940c 0132                 			jmp handleCurrentKeyEnd
                                 
                                 		callRizeTemperature:
000124 940e 0257                 			call rizeTemperature
000126 940c 0132                 			jmp handleCurrentKeyEnd
                                 
                                 		callLowerTemperature:
000128 940e 026c                 			call lowerTemperature
00012a 940c 0132                 			jmp handleCurrentKeyEnd
                                 
                                 		callHandleCancelKey:
00012c 940e 0133                 			call handleCancelKey
00012e 940c 0132                 			jmp handleCurrentKeyEnd
                                 
                                 		callSwitchConditioner:
000130 940e 0281                 			call switchConditioner
                                 
                                 		handleCurrentKeyEnd:
000132 9508                      	ret
                                 
                                 
                                 	handleCancelKey:
000133 e0f1                      		ldi zh, high(statesFlags0)
000134 e3e1                      		ldi zl, low(statesFlags0)
000135 8180                      		ld tempFlag2, z
000136 fd86                      		sbrc tempFlag2, sf_warning_signal_enabled_n
000137 940c 013b                 			jmp cancelWarning
000139 940c 0142                 			jmp endHandleCancelKey
                                 
                                 		cancelWarning:
00013b e000                      			ldi temp, 0
00013c 9300 012c                 			sts currentKey, temp ; current key is handled. so clear it
00013e 940e 0154                 			call disableWarningSignal
000140 940e 016d                 			call enableCancelSignal
                                 
                                 		endHandleCancelKey:
                                 
000142 9508                      	ret
                                 
                                 	resetSoundState:
000143 7d8f                      		cbr tempFlag2, sf_click_signal_enabled
000144 7e8f                      		cbr tempFlag2, sf_accept_signal_enabled
000145 7f87                      		cbr tempFlag2, sf_cancel_signal_enabled
000146 7b8f                      		cbr tempFlag2, sf_warning_signal_enabled
000147 778f                      		cbr tempFlag2, sf_sound_enabled
000148 9508                      	ret
                                 
                                 	enableWarningSignal:
000149 e0f1                      		ldi zh, high(statesFlags0)
00014a e3e1                      		ldi zl, low(statesFlags0)
00014b 8180                      		ld tempFlag2, z
00014c fd86                      		sbrc tempFlag2, sf_warning_signal_enabled_n
00014d 9508                      			ret ; return emmediately if it is already enabled
00014e 940e 0143                 		call resetSoundState
000150 6480                      		sbr tempFlag2, sf_warning_signal_enabled
000151 9380 0131                 		sts statesFlags0, tempFlag2
000153 9508                      	ret
                                 
                                 	disableWarningSignal:
000154 e0f1                      		ldi zh, high(statesFlags0)
000155 e3e1                      		ldi zl, low(statesFlags0)
000156 8180                      		ld tempFlag2, z
000157 7b8f                      		cbr tempFlag2, sf_warning_signal_enabled
000158 9380 0131                 		sts statesFlags0, tempFlag2
00015a 9508                      	ret
                                 
                                 	enableClickSignal:
00015b e0f1                      		ldi zh, high(statesFlags0)
00015c e3e1                      		ldi zl, low(statesFlags0)
00015d 8180                      		ld tempFlag2, z
00015e 940e 0143                 		call resetSoundState
000160 6280                      		sbr tempFlag2, sf_click_signal_enabled
000161 9380 0131                 		sts statesFlags0, tempFlag2
000163 9508                      	ret
                                 
                                 	enableAcceptSignal:
000164 e0f1                      		ldi zh, high(statesFlags0)
000165 e3e1                      		ldi zl, low(statesFlags0)
000166 8180                      		ld tempFlag2, z
000167 940e 0143                 		call resetSoundState
000169 6180                      		sbr tempFlag2, sf_accept_signal_enabled
00016a 9380 0131                 		sts statesFlags0, tempFlag2
00016c 9508                      	ret
                                 
                                 	enableCancelSignal:
00016d e0f1                      		ldi zh, high(statesFlags0)
00016e e3e1                      		ldi zl, low(statesFlags0)
00016f 8180                      		ld tempFlag2, z
000170 940e 0143                 		call resetSoundState
000172 6088                      		sbr tempFlag2, sf_cancel_signal_enabled
000173 9380 0131                 		sts statesFlags0, tempFlag2
000175 9508                      	ret
                                 
                                 	updateProgramTimers:
000176 ef0f                      		ldi temp, 0xff ; preset timer to change overflowing freq
000177 ef10                      		ldi temp2, 0xf0
000178 9300 0089                 		sts tcnt3h, temp
00017a 9310 0088                 		sts tcnt3l, temp2
                                 
00017c e0f1                      		ldi zh, high(eventsFlags1)
00017d e2ef                      		ldi zl, low(eventsFlags1)
00017e 8180                      		ld tempFlag2, z
00017f 7b8f                      		cbr tempFlag2, ef_update_program_timers
000180 9380 012f                 		sts eventsFlags1, tempFlag2
                                 
000182 e0f1                      		ldi zh, high(statesFlags0)
000183 e3e1                      		ldi zl, low(statesFlags0)
000184 8180                      		ld tempFlag2, z
000185 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000186 940c 01c3                 			jmp updTachTimer
                                 		
000188 e0b1                      		ldi xh, high(updateConditionerTimer) ; get timer from ram
000189 e1ae                      		ldi xl, low(updateConditionerTimer)
00018a 910c                      		ld temp, x
00018b 9503                      		inc temp
00018c 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
00018d f011                      			breq setConditionerFlag
00018e 940c 0192                 			jmp saveConditionerTimer
                                 
                                 		setConditionerFlag:
000190 6052                      			sbr eventsFlags0, ef_update_heater ; create "update_heater" task
                                 
000191 e000                      			ldi temp, 0 ; reset heater update timer
                                 
                                 		saveConditionerTimer:
000192 9300 011e                 			sts updateConditionerTimer, temp ;and save it to ram
                                 
                                 		; CONDITIONER FAN ;
000194 e0b1                      		ldi xh, high(conditionerFanTimer0) ; get temperature from ram
000195 e2a1                      		ldi xl, low(conditionerFanTimer0)
000196 910c                      		ld temp, x
000197 3f0f                      		cpi temp, 255 
000198 f029                      			breq checkCondFanTimer1	
000199 9503                      			inc temp
00019a 9300 0121                 			sts conditionerFanTimer0, temp
00019c 940c 01b2                 			jmp endUpdateCondFanTimer
                                 
                                 		checkCondFanTimer1:
00019e ec00                      			ldi temp, 128 + 64
00019f 9300 0121                 			sts conditionerFantimer0, temp
0001a1 e0b1                      			ldi xh, high(conditionerFanTimer1)
0001a2 e2a2                      			ldi xl, low(conditionerFanTimer1)
0001a3 910c                      			ld temp, x
                                 
0001a4 3f0f                      			cpi temp, 255
0001a5 f029                      				breq setUpdateCondFanFlag
0001a6 9503                      				inc temp
0001a7 9300 0122                 				sts conditionerFanTimer1, temp
0001a9 940c 01b2                 				jmp endUpdateCondFanTimer
                                 				
                                 				
                                 
                                 		setUpdateCondFanFlag:
0001ab 6051                      			sbr eventsFlags0, ef_update_conditioner_fan ; start upate fan task
                                 
0001ac ec00                      			ldi temp, 128 + 64
0001ad 9300 0121                 			sts conditionerFanTimer0, temp ; reset timer
0001af ef09                      			ldi temp, condFanSpeed
0001b0 9300 0122                 			sts conditionerFanTimer1, temp
                                 		
                                 		endUpdateCondFanTimer:
                                 
                                 
                                 
                                 		////////////udpate flaps timer ///////////
0001b2 e0b1                      		ldi xh, high(flapsUpdateTimer) ; get flaps timer from ram
0001b3 e1af                      		ldi xl, low(flapsUpdateTimer)
0001b4 910c                      		ld temp, x
0001b5 9503                      		inc temp
0001b6 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001b7 f011                      			breq setUpdateFlapsFlag
0001b8 940c 01c1                 			jmp saveUpdateFlapsTimer
                                 
                                 		setUpdateFlapsFlag:
0001ba e0f1                      			ldi zh, high(eventsFlags1)
0001bb e2ef                      			ldi zl, low(eventsFlags1)
0001bc 8180                      			ld tempFlag2, z
0001bd 6280                      			sbr tempFlag2, ef_update_flaps ; create "update_flaps" task
0001be 9380 012f                 			sts eventsFlags1, tempFlag2
                                 
0001c0 e000                      			ldi temp, 0 ; reset flaps update timer
                                 
                                 		saveUpdateFlapsTimer:
0001c1 9300 011f                 			sts flapsUpdateTimer, temp ;and save it to ram
                                 
                                 		
                                 		updTachTimer:
0001c3 e0b1                      		ldi xh, high(tachometerTimerL)
0001c4 e2a7                      		ldi xl, low(tachometerTimerL)
0001c5 910c                      		ld temp, x
0001c6 9503                      		inc temp
0001c7 3f0f                      		cpi temp, 255 
0001c8 f011                      			breq incrementTachTimerH
0001c9 940c 01d6                 			jmp saveTachTimerL
                                 
                                 		incrementTachTimerH:
0001cb e000                      			ldi temp, 0
0001cc 9300 0127                 			sts tachometerTimerL, temp
                                 
0001ce e0b1                      			ldi xh, high(tachometerTimerH)
0001cf e2a6                      			ldi xl, low(tachometerTimerH)
0001d0 910c                      			ld temp, x
0001d1 9503                      			inc temp
0001d2 3f0f                      			cpi temp, 255
0001d3 f051                      				breq resetTachTimer
0001d4 940c 01da                 				jmp saveTachTimerH
                                 
                                 		saveTachTimerL:
0001d6 9300 0127                 			sts tachometerTimerL, temp
0001d8 940c 01ea                 			jmp endTachTimerUpdate
                                 
                                 		saveTachTimerH:
0001da 9300 0126                 			sts tachometerTimerH, temp
0001dc 940c 01ea                 			jmp endTachTimerUpdate
                                 
                                 		resetTachTimer:
0001de ef0c                      			ldi temp, 128 + 64 + 32 + 16 + 8 + 4
0001df 9300 0126                 			sts tachometerTimerH, temp
0001e1 e000                      			ldi temp, 0
0001e2 9300 0127                 			sts tachometerTimerL, temp
                                 			
0001e4 e0f1                      			ldi zh, high(eventsFlags1)
0001e5 e2ef                      			ldi zl, low(eventsFlags1)
0001e6 8180                      			ld tempFlag2, z
0001e7 6088                      			sbr tempFlag2, ef_update_tachometer
0001e8 9380 012f                 			sts eventsFlags1, tempFlag2
                                 		
                                 		endTachTimerUpdate:
                                 
                                 
                                 		//////////// switch displayed data timer ///////////////////
0001ea e0b1                      		ldi xh, high(switchDisplayDataTimerL) ; get timer from ram
0001eb e1ac                      		ldi xl, low(switchDisplayDataTimerL)
0001ec 910c                      		ld temp, x
0001ed 9503                      		inc temp
0001ee 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001ef f021                      			breq incSwitchDisplayDataTimerH
0001f0 9300 011c                 			sts switchDisplayDataTimerL, temp
0001f2 940c 0208                 			jmp endDisplayDataTimerUpdate
                                 
                                 		incSwitchDisplayDataTimerH:
0001f4 e000                      			ldi temp, 0
0001f5 9300 011c                 			sts switchDisplayDataTimerL, temp
                                 
0001f7 e0b1                      			ldi xh, high(switchDisplayDataTimerH)
0001f8 e1ab                      			ldi xl, low(switchDisplayDataTimerH)
0001f9 910c                      			ld temp, x
0001fa 9503                      			inc temp
0001fb 3f0f                      			cpi temp, 255
0001fc f011                      				breq setSwitchDisplayDataFlag
0001fd 940c 0206                 				jmp saveSwitchDisplayDataTimerH
                                 
                                 			setSwitchDisplayDataFlag:
0001ff e0f1                      				ldi zh, high(eventsFlags1)
000200 e2ef                      				ldi zl, low(eventsFlags1)
000201 8180                      				ld tempFlag2, z
000202 6082                      				sbr tempFlag2, ef_switch_display_data
000203 9380 012f                 				sts eventsFlags1, tempFlag2
                                 
                                 				resetDisplayDataTimerH:
000205 ee00                      				ldi temp, displayDataSwitchingFreq ; reset  timer
                                 
                                 			saveSwitchDisplayDataTimerH:
000206 9300 011b                 				sts switchDisplayDataTimerH, temp ;and save it to ram
                                 		
                                 		endDisplayDataTimerUpdate:
                                 
                                 
                                 		
                                 		////////////udpate check engine temperature timer ///////////
000208 e0b1                      		ldi xh, high(checkEngineTemperatureTimer) ; get flaps timer from ram
000209 e2aa                      		ldi xl, low(checkEngineTemperatureTimer)
00020a 910c                      		ld temp, x
00020b 9503                      		inc temp
00020c 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
00020d f011                      			breq setCheckEngineTemperatureFlag
00020e 940c 0217                 			jmp saveCheckEngineTemperatureTimer
                                 
                                 		setCheckEngineTemperatureFlag:
000210 e0f1                      			ldi zh, high(eventsFlags1)
000211 e2ef                      			ldi zl, low(eventsFlags1)
000212 8180                      			ld tempFlag2, z
000213 6084                      			sbr tempFlag2, ef_check_engine_temperature ; create "update_flaps" task
000214 9380 012f                 			sts eventsFlags1, tempFlag2
                                 
000216 e000                      			ldi temp, 0 ; reset flaps update timer
                                 
                                 		saveCheckEngineTemperatureTimer:
000217 9300 012a                 			sts checkEngineTemperatureTimer, temp ;and save it to ram
                                 
                                 		endCheckEngineTemperatureTimerUpdate:
                                 
                                 		//////// handle the last pressed key timer //////////
000219 e0b1                      		ldi xh, high(handleCurrentKeyTimer)
00021a e2ad                      		ldi xl, low(handleCurrentKeyTimer)
00021b 910c                      		ld temp, x
00021c 9503                      		inc temp
00021d 3f0e                      		cpi temp, 254
00021e f410                      			brsh setHandleCurrentKeyFlag
00021f 940c 0228                 			jmp saveHandleCurrentKeyTimer
                                 
                                 		setHandleCurrentKeyFlag:
000221 e0f1                      			ldi zh, high(eventsFlags1)
000222 e2ef                      			ldi zl, low(eventsFlags1)
000223 8180                      			ld tempFlag2, z
000224 6081                      			sbr tempFlag2, ef_handle_current_key
000225 9380 012f                 			sts eventsFlags1, tempFlag2
                                 
000227 e000                      			ldi temp, 0
                                 
                                 		saveHandleCurrentKeyTimer:
000228 9300 012d                 			sts handleCurrentKeyTimer, temp
                                 
                                 		endHandleCrrentKeyTimerUpdate:
                                 
                                 
                                 		////////// outside temp checking timer//////////
00022a e0b1                      		ldi xh, high(eventsFlags2)
00022b e3a0                      		ldi xl, low(eventsFlags2)
00022c 917c                      		ld tempFlag, x
00022d e0b1                      		ldi xh, high(checkOutsideTemperatureTimerL) ; get timer from ram
00022e e2a5                      		ldi xl, low(checkOutsideTemperatureTimerL)
00022f 910c                      		ld temp, x
000230 9503                      		inc temp
000231 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
000232 f021                      			breq incCheckOutsideTemperatureTimerH
000233 9300 0125                 			sts checkOutsideTemperatureTimerL, temp
000235 940c 0248                 			jmp endCheckOutsideTemperatreTimerUpdate
                                 
                                 		incCheckOutsideTemperatureTimerH:
000237 e000                      			ldi temp, 0
000238 9300 0125                 			sts checkOutsideTemperatureTimerL, temp
                                 
00023a e0b1                      			ldi xh, high(CheckOutsideTemperatureTimerH)
00023b e2a4                      			ldi xl, low(CheckOutsideTemperatureTimerH)
00023c 910c                      			ld temp, x
00023d 9503                      			inc temp
00023e 3f0f                      			cpi temp, 255
00023f f011                      				breq setCheckOutsideTemperatreFlag
000240 940c 0246                 				jmp saveCheckOutsideTemperatreTimerH
                                 
                                 			setCheckOutsideTemperatreFlag:
000242 6870                      				sbr tempFlag, ef_check_outside_temperature
000243 9370 0130                 				sts eventsFlags2, tempFlag
                                 
                                 				resetCheckOutsideTemperatreTimerH:
000245 ef00                      				ldi temp, checkOutsideTemperatureFreq ; reset  timer
                                 
                                 			saveCheckOutsideTemperatreTimerH:
000246 9300 0124                 				sts CheckOutsideTemperatureTimerH, temp ;and save it to ram
                                 		
                                 		endCheckOutsideTemperatreTimerUpdate:
                                 
                                 
                                 		//////// check accelerations timer //////////
000248 e0b1                      		ldi xh, high(checkAccelerationTimer)
000249 e2ae                      		ldi xl, low(checkAccelerationTimer)
00024a 910c                      		ld temp, x
00024b 9503                      		inc temp
00024c 3f0e                      		cpi temp, 254
00024d f410                      			brsh setCheckAccelerationFlag
00024e 940c 0254                 			jmp saveCheckAccelerationTimer
                                 
                                 		setCheckAccelerationFlag:
000250 6470                      			sbr tempFlag, ef_check_acceleration
000251 9370 0130                 			sts eventsFlags2, tempFlag
000253 e000                      			ldi temp, 0
                                 
                                 		saveCheckAccelerationTimer:
000254 9300 012e                 			sts checkAccelerationTimer, temp
                                 
                                 		endCheckAccelerationUpdate:
                                 
                                 
000256 9508                      	ret
                                 
                                 
                                 	rizeTemperature:
000257 e0f1                      		ldi zh, high(statesFlags0)
000258 e3e1                      		ldi zl, low(statesFlags0)
000259 8180                      		ld tempFlag2, z
00025a ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
00025b 9508                      			ret
                                 		
00025c 940e 015b                 		call enableClickSignal ; make click sound
00025e e000                      		ldi temp, 0
00025f 9300 012c                 		sts currentKey, temp
000261 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000262 e1ad                      		ldi xl, low(targetTemperature)
000263 910c                      		ld temp, x
000264 9503                      		inc temp ; increment temperature
                                 		
000265 310f                      		cpi temp, 31 ; limit temperature to 30 grad
000266 f008                      			brlo saveTemperatureToRam
000267 e10e                      			ldi temp, 30
                                 
                                 		saveTemperatureToRam:
000268 9300 011d                 			sts targetTemperature, temp ;and save it to ram
                                 
00026a 6054                      		sbr eventsFlags0, ef_save_target_temperature
00026b 9508                      	ret
                                 
                                 	lowerTemperature:
00026c e0f1                      		ldi zh, high(statesFlags0)
00026d e3e1                      		ldi zl, low(statesFlags0)
00026e 8180                      		ld tempFlag2, z
00026f ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000270 9508                      			ret
                                 		
000271 940e 015b                 		call enableClickSignal ; make click sound
                                 
000273 e000                      		ldi temp, 0
000274 9300 012c                 		sts currentKey, temp
000276 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000277 e1ad                      		ldi xl, low(targetTemperature)
000278 910c                      		ld temp, x
000279 950a                      		dec temp ; decrement temperature
                                 
00027a 300a                      		cpi temp, 10 ; limit temperature to 30 grad
00027b f764                      			brge saveTemperatureToRam
00027c e00a                      			ldi temp, 10
                                 
00027d 9300 011d                 		sts targetTemperature, temp ;and save it to ram
                                 
00027f 6054                      		sbr eventsFlags0, ef_save_target_temperature
000280 9508                      	ret
                                 
                                 	switchConditioner:
000281 e000                      		ldi temp, 0
000282 9300 012c                 		sts currentKey, temp
000284 e0f1                      		ldi zh, high(statesFlags0)
000285 e3e1                      		ldi zl, low(statesFlags0)
000286 8180                      		ld tempFlag2, z
000287 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n
000288 940c 028c                 			jmp cond_en
00028a 940c 0293                 			jmp cond_dis
                                 
                                 		cond_en:
00028c 6084                      			sbr tempFlag2, sf_conditioner_enabled
00028d 9380 0131                 			sts statesFlags0, tempFlag2
00028f 940e 0164                 			call enableAcceptSignal
000291 940c 029c                 			jmp endSwitchConditioner
                                 		cond_dis:
000293 7f8b                      			cbr tempFlag2, sf_conditioner_enabled
000294 9380 0131                 			sts statesFlags0, tempFlag2
000296 940e 016d                 			call enableCancelSignal
000298 9818                      			cbi porte, heater_pin_number
000299 9819                      			cbi porte, cooler_pin_number
00029a 940c 029c                 			jmp endSwitchConditioner
                                 		endSwitchConditioner:
00029c 9508                      	ret
                                 
                                 
                                 
                                 	saveTargetTemperature:
00029d 99e1                      		sbic eecr, eewe ; wait for completion of previous write
00029e 940c 02aa                 			jmp endWritingAttempt
0002a0 e000                      		ldi temp, targetTempSavingAddr ; setup address where to wirte
0002a1 bb0f                      		out eearh, temp
0002a2 bb0e                      		out eearl, temp
                                 		
0002a3 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
0002a4 e1ad                      		ldi xl, low(targetTemperature)
0002a5 910c                      		ld temp, x
                                 
0002a6 bb0d                      		out eedr, temp ; store data to data register
0002a7 9ae2                      		sbi eecr, eemwe ; write logical one to eemwe
0002a8 9ae1                      		sbi eecr, eewe ; start eeprom write by setting eewe
                                 
0002a9 7f5b                      		cbr eventsFlags0, ef_save_target_temperature ; end writing task
                                 
                                 		endWritingAttempt:
                                 
0002aa 9508                      	ret
                                 
                                 	loadTargetTemperature:
0002ab 99e1                      		sbic eecr, eewe ; wait for completion of previous write
0002ac 940c 02bb                 			jmp endReadAttempt
0002ae e000                      		ldi temp, targetTempSavingAddr
0002af bb0f                      		out eearh, temp
0002b0 bb0e                      		out eearl, temp
0002b1 9ae0                      		sbi  eecr, eere ; start eeprom read by writing eere
0002b2 b30d                      		in temp, eedr ; read data from data register
0002b3 9300 011d                 		sts targetTemperature, temp
                                 
0002b5 e0f1                      		ldi zh, high(eventsFlags1)
0002b6 e2ef                      		ldi zl, low(eventsFlags1)
0002b7 8180                      		ld tempFlag2, z
0002b8 778f                      		cbr tempFlag2, ef_load_target_temp ; end loading task if it success
0002b9 9380 012f                 		sts eventsFlags1, tempFlag2
                                 		
                                 		endReadAttempt:
0002bb 9508                      	ret
                                 
                                 	checkEngineTemperature:
0002bc e0f1                      		ldi zh, high(eventsFlags1)
0002bd e2ef                      		ldi zl, low(eventsFlags1)
0002be 8180                      		ld tempFlag2, z
0002bf 7f8b                      		cbr tempFlag2, ef_check_engine_temperature
0002c0 9380 012f                 		sts eventsFlags1, tempFlag2
                                 
0002c2 e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
0002c3 e0a0                      		ldi xl, low(analogValuesTable)
0002c4 e032                      		ldi temp4, engineThermalSensorNum
0002c5 0fa3                      		add xl, temp4
0002c6 910c                      		ld temp, x
                                 
0002c7 3f08                      		cpi temp, 128 + 120 ; if engine temperature is more than 120C
0002c8 f420                      			brsh enableEngineTempWarning
0002c9 3300                      		cpi temp, 128 - 80 ; if enginge temperature is strangely low then warning too
0002ca f010                      			brlo enableEngineTempWarning
0002cb 940c 02cf                 			jmp endEngineTemperatureCheck
                                 			
                                 		enableEngineTempWarning:
0002cd 940e 0149                 			call enableWarningSignal
                                 
                                 		endEngineTemperatureCheck:
0002cf 9508                      	ret
                                 
                                 	checkOutsideTemperature:
0002d0 777f                      		cbr tempFlag, ef_check_outside_temperature
0002d1 9370 0130                 		sts eventsFlags2, tempFlag
                                 
0002d3 e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
0002d4 e0a0                      		ldi xl, low(analogValuesTable)
0002d5 e031                      		ldi temp4, outsideThermalSensorNum
0002d6 0fa3                      		add xl, temp4
0002d7 910c                      		ld temp, x
                                 
0002d8 3c06                      		cpi temp, 128 + 70 ; if  temperature is more then 70C than warning
0002d9 f420                      			brsh enableOutsideTempWarning
0002da 3300                      		cpi temp, 128 - 80 ; if temperature lower then -80 than warning
0002db f010                      			brlo enableOutsideTempWarning
0002dc 940c 02e0                 			jmp endOutsideTemperatureCheck
                                 			
                                 		enableOutsideTempWarning:
0002de 940e 0149                 			call enableWarningSignal
                                 
                                 		endOutsideTemperatureCheck:
0002e0 9508                      	ret
                                 
                                 	updateConditioner:
0002e1 e0f1                      		ldi zh, high(statesFlags0)
0002e2 e3e1                      		ldi zl, low(statesFlags0)
0002e3 8180                      		ld tempFlag2, z
0002e4 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
0002e5 9508                      			ret
0002e6 7f5d                      		cbr eventsFlags0, ef_update_heater
                                 
0002e7 e0b1                      		ldi xh, high(targetTemperature) ; get target temperature from ram
0002e8 e1ad                      		ldi xl, low(targetTemperature)
0002e9 910c                      		ld temp, x
                                 
0002ea 310f                      		cpi temp, 31
0002eb f480                      			brsh condTemperatureWarning
0002ec 300a                      		cpi temp, 10
0002ed f070                      			brlo condTemperatureWarning
                                 
0002ee e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
0002ef e0a0                      		ldi xl, low(analogValuesTable)
0002f0 911c                      		ld temp2, x
                                 
                                 		
                                 
0002f1 e0b1                      		ldi xh, high(analogValuesTable) ; get outside temperature from ram
0002f2 e0a0                      		ldi xl, low(analogValuesTable)
0002f3 e031                      		ldi temp4, outsideThermalSensorNum
0002f4 0fa3                      		add xl, temp4
0002f5 913c                      		ld temp4, x
                                 
0002f6 3c16                      		cpi temp2, 128 + 70 ; + 70C
0002f7 f420                      			brsh condTemperatureWarning
0002f8 3310                      		cpi temp2, 128 - 80
0002f9 f010                      			brlo condTemperatureWarning ; -80C
0002fa 940c 02fe                 		jmp updateHeater
                                 
                                 		condTemperatureWarning:
0002fc 940e 0149                 			call enableWarningSignal
                                 
                                 		updateHeater:
0002fe 3810                      		cpi temp2, 128 ; if temperature is minus then enable heater emmediately 
0002ff f048                      			brlo enableHeater
000300 5810                      			subi temp2, 128
                                 		
000301 1710                      		cp temp2, temp
000302 f030                      			brlo enableHeater
000303 940c 0305                 			jmp disableHeater
                                 
                                 		disableHeater: ; ye ye ye useless, but just for code readability
000305 9818                      			cbi porte, heater_pin_number
000306 9a19                      			sbi porte, cooler_pin_number
000307 940c 030b                 			jmp endUpdateConditioner
                                 
                                 		enableHeater:
000309 9a18                      			sbi porte, heater_pin_number
00030a 9819                      			cbi porte, cooler_pin_number
                                 
                                 		; TODO add hummidity sensor and regulate it
                                 
                                 		endUpdateConditioner: 
00030b 940e 0310                 		call resolveEngineFlap
00030d 940e 032b                 		call resolveOutsideFlap
00030f 9508                      	ret
                                 
                                 	resolveEngineFlap:
000310 e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
000311 e0a0                      		ldi xl, low(analogValuesTable)
000312 910c                      		ld temp, x
                                 
000313 e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
000314 e0a0                      		ldi xl, low(analogValuesTable)
000315 e032                      		ldi temp4, engineThermalSensorNum
000316 0fa3                      		add xl, temp4
000317 911c                      		ld temp2, x	
                                 
000318 1701                      		cp temp, temp2
000319 f038                      			brlo checkIfNeedWarmup
00031a 940c 031c                 			jmp checkIfNeedCooldown
                                 
                                 		checkIfNeedCooldown:
00031c 9919                      			sbic porte, cooler_pin_number
00031d 940c 0326                 				jmp openEngineFlap
00031f 940c 0329                 				jmp closeEngineFlap
                                 
                                 		checkIfNeedWarmup:
000321 9918                      			sbic porte, heater_pin_number
000322 940c 0326                 				jmp openEngineFlap
000324 940c 0329                 				jmp closeEngineFlap
                                 
                                 		openEngineFlap:
000326 9a97                      			sbi portd, engine_flap_pin_num
000327 940c 032a                 			jmp endResolveEngineFlap
                                 
                                 		closeEngineFlap:
000329 9897                      			cbi portd, engine_flap_pin_num
                                 
                                 		endResolveEngineFlap:
00032a 9508                      	ret
                                 
                                 	resolveOutsideFlap:
00032b e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
00032c e0a0                      		ldi xl, low(analogValuesTable)
00032d 910c                      		ld temp, x
                                 
00032e e0b1                      		ldi xh, high(analogValuesTable) ; get outside temperature from ram
00032f e0a0                      		ldi xl, low(analogValuesTable)
000330 e031                      		ldi temp4, outsideThermalSensorNum
000331 0fa3                      		add xl, temp4
000332 911c                      		ld temp2, x	
                                 
000333 1701                      		cp temp, temp2
000334 f038                      			brlo checkIfNeedWarmupFromOutside
000335 940c 0337                 			jmp checkIfNeedCooldownFromOutside
                                 
                                 		checkIfNeedCooldownFromOutside:
000337 9919                      			sbic porte, cooler_pin_number
000338 940c 0341                 				jmp openOutsideFlap
00033a 940c 0344                 				jmp closeOutsideFlap
                                 
                                 		checkIfNeedWarmupFromOutside:
00033c 9918                      			sbic porte, heater_pin_number
00033d 940c 0341                 				jmp openOutsideFlap
00033f 940c 0344                 				jmp closeOutsideFlap
                                 
                                 		openOutsideFlap:
000341 9a96                      			sbi portd, outside_flap_pin_num
000342 940c 0345                 			jmp endResolveOutsideFlap
                                 
                                 		closeOutsideFlap:
000344 9896                      			cbi portd, outside_flap_pin_num
                                 
                                 		endResolveOutsideFlap:
                                 
000345 9508                      	ret
                                 
                                 	updateConditionerFan:
000346 e0f1                      		ldi zh, high(statesFlags0)
000347 e3e1                      		ldi zl, low(statesFlags0)
000348 8180                      		ld tempFlag2, z
000349 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
00034a 9508                      			ret
00034b 7f5e                      		cbr eventsFlags0, ef_update_conditioner_fan
                                 
00034c e0b1                      		ldi xh, high(conditionerFanState) ; get fan state from ram
00034d e2a3                      		ldi xl, low(conditionerFanState)
00034e 910c                      		ld temp, x
00034f 3000                      		cpi temp, 0
000350 f029                      			breq resetCondFanState
                                 
000351 9506                      		lsr temp
000352 3008                      		cpi temp, 0b00001000 ; if we are trying to lightup pin not connected to fan then reset it 
000353 f011                      			breq resetCondFanState
000354 940c 0357                 			jmp saveCondFanState
                                 		resetCondFanState:
000356 e800                      			ldi temp, 0b10000000
                                 		saveCondFanState:
000357 9300 0123                 			sts conditionerFanState, temp ;and save it to ram	
000359 b113                      			in temp2, porte ; get current state of prote (to not broke other stuff connected to this port)
00035a 701f                      			andi temp2, 0b00001111
00035b 2b10                      			or temp2, temp ; out new fan state to porte
00035c b913                      			out porte, temp2
00035d 9508                      	ret
                                 
                                 	updateFlaps:
00035e e0f1                      		ldi zh, high(statesFlags0)
00035f e3e1                      		ldi zl, low(statesFlags0)
000360 8180                      		ld tempFlag2, z
000361 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000362 9508                      			ret
                                 		
000363 e0f1                      		ldi zh, high(eventsFlags1)
000364 e2ef                      		ldi zl, low(eventsFlags1)
000365 8180                      		ld tempFlag2, z
000366 7d8f                      		cbr tempFlag2, ef_update_flaps
000367 9380 012f                 		sts eventsFlags1, tempFlag2
                                 
000369 e0f1                      		ldi zh, high(currentControlledFlap) ; get the number of a flap we wanna update now
00036a e2e0                      		ldi zl, low(currentControlledFlap)
00036b 8100                      		ld temp, z
                                 
00036c e0b1                      		ldi xh, high(analogValuesTable) ; get current state of needed flap control from ram
00036d e0a0                      		ldi xl, low(analogValuesTable)
00036e e028                      		ldi temp3, 8 ; flaps controlls data begins from 8th byte
00036f 0fa2                      		add xl, temp3 
000370 0fa0                      		add xl, temp ; ofset to current flap control byte
                                 	
000371 911c                      		ld temp2, x
                                 
000372 7c10                      		andi temp2, 0b11000000 ; leave only two most significant byts (every falp will have only 4 possible states)
000373 9512                      		swap temp2
                                 
000374 b121                      		in temp3, pine ; get the contents from porte
000375 7f23                      		andi temp3, 0b11110011 ; clear two pins controlling the flaps to rewrite them in next two commands
000376 2b21                      		or temp3, temp2 ; and combine it with the date we wanno output
000377 b923                      		out porte, temp3 ; then... output
                                 
000378 b120                      		in temp3, pinf ; the same trick with two pins of portf (selecting one of our 4 flaps)
000379 732f                      		andi temp3, 0b00111111 
00037a 2f10                      		mov temp2, temp
00037b 9512                      		swap temp2
00037c 0f11                      		lsl temp2
00037d 0f11                      		lsl temp2
00037e 2b21                      		or temp3, temp2
00037f 9320 0062                 		sts portf, temp3
                                 
000381 9503                      		inc temp
                                 		
000382 3004                      		cpi temp, 4 ; if next selected falp as "non existing" 5th flap then fump to first one 
000383 f410                      			brsh jumpToFirstFlap
000384 940c 0387                 			jmp saveNextFlapNum
                                 		
                                 		jumpToFirstFlap:
000386 e000                      			ldi temp, 0
                                 
                                 		saveNextFlapNum:
000387 9300 0120                 			sts currentControlledFlap, temp
000389 9508                      	ret
                                 
                                 
                                 	updateSoundType:
00038a 7b5f                      		cbr eventsFlags0, ef_update_sound_type
                                 
00038b ef00                      		ldi temp, soundSignalsDelay ; reset timer immediately
00038c bf02                      		out tcnt0, temp
                                 		
00038d e0f1                      		ldi zh, high(statesFlags0)
00038e e3e1                      		ldi zl, low(statesFlags0)
00038f 8180                      		ld tempFlag2, z
000390 fd86                      		sbrc tempFlag2, sf_warning_signal_enabled_n
000391 940c 039d                 			jmp updateWarningSignal ; if warning signal is enabled then update it
000393 fd85                      		sbrc tempFlag2, sf_click_signal_enabled_n
000394 940c 03ad                 			jmp updateClickSignal
000396 fd84                      		sbrc tempFlag2, sf_accept_signal_enabled_n
000397 940c 03be                 			jmp updateAcceptSignal
000399 fd83                      		sbrc tempFlag2, sf_cancel_signal_enabled_n
00039a 940c 03da                 			jmp updateCancelSignal
00039c 9508                      		ret	
                                 
                                 		updateWarningSignal:	
00039d ff87                      			sbrs tempFlag2, sf_sound_enabled_n
00039e 940c 03a2                 				jmp warningSound_case_0
0003a0 940c 03a9                 				jmp warningSound_case_1
                                 				warningSound_case_0:
0003a2 ef0c                      					ldi temp, tone0
0003a3 9300 012b                 					sts currentTone, temp ; set sound tone
0003a5 6880                      					sbr tempFlag2, sf_sound_enabled ; enable sound
0003a6 9380 0131                 					sts statesFlags0, tempFlag2
0003a8 9508                      				ret
                                 
                                 				warningSound_case_1:
0003a9 778f                      					cbr tempFlag2, sf_sound_enabled ; disable sound
0003aa 9380 0131                 					sts statesFlags0, tempFlag2
0003ac 9508                      				ret
                                 
                                 		updateClickSignal:
0003ad ff87                      			sbrs tempFlag2, sf_sound_enabled_n
0003ae 940c 03b2                 				jmp clickSound_case_0 ; if we haven't clicked yet than click
0003b0 940c 03b9                 				jmp clickSound_case_1 ; otherwise end lcick signal
                                 
                                 				clickSound_case_0:
0003b2 ef0c                      					ldi temp, tone0
0003b3 9300 012b                 					sts currentTone, temp ; set low sound tone  
0003b5 6880                      					sbr tempFlag2, sf_sound_enabled ; enable sound
0003b6 9380 0131                 					sts statesFlags0, tempFlag2
0003b8 9508                      				ret
                                 
                                 				clickSound_case_1:
0003b9 7d8f                      					cbr tempFlag2, sf_click_signal_enabled ; end click sound
0003ba 778f                      					cbr tempFlag2, sf_sound_enabled ; disable sound
0003bb 9380 0131                 					sts statesFlags0, tempFlag2
0003bd 9508                      				ret
                                 
                                 		updateAcceptSignal:
0003be ff87                      			sbrs tempFlag2, sf_sound_enabled_n
0003bf 940c 03c3                 				jmp acceptSound_case0 ; if sound is not enabled yet than enable it and set tone low
0003c1 940c 03ca                 				jmp acceptSound_case1 ; otherwise if tone low then make it high. if tone high than end accept signal
                                 
                                 				acceptSound_case0:	
0003c3 ef0c                      					ldi temp, tone0		
0003c4 9300 012b                 					sts currentTone, temp ; set low sound tone  
0003c6 6880                      					sbr tempFlag2, sf_sound_enabled ; enable sound
0003c7 9380 0131                 					sts statesFlags0, tempFlag2
0003c9 9508                      				ret
                                 
                                 				acceptSound_case1:
0003ca e0b1                      					ldi xh, high(currentTone)
0003cb e2ab                      					ldi xl, low(currentTone)
0003cc 910c                      					ld temp, x
                                 
0003cd 3f0c                      					cpi temp, tone0
0003ce f011                      						breq acceptSound_case2 ; if tone is low make it high
0003cf 940c 03d5                 						jmp acceptSound_case3 ; otherwise end signal
                                 						acceptSound_case2:
0003d1 ef0e                      							ldi temp, tone1
0003d2 9300 012b                 							sts currentTone, temp ; set high sound tone  
0003d4 9508                      						ret
                                 						acceptSound_case3:
0003d5 778f                      							cbr tempFlag2, sf_sound_enabled	; disable sound
0003d6 7e8f                      							cbr tempFlag2, sf_accept_signal_enabled ; end accept signal
0003d7 9380 0131                 							sts statesFlags0, tempFlag2
0003d9 9508                      						ret
                                 
                                 		updateCancelSignal:
0003da ff87                      			sbrs tempFlag2, sf_sound_enabled_n
0003db 940c 03df                 				jmp cancelSound_case0 ; if sound is not enabled yet than enable it and set tone low
0003dd 940c 03e6                 				jmp cancelSound_case1 ; otherwise if tone low then make it high. if tone high than end accept signal
                                 
                                 				cancelSound_case0:
0003df ef0e                      					ldi temp, tone1			
0003e0 9300 012b                 					sts currentTone, temp ; set high sound tone  
0003e2 6880                      					sbr tempFlag2, sf_sound_enabled ; enable sound
0003e3 9380 0131                 					sts statesFlags0, tempFlag2
0003e5 9508                      				ret
                                 
                                 				cancelSound_case1:
0003e6 e0b1                      					ldi xh, high(currentTone)
0003e7 e2ab                      					ldi xl, low(currentTone)
0003e8 910c                      					ld temp, x
                                 
0003e9 3f0e                      					cpi temp, tone1
0003ea f011                      						breq cancelSound_case2 ; if tone high make it low
0003eb 940c 03f1                 						jmp cancelSound_case3 ; otherwise end signal
                                 						cancelSound_case2:
0003ed ef0c                      							ldi temp, tone0
0003ee 9300 012b                 							sts currentTone, temp ; set sound tone  
0003f0 9508                      						ret
                                 						cancelSound_case3:
0003f1 778f                      							cbr tempFlag2, sf_sound_enabled	; disable sound
0003f2 7f87                      							cbr tempFlag2, sf_cancel_signal_enabled ; end accept signal
0003f3 9380 0131                 							sts statesFlags0, tempFlag2
0003f5 9508                      						ret
                                 
                                 
                                 
                                 	updateWaveState:
0003f6 775f                      		cbr eventsFlags0, ef_update_sound_wave_state
                                 
0003f7 e0b1                      		ldi xh, high(currentTone)
0003f8 e2ab                      		ldi xl, low(currentTone)
0003f9 910c                      		ld temp, x
                                 
0003fa bd04                      		out tcnt2, temp ; reset timer2 immediately to prevent bad sound
                                 
0003fb e0f1                      		ldi zh, high(statesFlags0)
0003fc e3e1                      		ldi zl, low(statesFlags0)
0003fd 8180                      		ld tempFlag2, z
0003fe ff87                      		sbrs tempFlag2, sf_sound_enabled_n ; if we should not prodice some sound
0003ff 9518                      			reti ; do nothing
000400 9b95                      			sbis portd, speaker_pin_number ; if this pin is low
000401 940c 0405                 				jmp speakerWaveUp ; then make it high
000403 940c 0407                 				jmp speakerWaveDown ; otherwise make it low
                                 
                                 			speakerWaveUp:
000405 9a95                      				sbi portd, speaker_pin_number ; make it high
000406 9518                      				reti
                                 			speakerWaveDown:
000407 9895                      				cbi portd, speaker_pin_number ; make it low
000408 9518                      				reti
                                 				; result sound wave 				____	  ____	    ____	  ____
                                 				; will be something like that:	___|	|____|	  |____|    |____|    |____
                                 
                                 
                                 	readInput:
000409 b709                      		in temp, eimsk ; disable external intrruption int0
00040a 7f0e                      		andi temp, 0b11111110
00040b bf09                      		out eimsk, temp
                                 
00040c 7d5f                      		cbr eventsFlags0, ef_handle_input
                                 		
00040d e000                      		ldi temp, 0b00000000 ; check first row
00040e bb0b                      		out porta, temp
00040f b309                      		in temp, pina ; get pressed button
                                 		
000410 940e 0421                 		call checkInput
                                 
000412 e008                      		ldi temp, 0b00001000 ; check 2nd row
000413 bb0b                      		out porta, temp
000414 b309                      		in temp, pina 
                                 
000415 940e 0421                 		call checkInput
                                 
000417 e100                      		ldi temp, 0b00010000 ; check third row
000418 bb0b                      		out porta, temp
000419 b309                      		in temp, pina 
                                 
00041a 940e 0421                 		call checkInput
                                 
00041c e108                      		ldi temp, 0b00011000 ; check the last row
00041d bb0b                      		out porta, temp
00041e b309                      		in temp, pina ; 
                                 
00041f 940c 0428                 		jmp endReadingInput
                                 
                                 		checkInput:
000421 2f10                      			mov temp2, temp
000422 7017                      			andi temp2, 0b00000111 ; check only three bits indicating pressed button
000423 3010                      			cpi temp2, 0
000424 f409                      			brne clearReturnAddr	
000425 9508                      		ret
                                 
                                 		clearReturnAddr:
000426 911f                      			pop temp2 ; removing returning addr from stack
000427 911f                      			pop temp2
                                 		endReadingInput:
000428 9300 012c                 			sts currentKey, temp ; finally save pressed key
00042a e800                      			ldi temp, 0b10000000 ; enable continuous keyboard checking
00042b bb0b                      			out porta, temp 
                                 			
00042c b709                      			in temp, eimsk
00042d e011                      			ldi temp2, 0b00000001
00042e 2b01                      			or temp, temp2 ; enable external intrruption int0
00042f bf09                      			out eimsk, temp
000430 9508                      	ret
                                 
                                 	switchDisplayData:
000431 e0f1                      		ldi zh, high(eventsFlags1)
000432 e2ef                      		ldi zl, low(eventsFlags1)
000433 8180                      		ld tempFlag2, z
000434 7f8d                      		cbr tempFlag2, ef_switch_display_data
000435 9380 012f                 		sts eventsFlags1, tempFlag2
                                 
000437 e0f1                      		ldi zh, high(statesFlags0)
000438 e3e1                      		ldi zl, low(statesFlags0)
000439 8180                      		ld tempFlag2, z
00043a fd86                      		sbrc tempFlag2, sf_warning_signal_enabled_n
00043b 940c 0442                 			jmp checkDisplayErrorMessage
00043d 7f8e                      			cbr tempFlag2, sf_display_error_message
00043e 9380 0131                 			sts statesFlags0, tempFlag2
000440 940c 044c                 			jmp normalDataSwitch
                                 
                                 		checkDisplayErrorMessage:
000442 ff80                      			sbrs tempFlag2, sf_display_error_message_n
000443 940c 0447                 				jmp switchThroughError
000445 940c 044c                 				jmp normalDataSwitch			
                                 
                                 		switchThroughError:
000447 6081                      			sbr tempFlag2, sf_display_error_message
000448 9380 0131                 			sts statesFlags0, tempFlag2
00044a 940c 045c                 			jmp endSwitchingDisplayData
                                 
                                 		normalDataSwitch:
00044c 7f8e                      			cbr tempFlag2, sf_display_error_message
00044d 9380 0131                 			sts statesFlags0, tempFlag2
00044f e0b1                      		ldi xh, high(currentDisplayData) ; get "number" of type of data we wanna to be displayed
000450 e1aa                      				ldi xl, low(currentDisplayData)
000451 910c                      				ld temp, x
                                 
000452 3001                      				cpi temp, 1
000453 f428                      					brsh goToFirstData
                                 					;else next data
000454 9503                      					inc temp
000455 9300 011a                 					sts currentDisplayData, temp
000457 940c 045c                 					jmp endSwitchingDisplayData
                                 
                                 					goToFirstData:
000459 e000                      						ldi temp, 0
00045a 9300 011a                 						sts currentDisplayData, temp
                                 		
                                 		endSwitchingDisplayData:
                                 
00045c 9508                      	ret
                                 
                                 	update7segScreen:
00045d 7e5f                      		cbr eventsFlags0, ef_update_7seg_screen
                                 
00045e ef0f                      		ldi temp, 0xff 
00045f ef10                      		ldi temp2, 0xf0
000460 bd0d                      		out tcnt1h, temp
000461 bd1c                      		out tcnt1l, temp2
                                 		
000462 e0b1                      		ldi xh, high(curPos7Seg) ; get pereviously printed display indicator from ram
000463 e1a9                      		ldi xl, low(curPos7Seg)
000464 912c                      		ld temp3, x
                                 
000465 9523                      		inc temp3
                                 
000466 3028                      		cpi temp3, 8
000467 f410                      			brsh jumpToFirst7seg
000468 940c 0488                 			jmp printGlyph
                                 
                                 		jumpToFirst7seg:
00046a e020                      			ldi temp3, 0 ; select first indicator
00046b 940e 049e                 			call clear7SegScrBuffer
00046d e0b1                      			ldi xh, high(currentDisplayData)
00046e e1aa                      			ldi xl, low(currentDisplayData)
00046f 910c                      			ld temp, x
                                 				
000470 e0f1                      			ldi zh, high(statesFlags0)
000471 e3e1                      			ldi zl, low(statesFlags0)
000472 8180                      			ld tempFlag2, z
000473 fd80                      			sbrc tempFlag2, sf_display_error_message_n
000474 940c 0486                 				jmp selectErrorMessage
000476 3000                      			cpi temp, 0
000477 f011                      				breq selectTemperaturesData ; TODO prevent failing compairing after SBR command in interruption handler
000478 3001                      			cpi temp, 1
000479 f041                      				breq selectTachometerData
                                 
                                 			selectTemperaturesData:
00047a 940e 04ed                 				call printEngineTemperature
00047c 940e 04d8                 				call printCurrentTemperature
00047e 940e 04c5                 				call printTargetTemperature
000480 940c 0488                 				jmp endJumpToFirstSegment
                                 
                                 			selectTachometerData:
000482 940e 04b2                 				call printTachometerValue
000484 940c 0488                 				jmp endJumpToFirstSegment
                                 
                                 			selectErrorMessage:
000486 940e 0507                 				call printErrorMessage
                                 
                                 			endJumpToFirstSegment:
                                 
                                 
                                 		printGlyph:
000488 9320 0119                 			sts curPos7Seg, temp3
                                 
                                 			; get number of a glyph 
00048a e0b1                      			ldi xh, high(SevenSegScrBuff)
00048b e1a0                      			ldi xl, low(SevenSegScrBuff)
00048c 0fa2                      			add  xl, temp3
                                 
00048d 910c                      			ld temp, x
                                 
00048e e0f0                      			ldi zh,0
00048f eae0                      			ldi zl, charTable7seg * 2
                                 
000490 0fe0                      			add zl, temp
000491 9104                      			lpm temp, z
                                 
000492 3021                      			cpi temp3, 1
000493 f021                      				breq printDot
000494 3024                      			cpi temp3, 4
000495 f011                      				breq printDot
000496 940c 0499                 				jmp moveGlyphToscreen
                                 			
                                 			printDot:
000498 7f0e                      				andi temp, 0b11111110
                                 
                                 			moveGlyphToScreen:
000499 9522                      			swap temp3
00049a 0f22                      			lsl temp3
00049b bb28                      			out portb, temp3 ; select place on display
                                 
00049c bb05                      			out portc, temp ; print glyph
00049d 9508                      	ret
                                 
                                 	clear7SegScrBuffer:
00049e e0f0                      		ldi zh, 0
00049f eae0                      		ldi zl, charTable7seg * 2
0004a0 e103                      		ldi temp, chSpace ; load space glyph
                                 		;add zl, temp
                                 		;lpm temp, z
                                 
0004a1 9300 0110                 		sts SevenSegScrBuff + 0, temp ; clear unused display indicators
0004a3 9300 0111                 		sts SevenSegScrBuff + 1, temp
0004a5 9300 0112                 		sts SevenSegScrBuff + 2, temp
0004a7 9300 0113                 		sts SevenSegScrBuff + 3, temp
0004a9 9300 0114                 		sts SevenSegScrBuff + 4, temp
0004ab 9300 0115                 		sts SevenSegScrBuff + 5, temp
0004ad 9300 0116                 		sts SevenSegScrBuff + 6, temp
0004af 9300 0117                 		sts SevenSegScrBuff + 7, temp
0004b1 9508                      	ret
                                 
                                 	printTachometerValue:
0004b2 e0b1                      		ldi xh, high(engineSpeed) ; get engineSpeed from ram
0004b3 e2a9                      		ldi xl, low(engineSpeed)
0004b4 910c                      		ld temp, x
                                 	
0004b5 940e 0516                 		call convertBinToDec
0004b7 2f10                      		mov temp2, temp
0004b8 701f                      		andi temp2, 0b00001111 ; select low page
0004b9 9310 0112                 		sts SevenSegScrBuff + 2 , temp2 ; place the actual glyph number in a buffer
                                 
0004bb 7f00                      		andi temp, 0b11110000 ; select high page
0004bc 9502                      		swap temp
0004bd 9300 0111                 		sts SevenSegScrBuff + 1, temp ; place the actual glyph nubmer in a buffer
                                 
0004bf e000                      		ldi temp, ch0
0004c0 9300 0113                 		sts SevenSegScrBuff + 3, temp
0004c2 9300 0114                 		sts SevenSegScrBuff + 4, temp
0004c4 9508                      	ret
                                 
                                 	
                                 	printTargetTemperature:
0004c5 e0f1                      		ldi zh, high(statesFlags0)
0004c6 e3e1                      		ldi zl, low(statesFlags0)
0004c7 8180                      		ld tempFlag2, z
0004c8 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
0004c9 9508                      			ret
0004ca e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
0004cb e1ad                      		ldi xl, low(targetTemperature)
0004cc 910c                      		ld temp, x
                                 	
0004cd 940e 0516                 		call convertBinToDec
0004cf 2f10                      		mov temp2, temp
0004d0 701f                      		andi temp2, 0b00001111 ; select low page
0004d1 9310 0114                 		sts SevenSegScrBuff + 4, temp2 ; place the actual glyph number in a buffer
                                 
0004d3 7f00                      		andi temp, 0b11110000 ; select high page
0004d4 9502                      		swap temp
0004d5 9300 0113                 		sts SevenSegScrBuff + 3, temp ; place the actual glyph nubmer in a buffer
0004d7 9508                      	ret
                                 
                                 	printCurrentTemperature:
0004d8 e0b1                      		ldi xh, high(analogValuesTable) ; get temperature from ram
0004d9 e0a0                      		ldi xl, low(analogValuesTable)
0004da 910c                      		ld temp, x
                                 
0004db 3800                      		cpi temp, 128 ; check right at the beggining if this number negative
0004dc f420                      			brsh convertTemperature
                                 
                                 		negateTemperature:
0004dd e111                      			ldi temp2,  chMinus ; "-" glyph number in a table
0004de 9310 0115                 			sts SevenSegScrBuff + 5, temp2
0004e0 9500                      			com temp
                                 			
                                 		convertTemperature:
0004e1 5800                      			subi temp, 128
0004e2 940e 0516                 			call convertBinToDec
                                 	
0004e4 2f10                      			mov temp2, temp
0004e5 701f                      			andi temp2, 0b00001111 ; select low page
0004e6 9310 0117                 			sts SevenSegScrBuff + 7, temp2 ; place the actual glyph number in a buffer
                                 
0004e8 7f00                      			andi temp, 0b11110000 ; select high page
0004e9 9502                      			swap temp
0004ea 9300 0116                 			sts SevenSegScrBuff + 6, temp ; place the actual glyph nubmer in a buffer
0004ec 9508                      	ret
                                 
                                 	printEngineTemperature:
0004ed e0b1                      		ldi xh, high(analogValuesTable) ; get temperature from ram
0004ee e0a0                      		ldi xl, low(analogValuesTable)
0004ef e002                      		ldi temp, 2
0004f0 0fa0                      		add xl, temp
0004f1 910c                      		ld temp, x
                                 		
0004f2 3800                      		cpi temp, 128
0004f3 f068                      		 brlo printEngineTempNegative
                                 
0004f4 5800                      		subi temp, 128
0004f5 940e 0516                 		call convertBinToDec
                                 	
0004f7 2f10                      		mov temp2, temp
0004f8 701f                      		andi temp2, 0b00001111 ; select low page
0004f9 9310 0111                 		sts SevenSegScrBuff + 1, temp2 ; place the actual glyph number in a buffer
                                 
0004fb 7f00                      		andi temp, 0b11110000 ; select high page
0004fc 9502                      		swap temp
0004fd 9300 0110                 		sts SevenSegScrBuff, temp ; place the actual glyph nubmer in a buffer
0004ff 940c 0506                 		jmp endEngineTempPrinting
                                 
                                 		printEngineTempNegative:
000501 e101                      			ldi temp, chMinus ; load "minus" gliph number
000502 9300 0110                 			sts SevenSegScrBuff, temp
000504 9300 0111                 			sts SevenSegScrBuff + 1, temp
                                 
                                 		endEngineTempPrinting:
000506 9508                      	ret
                                 
                                 	printErrorMessage:	
000507 e00e                      		ldi temp, chE
000508 9300 0110                 		sts SevenSegScrBuff, temp
00050a e102                      		ldi temp, chR
00050b 9300 0111                 		sts SevenSegScrBuff + 1, temp
00050d 9300 0112                 		sts SevenSegScrBuff + 2, temp
00050f e000                      		ldi temp, ch0
000510 9300 0113                 		sts sevenSegScrBuff + 3, temp
000512 e102                      		ldi temp, chR
000513 9300 0114                 		sts sevenSegScrBuff + 4, temp
000515 9508                      	ret
                                 
                                 	convertBinToDec:
000516 3604                      		cpi temp, 100 ; check right at the beggining if this number is to big to display it on the screen
000517 f5d8                      		brsh btdMax
000518 e010                      		ldi temp2, 0 ; yeeeeeee no looooopsss ahahahhachchahhhacha
000519 300a                      			cpi temp, 10
00051a f414                      			brge increaseTens0
00051b 940c 0559                 				jmp setLowPage
                                 		increaseTens0:
00051d 500a                      			subi temp, 10
00051e 9513                      			inc temp2
00051f 300a                      			cpi temp, 10
000520 f414                      			brge increaseTens1
000521 940c 0559                 				jmp setLowPage
                                 		increaseTens1:
000523 500a                      			subi temp, 10
000524 9513                      			inc temp2
000525 300a                      			cpi temp, 10
000526 f414                      			brge increaseTens2
000527 940c 0559                 				jmp setLowPage
                                 		increaseTens2:
000529 500a                      			subi temp, 10
00052a 9513                      			inc temp2
00052b 300a                      			cpi temp, 10
00052c f414                      			brge increaseTens3
00052d 940c 0559                 				jmp setLowPage
                                 		increaseTens3:
00052f 500a                      			subi temp, 10
000530 9513                      			inc temp2
000531 300a                      			cpi temp, 10
000532 f414                      			brge increaseTens4
000533 940c 0559                 				jmp setLowPage
                                 		increaseTens4:
000535 500a                      			subi temp, 10
000536 9513                      			inc temp2
000537 300a                      			cpi temp, 10
000538 f414                      			brge increaseTens5
000539 940c 0559                 				jmp setLowPage
                                 		increaseTens5:
00053b 500a                      			subi temp, 10
00053c 9513                      			inc temp2
00053d 300a                      			cpi temp, 10
00053e f414                      			brge increaseTens6
00053f 940c 0559                 				jmp setLowPage
                                 		increaseTens6:
000541 500a                      			subi temp, 10
000542 9513                      			inc temp2
000543 300a                      			cpi temp, 10
000544 f414                      			brge increaseTens7
000545 940c 0559                 				jmp setLowPage
                                 		increaseTens7:
000547 500a                      			subi temp, 10
000548 9513                      			inc temp2
000549 300a                      			cpi temp, 10
00054a f414                      			brge increaseTens8
00054b 940c 0559                 				jmp setLowPage
                                 		increaseTens8:
00054d 500a                      			subi temp, 10
00054e 9513                      			inc temp2
00054f 301a                      			cpi temp2, 10
000550 f414                      				brge btdMax
000551 940c 0559                 				jmp setLowPage
                                 		btdMax:
000553 e019                      			ldi temp2, 9
000554 2f01                      			mov temp, temp2
000555 9502                      			swap temp
000556 0f01                      			add temp, temp2
                                 			
000557 940c 055c                 			jmp endBTDConv
                                 
                                 		setLowPage:
000559 9502                      			swap temp ; move low number to high page
00055a 0f01                      			add temp, temp2 ; save hig number to low page
00055b 9502                      			swap temp
                                 
                                 		endBTDConv:	
00055c 9508                      	ret
                                 
                                 
                                 	readAnalogSensors:
00055d 7f57                      		cbr eventsFlags0, ef_read_analog_sensors
                                 
00055e e0b1                      		ldi xh, high(currentSensorNum) ; get the nubmer of thermal sensor we wanna read from
00055f e1a8                      		ldi xl, low(currentSensorNum)
000560 911c                      		ld temp2, x
                                 
000561 e0f1                      		ldi zh, high(analogValuesTable) ; seting up addres of the beginning of temperatuers table
000562 e0e0                      		ldi zl, low(analogValuesTable)
                                 
000563 0fe1                      		add zl, temp2 ; apply offset to store data to correct place in a table
                                 
000564 b104                      		in temp, adcl
000565 b105                      		in temp, adch
000566 8300                      		st z, temp ; and finally store it
                                 
000567 9513                      		inc temp2 ; select next sensor value to be readen in the next iterration
                                 
                                 		
000568 3110                      		cpi temp2, 16 ; if next sensor is "non existing" 17th sensor then return to first one
000569 f414                      			brge jumpToFirstSensor
00056a 940c 056d                 			jmp saveNextSensorNumber ; else just save the next sensor nubmer
                                 
                                 		jumpToFirstSensor:
00056c e010                      			ldi temp2, 0
                                 
                                 		saveNextSensorNumber:
00056d 9310 0118                 			sts currentSensorNum, temp2
00056f 0f11                      			lsl temp2
000570 b100                      			in temp, pinf ; get content of portf
000571 7e01                      			andi temp, 0b11100001 ; clear 4 bits to rewrite them later
000572 2b10                      			or temp2, temp
000573 9310 0062                 			sts portf, temp2
                                 
000575 e600                      		ldi temp, 0b01100000 ; and restart adc after all
000576 b907                      		out admux, temp
000577 ed0e                      		ldi temp, 0b11011110
000578 b906                      		out adcsra, temp
000579 9508                      	ret
                                 
                                 	updateTachometer:
00057a e0f1                      		ldi zh, high(eventsFlags1)
00057b e2ef                      		ldi zl, low(eventsFlags1)
00057c 8180                      		ld tempFlag2, z
00057d 7f87                      		cbr tempFlag2, ef_update_tachometer
00057e 9380 012f                 		sts eventsFlags1, tempFlag2
                                 		
000580 e0b1                      		ldi xh, high(tachometerCounter) ; get value counted by tachometer counter durring 0.1 sec
000581 e2a8                      		ldi xl, low(tachometerCounter)
000582 910c                      		ld temp, x
                                 		;inc temp ; some kind of trikky compensation
                                 
000583 e016                      		ldi temp2, 6
000584 9f01                      		mul temp, temp2 ; because it is 6*10 seconds in one minute
000585 2d00                      		mov temp, r0 ; get product low (numbers will not be to big)
                                 
                                 		
                                 
000586 3600                      		cpi temp, 96
000587 f410                      			brsh tachometerMax
000588 940c 058b                 			jmp saveEngineSpeed
                                 
                                 		tachometerMax:
00058a e603                      			ldi temp, 99
                                 		saveEngineSpeed:
00058b 9300 0129                 			sts engineSpeed, temp
00058d e000                      			ldi temp, 0
00058e 9300 0128                 			sts tachometerCounter, temp
000590 9508                      	ret
                                 
                                 	incrementTachometerCounter:
000591 e0f1                      		ldi zh, high(eventsFlags1)
000592 e2ef                      		ldi zl, low(eventsFlags1)
000593 8180                      		ld tempFlag2, z
000594 7e8f                      		cbr tempFlag2, ef_increment_tachometer
000595 9380 012f                 		sts eventsFlags1, tempFlag2
                                 
000597 b709                      		in temp, eimsk ; disable external intrruption int1
000598 7f0d                      		andi temp, 0b11111101
000599 bf09                      		out eimsk, temp
                                 
00059a e0b1                      		ldi xh, high(tachometerCounter)
00059b e2a8                      		ldi xl, low(tachometerCounter)
00059c 910c                      		ld temp, x
                                 		
00059d 3f0f                      		cpi temp, 255
00059e f029                      			breq endIncTachCounter
00059f 940c 05a1                 			jmp incTachCounter
                                 
                                 		incTachCounter:
0005a1 9503                      			inc temp
0005a2 9300 0128                 			sts tachometerCounter, temp
                                 		
                                 		endIncTachCounter:
0005a4 b709                      			in temp, eimsk
0005a5 e012                      			ldi temp2, 0b00000010
0005a6 2b01                      			or temp, temp2 ; enable external intrruption int1
0005a7 bf09                      			out eimsk, temp
0005a8 9508                      	ret
                                 	
                                 
                                 	////////////INTERRUPTIONS HANDLERS/////////////
                                 	extInt0Handler:
0005a9 b74f                      		in tempInter, sreg
0005aa 6250                      		sbr eventsFlags0, ef_handle_input
0005ab bf4f                      		out sreg, tempInter
0005ac 9518                      	reti
                                 
                                 	extInt1Handler:
0005ad b74f                      		in tempInter, sreg
0005ae e0d1                      		ldi yh, high(eventsFlags1)
0005af e2cf                      		ldi yl, low(eventsFlags1)
0005b0 8168                      		ld tempInter2, y
0005b1 6160                      		sbr tempInter2, ef_increment_tachometer
0005b2 9360 012f                 		sts eventsFlags1, tempInter2
0005b4 bf4f                      		out sreg, tempInter
0005b5 9518                      	reti
                                 
                                 	timer0OvfHandler:
0005b6 b74f                      		in tempInter, sreg
0005b7 6450                      		sbr eventsFlags0, ef_update_sound_type
0005b8 bf4f                      		out sreg, tempInter
0005b9 9518                      	reti
                                 
                                 	timer1OvfHandler:
0005ba b74f                      		in tempInter, sreg
0005bb 6150                      		sbr eventsFlags0, ef_update_7seg_screen
0005bc bf4f                      		out sreg, tempInter
0005bd 9518                      	reti
                                 
                                 	timer2OvfHandler: 
0005be b74f                      		in tempInter, sreg
0005bf 6850                      		sbr eventsFlags0, ef_update_sound_wave_state
0005c0 bf4f                      		out sreg, tempInter
0005c1 9518                      	reti
                                 
                                 	timer3OvfHandler:
0005c2 b74f                      		in tempInter, sreg
0005c3 e0d1                      		ldi yh, high(eventsFlags1)
0005c4 e2cf                      		ldi yl, low(eventsFlags1)
0005c5 8168                      		ld tempInter2, y
0005c6 6460                      		sbr tempInter2, ef_update_program_timers
0005c7 9360 012f                 		sts eventsFlags1, tempInter2
0005c9 bf4f                      		out sreg, tempInter
0005ca 9518                      	reti
                                 
                                 	adcConvertionHandler:	
0005cb b74f                      		in tempInter, sreg
0005cc 6058                      		sbr eventsFlags0, ef_read_analog_sensors
0005cd bf4f                      		out sreg, tempInter


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :  48 y  :   2 z  :  35 r0 :   1 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 350 r17:  85 r18:  24 r19:  14 r20:  14 
r21:  25 r22:   6 r23:  21 r24: 126 r25:   0 r26:  60 r27:  48 r28:   2 
r29:   2 r30:  38 r31:  36 
Registers used: 19 out of 35 (54.3%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  16 adiw  :   0 and   :   0 
andi  :  17 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  24 brge  :  12 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  13 brlt  :   0 brmi  :   0 
brne  :   1 brpl  :   0 brsh  :  15 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  56 cbi   :   7 cbr   :  34 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   1 cp    :   3 cpc   :   0 
cpi   :  62 cpse  :   0 dec   :   1 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  22 inc   :  28 
jmp   : 105 ld    :  83 ldd   :   0 ldi   : 267 lds   :   0 lpm   :   2 
lsl   :   4 lsr   :   1 mov   :   8 movw  :   0 mul   :   1 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   8 ori   :   0 out   :  49 
pop   :   2 push  :   0 rcall :   0 ret   :  54 reti  :  10 rjmp  :   0 
rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 sbi   :  13 sbic  :   6 
sbis  :   1 sbiw  :   0 sbr   :  29 sbrc  :  26 sbrs  :  14 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   : 116 sub   :   0 subi  :  12 swap  :  10 tst   :   0 wdr   :   0 

Instructions used: 40 out of 114 (35.1%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000b9e   2822     24   2846  131072   2.2%
[.dseg] 0x000100 0x000132      0     50     50    4096   1.2%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
