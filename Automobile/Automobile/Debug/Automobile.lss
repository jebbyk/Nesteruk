
AVRASM ver. 2.2.7  C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm Mon Dec 21 22:22:27 2020

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
                                 
                                 .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 .def temp = r16 ; temporal registter for some actions
                                 .def temp2 = r17
                                 .def temp3 = r18
                                 .def temp4 = r19
                                 .def tempInter = r20
                                 .def eventsFlags0 = r21
                                 .def eventsFlags1 = r22
                                 .def tempFlag = r23
                                 .def tempFlag2 = r24
                                 
                                 .equ speaker_pin_number = 5
                                 .equ speaker_pin_position = 0b00000100 ; speaker will be connected on 5th pin of portD
                                 
                                 .equ engine_flap_pin_num = 7 ; engine cooler flap will be contolled by the electrical magnet
                                 .equ engine_flap_pin_pos = 0b10000000
                                 
                                 .equ outside_flap_pin_num = 6 ; the same for outside flap
                                 .equ outside_flap_pin_pos = 0b01000000
                                 
                                 .equ debug_pin_position = 0b00100000 ; will use this pin to show something idk
                                 .equ debug_pin_number = 5
                                 
                                 .equ heater_pin_number = 0
                                 .equ heater_pin_position = 0b000000001
                                 .equ cooler_pin_number = 1
                                 .equ cooler_pin_position = 0b000000010
                                 
                                 .equ frontAirbagsTriggerPinNumber = 4
                                 .equ frontAirbagsTriggerPinPosition = 0b00010000
                                 .equ sideAirbagsTriggerPinNumber = 3
                                 .equ sideAirbagsTriggerPinPosition =  0b00001000
                                 .equ maxAllowedSideAcceleration = 40
                                 .equ maxAllowedForwardAcceleration = 100
                                 .equ maxAllowedBackwardAcceleration = 70
                                 .equ accelerationCheckingFreq = 128 + 64 + 32 + 16 + 8 + 4 + 2
                                 
                                 .equ insideThermalSensorNum = 0
                                 .equ outsideThermalSensorNum = 1
                                 .equ engineThermalSensorNum = 2
                                 .equ steeringWheelSensorNum = 3
                                 .equ seat0ThermalSensorNum = 4 ; TODO can be done without these 4 lines of code
                                 .equ seat1ThermalSensorNum = 5
                                 .equ seat2ThermalSensorNum = 6
                                 .equ seat3ThermalSensorNum = 7 
                                 .equ seat0FlapControl = 8
                                 .equ seat1FlapControl = 9
                                 .equ seat2FlapControl = 10
                                 .equ seat3FlapControl = 11
                                 .equ accelerationFrontSensorZ = 12
                                 .equ accelerationFrontSensorX = 13
                                 .equ accelerationRearSensorX = 14
                                 .equ lolkekcheburek = 15
                                 
                                 .equ tccr0_setup_byte = 0b00000101 ; select speed for timer0
                                 .equ assr_setup_byte =  0b00001000 ; select async oscilator (slower speed and independent from main clock)
                                 .equ tccr1b_setup_byte = 0b00000101 ; seelect speed for timer1
                                 .equ tccr2_setup_byte = 0b00000101 ; select speed for timer2
                                 .equ tccr3b_setup_byte = 0b00000011 ; select speed for timer3
                                 .equ timsk_setup_byte = 0b01000101 ; enable timer2, tiemr1 and timer0 interruption on overflowz
                                 .equ etimsk_setup_byte = 0b00000100 ; enable temer3 interruption on overflow
                                 
                                 .equ ch0 = 0
                                 .equ ch1 = 1
                                 .equ ch2 = 2
                                 .equ ch3 = 3
                                 .equ ch4 = 4
                                 .equ ch5 = 5
                                 .equ ch6 = 6
                                 .equ ch7 = 7
                                 .equ ch8 = 8
                                 .equ ch9 = 9
                                 .equ chA = 10
                                 .equ chB = 11
                                 .equ chC = 12
                                 .equ chD = 13
                                 .equ chE = 14
                                 .equ chF = 15
                                 .equ chGrad = 16
                                 .equ chMinus = 17
                                 .equ chR = 18
                                 .equ chSpace = 19
                                 
                                 .equ soundSignalsDelay = 128 + 64 + 32 + 16 ; (lower number bigger delays)
                                 	.equ tone0 = 0 + 128 + 64 + 32 + 16 + 8 + 4 ; (lower number -lower tone)
                                  	.equ tone1 = 0 + 128 + 64 + 32 + 16 + 8 + 4 + 2
                                 
                                 .equ displayDataSwitchingFreq = 128 + 64 + 32 ; bigger number - faster switching
                                 
                                 .equ checkOutsideTemperatureFreq = 128 + 64 + 32 + 16 
                                 
                                 .equ condFanSpeed = 249; higher number - higher speed
                                 	
                                 
                                 	; states flags 0
                                 	.equ sf_sound_enabled =				0b10000000
                                 	.equ sf_sound_enabled_n =			7
                                 	.equ sf_warning_signal_enabled =	0b01000000
                                 	.equ sf_warning_signal_enabled_n =  6
                                 	.equ sf_click_signal_enabled  =		0b00100000
                                 	.equ sf_click_signal_enabled_n =	5
                                 	.equ sf_accept_signal_enabled =		0b00010000
                                 	.equ sf_accept_signal_enabled_n =	4
                                 	.equ sf_cancel_signal_enabled =		0b00001000
                                 	.equ sf_cancel_signal_enabled_n =	3
                                 	.equ sf_conditioner_enabled =		0b00000100
                                 	.equ sf_conditioner_enabled_n =		2
                                 	.equ sf_engine_cooler_flap_state =	0b00000010
                                 	.equ sf_engine_cooler_flap_state_n = 1
                                 	.equ sf_display_error_message =		0b00000001
                                 	.equ sf_display_error_message_n =	0
                                 
                                 	; eventsFlags0
                                 	.equ ef_update_sound_wave_state =	0b10000000
                                 	.equ ef_update_sound_wave_state_n =	7
                                 	.equ ef_update_sound_type =			0b01000000
                                 	.equ ef_update_sound_type_n =		6
                                 	.equ ef_handle_input =				0b00100000
                                 	.equ ef_handle_input_n =			5
                                 	.equ ef_update_7seg_screen =		0b00010000
                                 	.equ ef_update_7seg_screen_n =		4
                                 	.equ ef_read_analog_sensors =		0b00001000
                                 	.equ ef_read_analog_sensors_n =		3
                                 	.equ ef_save_target_temperature =	0b00000100
                                 	.equ ef_save_target_temperature_n = 2
                                 	.equ ef_update_heater =				0b00000010
                                 	.equ ef_update_heater_n =			1
                                 	.equ ef_update_conditioner_fan =	0b00000001
                                 	.equ ef_update_conditioner_fan_n =	0
                                 
                                 
                                 	; events flags1
                                 	.equ ef_load_target_temp =			0b10000000
                                 	.equ ef_load_target_temp_n =		7
                                 	.equ ef_update_program_timers =		0b01000000
                                 	.equ ef_update_program_timers_n =	6
                                 	.equ ef_update_flaps =				0b00100000
                                 	.equ ef_update_flaps_n =			5
                                 	.equ ef_increment_tachometer =		0b00010000
                                 	.equ ef_increment_tachometer_n =	4
                                 	.equ ef_update_tachometer =			0b00001000
                                 	.equ ef_update_tachometer_n =		3
                                 	.equ ef_check_engine_temperature =	0b00000100
                                 	.equ ef_check_engine_temperature_n = 2
                                 	.equ ef_switch_display_data =		0b00000010
                                 	.equ ef_switch_display_data_n =		1
                                 	.equ ef_handle_current_key =		0b00000001
                                 	.equ ef_handle_current_key_n =		0
                                 
                                 	; events falgs 2
                                 	.equ ef_check_outside_temperature =		0b10000000
                                 	.equ ef_check_outside_temperature_n =   7
                                 	.equ ef_check_acceleration =			0b01000000
                                 	.equ ef_check_acceleration_n =			6
                                 
                                 
                                 //addreses in eeprom where usefull data will be saved
                                 .equ targetTempSavingAddr = 0
                                 
                                 
                                 .dseg
                                 	analogValuesTable:
000100                           		.byte 16 ; there will be stored all the data from all 8 thermal sensors
                                 	SevenSegScrBuff:
000110                           		.byte 8 ; reserve 8 bytes for 7 segment dysplay buffer
                                 	currentSensorNum:
000118                           		.byte 1 ; there will be stored number of thermalSensor we wanna save data from
                                 	curPos7Seg:
000119                           		.byte 1 ; position of currently printing glyph on 7seg display
                                 	
                                 	currentDisplayData:
00011a                           		.byte 1 ; 0 - temperatures, 1 - tachometer
                                 	switchDisplayDataTimerH:
00011b                           		.byte 1 ;
                                 	switchDisplayDataTimerL:
00011c                           		.byte 1 ;
                                 
                                 	targetTemperature:
00011d                           		.byte 1 ; reserve  1 byte to keep temperature while running\
                                 	updateConditionerTimer:
00011e                           		.byte 1
                                 	flapsUpdateTimer:
00011f                           		.byte 1
                                 	currentControlledFlap:
000120                           		.byte 1
                                 	conditionerFanTimer0:
000121                           		.byte 1 ; reserve 2 bytes to store current conditioner fan timer
                                 	conditionerFanTimer1:
000122                           		.byte 1
                                 	conditionerFanState:
000123                           		.byte 1 ; reserve 1 byte to know fan "rotation" (not quite but who cares)
                                 	checkOutsideTemperatureTimerH:
000124                           		.byte 1
                                 	checkOutsideTemperatureTimerL:
000125                           		.byte 1
                                 
                                 	tachometerTimerH:
000126                           		.byte 1
                                 	tachometerTimerL:
000127                           		.byte 1
                                 	tachometerCounter:
000128                           		.byte 1
                                 	engineSpeed:
000129                           		.byte 1
                                 	checkEngineTemperatureTimer:
00012a                           		.byte 1
                                 
                                 	currentTone:
00012b                           		.byte 1 ; there will be stored current note of sound
                                 
                                 	currentKey:
00012c                           		.byte 1 ; there will be storred a number of the last pressed key
                                 	handleCurrentKeyTimer:
00012d                           		.byte 1
                                 
                                 	checkAccelerationTimer:
00012e                           		.byte 1 
                                 
                                 	eventsFlags2:
00012f                           		.byte 1
                                 	statesFlags0:
000130                           		.byte 1
                                 
                                 .cseg
                                 	.org 0
000000 940c 005c                 		jmp reset
                                 
                                 	
                                 		.org $0002
000002 940c 0560                 			jmp extInt0Handler
                                 		.org $0004
000004 940c 0564                 			jmp extInt1Handler
                                 		.org $0014
000014 940c 0570                 			jmp timer2OvfHandler
                                 		.org $001C
00001c 940c 056c                 			jmp timer1OvfHandler
                                 		.org $0020
000020 940c 0568                 			jmp timer0OvfHandler
                                 		.org $002a
00002a 940c 0578                 			jmp adcConvertionHandler
                                 		.org $003a 
00003a 940c 0574                 			jmp timer3OvfHandler
                                 
                                 
                                 	.org $0050 ; start program almost right after all intrruptions vectors
                                 
                                 	charTable7seg: 
                                 		//main simbols for 7seg display
000050 9f03
000051 0d25                      		.db 0b00000011 /*0*/, 0b10011111 /*1*/, 0b00100101 /*2*/, 0b00001101 /*3*/
000052 4999
000053 1f41                      		.db	0b10011001 /*4*/, 0b01001001 /*5*/, 0b01000001 /*6*/, 0b00011111 /*7*/
000054 0901
000055 c111                      		.db	0b00000001 /*8*/, 0b00001001 /*9*/, 0b00010001 /*a*/, 0b11000001 /*b*/
000056 8561
000057 7161                      		.db	0b01100001 /*c*/, 0b10000101 /*d*/, 0b01100001 /*e*/, 0b01110001 /*f*/
                                 
                                 		//extra simbols for 7seg display
000058 fd39
000059 ff73                      		.db	0b00111001 /*grad*/, 0b11111101 /*minus*/, 0b01110011 /*r*/, 0xff /*space*/
                                 
                                 	errorString7: 
00005a 120e
00005b 1312                      		.db chE, chR, chR, chSpace
                                 	
                                 
                                 	reset:
                                 
00005c e100                      		ldi temp, high(ramend) ; setting up stack pointer
00005d bf0e                      		out sph, temp
00005e ef0f                      		ldi temp, low(ramend)
00005f bf0d                      		out spl, temp
                                 
                                 		; setting up ports
000060 e908                      		ldi temp, 0b10011000 ; 0,1,2-in (read column), 3,4 - out (select row), 7 - out (check all buttons)
000061 bb0a                      		out ddra, temp
000062 e800                      		ldi temp, 0b10000000 ; enable continuous check if any button is pressed
000063 bb0b                      		out porta, temp
                                 
000064 ee00                      		ldi temp, 0b11100000 ; set last hree bits of portB to be output
000065 bb07                      		out ddrb, temp
                                 
000066 ef0f                      		ldi temp, 0b11111111 ; set all pins of portC to be output
000067 bb04                      		out ddrc, temp
                                 
000068 e004                      		ldi temp, speaker_pin_position
000069 e810                      		ldi temp2, engine_flap_pin_pos
00006a 2b01                      		or temp, temp2
00006b e410                      		ldi temp2, outside_flap_pin_pos
00006c 2b01                      		or temp, temp2
00006d bb01                      		out ddrd, temp
                                 
00006e ef0f                      		ldi temp, 0xff ;heater, cooler, 2,3 - flap state, 4-7 step engines (fans)
00006f b902                      		out ddre, temp
                                 
000070 ef0e                      		ldi temp, 0b11111110 ; 0 - thermSensors in, 1-4 selected thermalSensor, 6-7 selected flap
000071 9300 0061                 		sts ddrf, temp
                                 
                                 
                                 		//setting up external interrupts
000073 e003                      		ldi temp, 0b00000011 ; enable external intrruption int0, int1
000074 bf09                      		out eimsk, temp
                                 
000075 e00f                      		ldi temp, 0b00001111 ; set ext interrupt0 and interrupt1 on rising edge
000076 9300 006a                 		sts eicra, temp
                                 
                                 		//setting up timers
000078 e005                      		ldi temp, tccr0_setup_byte
000079 bf03                      		out tccr0, temp ; set timer0 speed
00007a e008                      		ldi temp, assr_setup_byte
00007b bf00                      		out assr, temp ; select async oscilator ( timer0 will be super slow and independent from main clock)
                                 
00007c e005                      		ldi temp, tccr1b_setup_byte ; setting up timer1 speed
00007d bd0e                      		out tccr1b, temp;
00007e ef0f                      		ldi temp, 0xff ; reset timer
00007f e010                      		ldi temp2, 0x00
000080 bd0d                      		out tcnt1h, temp
000081 bd1c                      		out tcnt1l, temp2
                                 
000082 e005                      		ldi temp, tccr2_setup_byte
000083 bd05                      		out tccr2, temp ; set timer2 speed
                                 
000084 e003                      		ldi temp, tccr3b_setup_byte ; setting up timer3 speed
000085 9300 008a                 		sts tccr3b, temp
                                 
000087 e405                      		ldi temp, timsk_setup_byte
000088 bf07                      		out timsk, temp ; enable interupts on timers overflowing
                                 
000089 e004                      		ldi temp, etimsk_setup_byte
00008a 9300 007d                 		sts etimsk, temp
                                 
                                 
00008c e600                      		ldi temp, 0b01100000 ; use external cap in adc, left adjust the result
00008d b907                      		out admux, temp
                                 
00008e ed0f                      		ldi temp, 0b11011111 ; en adc, start conv, , clear int flag, enable interuptions, setup prescaler
00008f b906                      		out adcsra, temp
                                 
                                 	
000090 6860                      		sbr eventsFlags1, ef_load_target_temp ; try to load target temp on start
                                 
000091 9478                      		sei ;  allow interrupts
                                 
                                 
                                 	backgroundProcess:
000092 fd56                      		sbrc eventsFlags0, ef_update_sound_type_n
000093 940e 0350                 			call updateSoundType
000095 fd57                      		sbrc eventsFlags0, ef_update_sound_wave_state_n
000096 940e 03bc                 			call updateWaveState
000098 fd55                      		sbrc eventsFlags0, ef_handle_input_n
000099 940e 03cf                 			call readInput
00009b fd54                      		sbrc eventsFlags0, ef_update_7seg_screen_n
00009c 940e 041e                 			call update7segScreen
00009e fd53                      		sbrc eventsFlags0, ef_read_analog_sensors_n
00009f 940e 051e                 			call readAnalogSensors
0000a1 fd52                      		sbrc eventsFlags0, ef_save_target_temperature_n
0000a2 940e 0272                 			call saveTargetTemperature
0000a4 fd51                      		sbrc eventsFlags0, ef_update_heater_n
0000a5 940e 02ac                 			call updateConditioner
0000a7 fd50                      		sbrc eventsFlags0, ef_update_conditioner_fan_n
0000a8 940e 0311                 			call updateConditionerFan
                                 
0000aa fd67                      		sbrc eventsFlags1, ef_load_target_temp_n
0000ab 940e 0280                 			call loadTargetTemperature
0000ad fd66                      		sbrc eventsFlags1, ef_update_program_timers_n
0000ae 940e 0169                 			call updateProgramTimers 
0000b0 fd65                      		sbrc eventsFlags1, ef_update_flaps_n
0000b1 940e 0329                 			call updateFlaps
0000b3 fd63                      		sbrc eventsFlags1, ef_update_tachometer_n
0000b4 940e 053b                 			call updateTachometer
0000b6 fd64                      		sbrc eventsFlags1, ef_increment_tachometer_n
0000b7 940e 054d                 			call incrementTachometerCounter
0000b9 fd62                      		sbrc eventsFlags1, ef_check_engine_temperature_n
0000ba 940e 028c                 			call checkEngineTemperature
0000bc fd61                      		sbrc eventsFlags1, ef_switch_display_data_n
0000bd 940e 03f7                 			call switchDisplayData
0000bf fd60                      		sbrc eventsFlags1, ef_handle_current_key_n
0000c0 940e 0109                 			call handleCurrentKey
                                 
0000c2 e0b1                      		ldi xh, high(eventsFlags2)
0000c3 e2af                      		ldi xl, low(eventsFlags2) 
0000c4 917c                      		ld tempFlag, x
0000c5 fd77                      		sbrc tempFlag, ef_check_outside_temperature_n
0000c6 940e 029b                 			call checkOutsideTemperature
0000c8 fd76                      		sbrc tempFlag, ef_check_acceleration_n
0000c9 940e 00cd                 			call checkAcceleration
                                 
0000cb 940c 0092                  	jmp backgroundProcess
                                 
                                 	checkAcceleration:
0000cd 7b7f                      		cbr tempFlag, ef_check_acceleration
0000ce 9370 012f                 		sts eventsFlags2, tempFlag
                                 
0000d0 e0b1                      		ldi xh, high(analogValuesTable)
0000d1 e0a0                      		ldi xl, low(analogValuesTable)
0000d2 e00c                      		ldi temp, accelerationFrontSensorZ
0000d3 0fa0                      		add xl, temp
0000d4 911c                      		ld temp2, x
                                 
0000d5 331a                      		cpi temp2, 128 - maxAllowedBackwardAcceleration
0000d6 f0b0                      			brlo frontCollision
                                 		
                                 		checkRearCollision:
0000d7 3e14                      			cpi temp2, 128 + maxAllowedForwardAcceleration
0000d8 f4c0                      				brsh rearCollision
                                 
                                 		
                                 
                                 		checkFrontLeftCollision:
0000d9 e0b1                      		ldi xh, high(analogValuesTable)
0000da e0a0                      		ldi xl, low(analogValuesTable)
0000db e00d                      		ldi temp, accelerationFrontSensorX
0000dc 0fa0                      		add xl, temp
0000dd 912c                      		ld temp3, x
                                 
                                 		
0000de 3a28                      		cpi temp3, 128 + maxAllowedSideAcceleration
0000df f4b0                      			brsh frontLeftCollision
                                 		
                                 		checkFrontRightCollision:
0000e0 3528                      			cpi temp3, 128 - maxAllowedSideAcceleration
0000e1 f0c8                      				brlo frontRightCollision
                                 
                                 		checkBackLeftCollision:
0000e2 e0b1                      		ldi xh, high(analogValuesTable)
0000e3 e0a0                      		ldi xl, low(analogValuesTable)
0000e4 e00e                      		ldi temp, accelerationRearSensorX
0000e5 0fa0                      		add xl, temp
0000e6 913c                      		ld temp4, x
                                 
0000e7 3a38                      		cpi temp4, 128 + maxAllowedSideAcceleration
0000e8 f4b8                      			brsh backLeftCollision
                                 
                                 		checkBackRightCollision:
0000e9 3538                      			cpi temp4, 128 - maxAllowedSideAcceleration
0000ea f0d0                      				brlo backRightCollision
0000eb 940c 0108                 				jmp endCheckCollision
                                 
                                 		frontCollision:
0000ed 940e 013c                 			call enableWarningSignal
0000ef 940c 00d7                 			jmp checkRearCollision
                                 
                                 		rearCollision:
0000f1 9a94                      			sbi portd, frontAirbagsTriggerPinNumber
0000f2 940e 013c                 			call enableWarningSignal
0000f4 940c 00d9                 			jmp checkFrontLeftCollision
                                 
                                 		frontLeftCollision:
0000f6 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
0000f7 940e 013c                 			call enableWarningSignal
0000f9 940c 00e0                 			jmp checkFrontRightCollision
                                 
                                 		frontRightCollision:
0000fb 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
0000fc 940e 013c                 			call enableWarningSignal
0000fe 940c 00e2                 			jmp checkBackLeftCollision
                                 
                                 		backLeftCollision:
000100 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
000101 940e 013c                 			call enableWarningSignal
000103 940c 00e9                 			jmp checkBackRightCollision
                                 
                                 		backRightCollision:
000105 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
000106 940e 013c                 			call enableWarningSignal
                                 
                                 		endCheckCollision:
000108 9508                      	ret
                                 
                                 	handleCurrentKey:
000109 7f6e                      		cbr eventsFlags1, ef_handle_current_key
00010a e0b1                      		ldi xh, high(currentKey)
00010b e2ac                      		ldi xl, low(currentKey)
00010c 910c                      		ld temp, x
00010d 310c                      		cpi temp, 28
00010e f041                      			breq callRizeTemperature
00010f 3104                      		cpi temp, 20
000110 f051                      			breq callLowerTemperature
000111 300c                      		cpi temp, 12
000112 f061                      			breq callHandleCancelKey
000113 3109                      		cpi temp, 25
000114 f071                      			breq callSwitchConditioner
000115 940c 0125                 			jmp handleCurrentKeyEnd
                                 
                                 		callRizeTemperature:
000117 940e 022c                 			call rizeTemperature
000119 940c 0125                 			jmp handleCurrentKeyEnd
                                 
                                 		callLowerTemperature:
00011b 940e 0241                 			call lowerTemperature
00011d 940c 0125                 			jmp handleCurrentKeyEnd
                                 
                                 		callHandleCancelKey:
00011f 940e 0126                 			call handleCancelKey
000121 940c 0125                 			jmp handleCurrentKeyEnd
                                 
                                 		callSwitchConditioner:
000123 940e 0256                 			call switchConditioner
                                 
                                 		handleCurrentKeyEnd:
000125 9508                      	ret
                                 
                                 
                                 	handleCancelKey:
000126 e0f1                      		ldi zh, high(statesFlags0)
000127 e3e0                      		ldi zl, low(statesFlags0)
000128 8180                      		ld tempFlag2, z
000129 fd86                      		sbrc tempFlag2, sf_warning_signal_enabled_n
00012a 940c 012e                 			jmp cancelWarning
00012c 940c 0135                 			jmp endHandleCancelKey
                                 
                                 		cancelWarning:
00012e e000                      			ldi temp, 0
00012f 9300 012c                 			sts currentKey, temp ; current key is handled. so clear it
000131 940e 0147                 			call disableWarningSignal
000133 940e 0160                 			call enableCancelSignal
                                 
                                 		endHandleCancelKey:
                                 
000135 9508                      	ret
                                 
                                 	resetSoundState:
000136 7d8f                      		cbr tempFlag2, sf_click_signal_enabled
000137 7e8f                      		cbr tempFlag2, sf_accept_signal_enabled
000138 7f87                      		cbr tempFlag2, sf_cancel_signal_enabled
000139 7b8f                      		cbr tempFlag2, sf_warning_signal_enabled
00013a 778f                      		cbr tempFlag2, sf_sound_enabled
00013b 9508                      	ret
                                 
                                 	enableWarningSignal:
00013c e0f1                      		ldi zh, high(statesFlags0)
00013d e3e0                      		ldi zl, low(statesFlags0)
00013e 8180                      		ld tempFlag2, z
00013f fd86                      		sbrc tempFlag2, sf_warning_signal_enabled_n
000140 9508                      			ret ; return emmediately if it is already enabled
000141 940e 0136                 		call resetSoundState
000143 6480                      		sbr tempFlag2, sf_warning_signal_enabled
000144 9380 0130                 		sts statesFlags0, tempFlag2
000146 9508                      	ret
                                 
                                 	disableWarningSignal:
000147 e0f1                      		ldi zh, high(statesFlags0)
000148 e3e0                      		ldi zl, low(statesFlags0)
000149 8180                      		ld tempFlag2, z
00014a 7b8f                      		cbr tempFlag2, sf_warning_signal_enabled
00014b 9380 0130                 		sts statesFlags0, tempFlag2
00014d 9508                      	ret
                                 
                                 	enableClickSignal:
00014e e0f1                      		ldi zh, high(statesFlags0)
00014f e3e0                      		ldi zl, low(statesFlags0)
000150 8180                      		ld tempFlag2, z
000151 940e 0136                 		call resetSoundState
000153 6280                      		sbr tempFlag2, sf_click_signal_enabled
000154 9380 0130                 		sts statesFlags0, tempFlag2
000156 9508                      	ret
                                 
                                 	enableAcceptSignal:
000157 e0f1                      		ldi zh, high(statesFlags0)
000158 e3e0                      		ldi zl, low(statesFlags0)
000159 8180                      		ld tempFlag2, z
00015a 940e 0136                 		call resetSoundState
00015c 6180                      		sbr tempFlag2, sf_accept_signal_enabled
00015d 9380 0130                 		sts statesFlags0, tempFlag2
00015f 9508                      	ret
                                 
                                 	enableCancelSignal:
000160 e0f1                      		ldi zh, high(statesFlags0)
000161 e3e0                      		ldi zl, low(statesFlags0)
000162 8180                      		ld tempFlag2, z
000163 940e 0136                 		call resetSoundState
000165 6088                      		sbr tempFlag2, sf_cancel_signal_enabled
000166 9380 0130                 		sts statesFlags0, tempFlag2
000168 9508                      	ret
                                 
                                 	updateProgramTimers:
000169 ef0f                      		ldi temp, 0xff ; preset timer to change overflowing freq
00016a ef10                      		ldi temp2, 0xf0
00016b 9300 0089                 		sts tcnt3h, temp
00016d 9310 0088                 		sts tcnt3l, temp2
                                 
00016f 7b6f                      		cbr eventsFlags1, ef_update_program_timers
                                 
000170 e0f1                      		ldi zh, high(statesFlags0)
000171 e3e0                      		ldi zl, low(statesFlags0)
000172 8180                      		ld tempFlag2, z
000173 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000174 940c 01ac                 			jmp updTachTimer
                                 		
000176 e0b1                      		ldi xh, high(updateConditionerTimer) ; get timer from ram
000177 e1ae                      		ldi xl, low(updateConditionerTimer)
000178 910c                      		ld temp, x
000179 9503                      		inc temp
00017a 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
00017b f011                      			breq setConditionerFlag
00017c 940c 0180                 			jmp saveConditionerTimer
                                 
                                 		setConditionerFlag:
00017e 6052                      			sbr eventsFlags0, ef_update_heater ; create "update_heater" task
                                 
00017f e000                      			ldi temp, 0 ; reset heater update timer
                                 
                                 		saveConditionerTimer:
000180 9300 011e                 			sts updateConditionerTimer, temp ;and save it to ram
                                 
                                 		; CONDITIONER FAN ;
000182 e0b1                      		ldi xh, high(conditionerFanTimer0) ; get temperature from ram
000183 e2a1                      		ldi xl, low(conditionerFanTimer0)
000184 910c                      		ld temp, x
000185 3f0f                      		cpi temp, 255 
000186 f029                      			breq checkCondFanTimer1	
000187 9503                      			inc temp
000188 9300 0121                 			sts conditionerFanTimer0, temp
00018a 940c 01a0                 			jmp endUpdateCondFanTimer
                                 
                                 		checkCondFanTimer1:
00018c ec00                      			ldi temp, 128 + 64
00018d 9300 0121                 			sts conditionerFantimer0, temp
00018f e0b1                      			ldi xh, high(conditionerFanTimer1)
000190 e2a2                      			ldi xl, low(conditionerFanTimer1)
000191 910c                      			ld temp, x
                                 
000192 3f0f                      			cpi temp, 255
000193 f029                      				breq setUpdateCondFanFlag
000194 9503                      				inc temp
000195 9300 0122                 				sts conditionerFanTimer1, temp
000197 940c 01a0                 				jmp endUpdateCondFanTimer
                                 				
                                 				
                                 
                                 		setUpdateCondFanFlag:
000199 6051                      			sbr eventsFlags0, ef_update_conditioner_fan ; start upate fan task
                                 
00019a ec00                      			ldi temp, 128 + 64
00019b 9300 0121                 			sts conditionerFanTimer0, temp ; reset timer
00019d ef09                      			ldi temp, condFanSpeed
00019e 9300 0122                 			sts conditionerFanTimer1, temp
                                 		
                                 		endUpdateCondFanTimer:
                                 
                                 
                                 
                                 		////////////udpate flaps timer ///////////
0001a0 e0b1                      		ldi xh, high(flapsUpdateTimer) ; get flaps timer from ram
0001a1 e1af                      		ldi xl, low(flapsUpdateTimer)
0001a2 910c                      		ld temp, x
0001a3 9503                      		inc temp
0001a4 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001a5 f011                      			breq setUpdateFlapsFlag
0001a6 940c 01aa                 			jmp saveUpdateFlapsTimer
                                 
                                 		setUpdateFlapsFlag:
0001a8 6260                      			sbr eventsFlags1, ef_update_flaps ; create "update_flaps" task
                                 
0001a9 e000                      			ldi temp, 0 ; reset flaps update timer
                                 
                                 		saveUpdateFlapsTimer:
0001aa 9300 011f                 			sts flapsUpdateTimer, temp ;and save it to ram
                                 
                                 
                                 		
                                 		updTachTimer:
0001ac e0b1                      		ldi xh, high(tachometerTimerL)
0001ad e2a7                      		ldi xl, low(tachometerTimerL)
0001ae 910c                      		ld temp, x
0001af 9503                      		inc temp
0001b0 3f0f                      		cpi temp, 255 
0001b1 f011                      			breq incrementTachTimerH
0001b2 940c 01bf                 			jmp saveTachTimerL
                                 
                                 		incrementTachTimerH:
0001b4 e000                      			ldi temp, 0
0001b5 9300 0127                 			sts tachometerTimerL, temp
                                 
0001b7 e0b1                      			ldi xh, high(tachometerTimerH)
0001b8 e2a6                      			ldi xl, low(tachometerTimerH)
0001b9 910c                      			ld temp, x
0001ba 9503                      			inc temp
0001bb 3f0f                      			cpi temp, 255
0001bc f051                      				breq resetTachTimer
0001bd 940c 01c3                 				jmp saveTachTimerH
                                 
                                 		saveTachTimerL:
0001bf 9300 0127                 			sts tachometerTimerL, temp
0001c1 940c 01ce                 			jmp endTachTimerUpdate
                                 
                                 		saveTachTimerH:
0001c3 9300 0126                 			sts tachometerTimerH, temp
0001c5 940c 01ce                 			jmp endTachTimerUpdate
                                 
                                 		resetTachTimer:
0001c7 ef0c                      			ldi temp, 128 + 64 + 32 + 16 + 8 + 4
0001c8 9300 0126                 			sts tachometerTimerH, temp
0001ca e000                      			ldi temp, 0
0001cb 9300 0127                 			sts tachometerTimerL, temp
                                 			
0001cd 6068                      			sbr eventsFlags1, ef_update_tachometer
                                 		
                                 		endTachTimerUpdate:
                                 
                                 
                                 		//////////// switch displayed data timer ///////////////////
0001ce e0b1                      		ldi xh, high(switchDisplayDataTimerL) ; get timer from ram
0001cf e1ac                      		ldi xl, low(switchDisplayDataTimerL)
0001d0 910c                      		ld temp, x
0001d1 9503                      		inc temp
0001d2 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001d3 f021                      			breq incSwitchDisplayDataTimerH
0001d4 9300 011c                 			sts switchDisplayDataTimerL, temp
0001d6 940c 01e7                 			jmp endDisplayDataTimerUpdate
                                 
                                 		incSwitchDisplayDataTimerH:
0001d8 e000                      			ldi temp, 0
0001d9 9300 011c                 			sts switchDisplayDataTimerL, temp
                                 
0001db e0b1                      			ldi xh, high(switchDisplayDataTimerH)
0001dc e1ab                      			ldi xl, low(switchDisplayDataTimerH)
0001dd 910c                      			ld temp, x
0001de 9503                      			inc temp
0001df 3f0f                      			cpi temp, 255
0001e0 f011                      				breq setSwitchDisplayDataFlag
0001e1 940c 01e5                 				jmp saveSwitchDisplayDataTimerH
                                 
                                 			setSwitchDisplayDataFlag:
0001e3 6062                      				sbr eventsFlags1, ef_switch_display_data
                                 
                                 				resetDisplayDataTimerH:
0001e4 ee00                      				ldi temp, displayDataSwitchingFreq ; reset  timer
                                 
                                 			saveSwitchDisplayDataTimerH:
0001e5 9300 011b                 				sts switchDisplayDataTimerH, temp ;and save it to ram
                                 		
                                 		endDisplayDataTimerUpdate:
                                 
                                 
                                 		
                                 		////////////udpate check engine temperature timer ///////////
0001e7 e0b1                      		ldi xh, high(checkEngineTemperatureTimer) ; get flaps timer from ram
0001e8 e2aa                      		ldi xl, low(checkEngineTemperatureTimer)
0001e9 910c                      		ld temp, x
0001ea 9503                      		inc temp
0001eb 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001ec f011                      			breq setCheckEngineTemperatureFlag
0001ed 940c 01f1                 			jmp saveCheckEngineTemperatureTimer
                                 
                                 		setCheckEngineTemperatureFlag:
0001ef 6064                      			sbr eventsFlags1, ef_check_engine_temperature ; create "update_flaps" task
                                 
0001f0 e000                      			ldi temp, 0 ; reset flaps update timer
                                 
                                 		saveCheckEngineTemperatureTimer:
0001f1 9300 012a                 			sts checkEngineTemperatureTimer, temp ;and save it to ram
                                 
                                 		endCheckEngineTemperatureTimerUpdate:
                                 
                                 		//////// handle the last pressed key timer //////////
0001f3 e0b1                      		ldi xh, high(handleCurrentKeyTimer)
0001f4 e2ad                      		ldi xl, low(handleCurrentKeyTimer)
0001f5 910c                      		ld temp, x
0001f6 9503                      		inc temp
0001f7 3f0e                      		cpi temp, 254
0001f8 f410                      			brsh setHandleCurrentKeyFlag
0001f9 940c 01fd                 			jmp saveHandleCurrentKeyTimer
                                 
                                 		setHandleCurrentKeyFlag:
0001fb 6061                      			sbr eventsFlags1, ef_handle_current_key
0001fc e000                      			ldi temp, 0
                                 
                                 		saveHandleCurrentKeyTimer:
0001fd 9300 012d                 			sts handleCurrentKeyTimer, temp
                                 
                                 		endHandleCrrentKeyTimerUpdate:
                                 
                                 
                                 		////////// outside temp checking timer//////////
0001ff e0b1                      		ldi xh, high(eventsFlags2)
000200 e2af                      		ldi xl, low(eventsFlags2)
000201 917c                      		ld tempFlag, x
000202 e0b1                      		ldi xh, high(checkOutsideTemperatureTimerL) ; get timer from ram
000203 e2a5                      		ldi xl, low(checkOutsideTemperatureTimerL)
000204 910c                      		ld temp, x
000205 9503                      		inc temp
000206 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
000207 f021                      			breq incCheckOutsideTemperatureTimerH
000208 9300 0125                 			sts checkOutsideTemperatureTimerL, temp
00020a 940c 021d                 			jmp endCheckOutsideTemperatreTimerUpdate
                                 
                                 		incCheckOutsideTemperatureTimerH:
00020c e000                      			ldi temp, 0
00020d 9300 0125                 			sts checkOutsideTemperatureTimerL, temp
                                 
00020f e0b1                      			ldi xh, high(CheckOutsideTemperatureTimerH)
000210 e2a4                      			ldi xl, low(CheckOutsideTemperatureTimerH)
000211 910c                      			ld temp, x
000212 9503                      			inc temp
000213 3f0f                      			cpi temp, 255
000214 f011                      				breq setCheckOutsideTemperatreFlag
000215 940c 021b                 				jmp saveCheckOutsideTemperatreTimerH
                                 
                                 			setCheckOutsideTemperatreFlag:
000217 6870                      				sbr tempFlag, ef_check_outside_temperature
000218 9370 012f                 				sts eventsFlags2, tempFlag
                                 
                                 				resetCheckOutsideTemperatreTimerH:
00021a ef00                      				ldi temp, checkOutsideTemperatureFreq ; reset  timer
                                 
                                 			saveCheckOutsideTemperatreTimerH:
00021b 9300 0124                 				sts CheckOutsideTemperatureTimerH, temp ;and save it to ram
                                 		
                                 		endCheckOutsideTemperatreTimerUpdate:
                                 
                                 
                                 		//////// check accelerations timer //////////
00021d e0b1                      		ldi xh, high(checkAccelerationTimer)
00021e e2ae                      		ldi xl, low(checkAccelerationTimer)
00021f 910c                      		ld temp, x
000220 9503                      		inc temp
000221 3f0e                      		cpi temp, 254
000222 f410                      			brsh setCheckAccelerationFlag
000223 940c 0229                 			jmp saveCheckAccelerationTimer
                                 
                                 		setCheckAccelerationFlag:
000225 6470                      			sbr tempFlag, ef_check_acceleration
000226 9370 012f                 			sts eventsFlags2, tempFlag
000228 e000                      			ldi temp, 0
                                 
                                 		saveCheckAccelerationTimer:
000229 9300 012e                 			sts checkAccelerationTimer, temp
                                 
                                 		endCheckAccelerationUpdate:
                                 
                                 
00022b 9508                      	ret
                                 
                                 
                                 	rizeTemperature:
00022c e0f1                      		ldi zh, high(statesFlags0)
00022d e3e0                      		ldi zl, low(statesFlags0)
00022e 8180                      		ld tempFlag2, z
00022f ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000230 9508                      			ret
                                 		
000231 940e 014e                 		call enableClickSignal ; make click sound
000233 e000                      		ldi temp, 0
000234 9300 012c                 		sts currentKey, temp
000236 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000237 e1ad                      		ldi xl, low(targetTemperature)
000238 910c                      		ld temp, x
000239 9503                      		inc temp ; increment temperature
                                 		
00023a 310f                      		cpi temp, 31 ; limit temperature to 30 grad
00023b f008                      			brlo saveTemperatureToRam
00023c e10e                      			ldi temp, 30
                                 
                                 		saveTemperatureToRam:
00023d 9300 011d                 			sts targetTemperature, temp ;and save it to ram
                                 
00023f 6054                      		sbr eventsFlags0, ef_save_target_temperature
000240 9508                      	ret
                                 
                                 	lowerTemperature:
000241 e0f1                      		ldi zh, high(statesFlags0)
000242 e3e0                      		ldi zl, low(statesFlags0)
000243 8180                      		ld tempFlag2, z
000244 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000245 9508                      			ret
                                 		
000246 940e 014e                 		call enableClickSignal ; make click sound
                                 
000248 e000                      		ldi temp, 0
000249 9300 012c                 		sts currentKey, temp
00024b e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
00024c e1ad                      		ldi xl, low(targetTemperature)
00024d 910c                      		ld temp, x
00024e 950a                      		dec temp ; decrement temperature
                                 
00024f 300a                      		cpi temp, 10 ; limit temperature to 30 grad
000250 f764                      			brge saveTemperatureToRam
000251 e00a                      			ldi temp, 10
                                 
000252 9300 011d                 		sts targetTemperature, temp ;and save it to ram
                                 
000254 6054                      		sbr eventsFlags0, ef_save_target_temperature
000255 9508                      	ret
                                 
                                 	switchConditioner:
000256 e000                      		ldi temp, 0
000257 9300 012c                 		sts currentKey, temp
000259 e0f1                      		ldi zh, high(statesFlags0)
00025a e3e0                      		ldi zl, low(statesFlags0)
00025b 8180                      		ld tempFlag2, z
00025c ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n
00025d 940c 0261                 			jmp cond_en
00025f 940c 0268                 			jmp cond_dis
                                 
                                 		cond_en:
000261 6084                      			sbr tempFlag2, sf_conditioner_enabled
000262 9380 0130                 			sts statesFlags0, tempFlag2
000264 940e 0157                 			call enableAcceptSignal
000266 940c 0271                 			jmp endSwitchConditioner
                                 		cond_dis:
000268 7f8b                      			cbr tempFlag2, sf_conditioner_enabled
000269 9380 0130                 			sts statesFlags0, tempFlag2
00026b 940e 0160                 			call enableCancelSignal
00026d 9818                      			cbi porte, heater_pin_number
00026e 9819                      			cbi porte, cooler_pin_number
00026f 940c 0271                 			jmp endSwitchConditioner
                                 		endSwitchConditioner:
000271 9508                      	ret
                                 
                                 
                                 
                                 	saveTargetTemperature:
000272 99e1                      		sbic eecr, eewe ; wait for completion of previous write
000273 940c 027f                 			jmp endWritingAttempt
000275 e000                      		ldi temp, targetTempSavingAddr ; setup address where to wirte
000276 bb0f                      		out eearh, temp
000277 bb0e                      		out eearl, temp
                                 		
000278 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000279 e1ad                      		ldi xl, low(targetTemperature)
00027a 910c                      		ld temp, x
                                 
00027b bb0d                      		out eedr, temp ; store data to data register
00027c 9ae2                      		sbi eecr, eemwe ; write logical one to eemwe
00027d 9ae1                      		sbi eecr, eewe ; start eeprom write by setting eewe
                                 
00027e 7f5b                      		cbr eventsFlags0, ef_save_target_temperature ; end writing task
                                 
                                 		endWritingAttempt:
                                 
00027f 9508                      	ret
                                 
                                 	loadTargetTemperature:
000280 99e1                      		sbic eecr, eewe ; wait for completion of previous write
000281 940c 028b                 			jmp endReadAttempt
000283 e000                      		ldi temp, targetTempSavingAddr
000284 bb0f                      		out eearh, temp
000285 bb0e                      		out eearl, temp
000286 9ae0                      		sbi  eecr, eere ; start eeprom read by writing eere
000287 b30d                      		in temp, eedr ; read data from data register
000288 9300 011d                 		sts targetTemperature, temp
                                 
00028a 776f                      		cbr eventsFlags1, ef_load_target_temp ; end loading task if it success
                                 		
                                 		endReadAttempt:
00028b 9508                      	ret
                                 
                                 	checkEngineTemperature:
00028c 7f6b                      		cbr eventsFlags1, ef_check_engine_temperature
00028d e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
00028e e0a0                      		ldi xl, low(analogValuesTable)
00028f e032                      		ldi temp4, engineThermalSensorNum
000290 0fa3                      		add xl, temp4
000291 910c                      		ld temp, x
                                 
000292 3f08                      		cpi temp, 128 + 120 ; if engine temperature is more than 120C
000293 f420                      			brsh enableEngineTempWarning
000294 3300                      		cpi temp, 128 - 80 ; if enginge temperature is strangely low then warning too
000295 f010                      			brlo enableEngineTempWarning
000296 940c 029a                 			jmp endEngineTemperatureCheck
                                 			
                                 		enableEngineTempWarning:
000298 940e 013c                 			call enableWarningSignal
                                 
                                 		endEngineTemperatureCheck:
00029a 9508                      	ret
                                 
                                 	checkOutsideTemperature:
00029b 777f                      		cbr tempFlag, ef_check_outside_temperature
00029c 9370 012f                 		sts eventsFlags2, tempFlag
                                 
00029e e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
00029f e0a0                      		ldi xl, low(analogValuesTable)
0002a0 e031                      		ldi temp4, outsideThermalSensorNum
0002a1 0fa3                      		add xl, temp4
0002a2 910c                      		ld temp, x
                                 
0002a3 3c06                      		cpi temp, 128 + 70 ; if  temperature is more then 70C than warning
0002a4 f420                      			brsh enableOutsideTempWarning
0002a5 3300                      		cpi temp, 128 - 80 ; if temperature lower then -80 than warning
0002a6 f010                      			brlo enableOutsideTempWarning
0002a7 940c 02ab                 			jmp endOutsideTemperatureCheck
                                 			
                                 		enableOutsideTempWarning:
0002a9 940e 013c                 			call enableWarningSignal
                                 
                                 		endOutsideTemperatureCheck:
0002ab 9508                      	ret
                                 
                                 	updateConditioner:
0002ac e0f1                      		ldi zh, high(statesFlags0)
0002ad e3e0                      		ldi zl, low(statesFlags0)
0002ae 8180                      		ld tempFlag2, z
0002af ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
0002b0 9508                      			ret
0002b1 7f5d                      		cbr eventsFlags0, ef_update_heater
                                 
0002b2 e0b1                      		ldi xh, high(targetTemperature) ; get target temperature from ram
0002b3 e1ad                      		ldi xl, low(targetTemperature)
0002b4 910c                      		ld temp, x
                                 
0002b5 310f                      		cpi temp, 31
0002b6 f480                      			brsh condTemperatureWarning
0002b7 300a                      		cpi temp, 10
0002b8 f070                      			brlo condTemperatureWarning
                                 
0002b9 e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
0002ba e0a0                      		ldi xl, low(analogValuesTable)
0002bb 911c                      		ld temp2, x
                                 
                                 		
                                 
0002bc e0b1                      		ldi xh, high(analogValuesTable) ; get outside temperature from ram
0002bd e0a0                      		ldi xl, low(analogValuesTable)
0002be e031                      		ldi temp4, outsideThermalSensorNum
0002bf 0fa3                      		add xl, temp4
0002c0 913c                      		ld temp4, x
                                 
0002c1 3c16                      		cpi temp2, 128 + 70 ; + 70C
0002c2 f420                      			brsh condTemperatureWarning
0002c3 3310                      		cpi temp2, 128 - 80
0002c4 f010                      			brlo condTemperatureWarning ; -80C
0002c5 940c 02c9                 		jmp updateHeater
                                 
                                 		condTemperatureWarning:
0002c7 940e 013c                 			call enableWarningSignal
                                 
                                 		updateHeater:
0002c9 3810                      		cpi temp2, 128 ; if temperature is minus then enable heater emmediately 
0002ca f048                      			brlo enableHeater
0002cb 5810                      			subi temp2, 128
                                 		
0002cc 1710                      		cp temp2, temp
0002cd f030                      			brlo enableHeater
0002ce 940c 02d0                 			jmp disableHeater
                                 
                                 		disableHeater: ; ye ye ye useless, but just for code readability
0002d0 9818                      			cbi porte, heater_pin_number
0002d1 9a19                      			sbi porte, cooler_pin_number
0002d2 940c 02d6                 			jmp endUpdateConditioner
                                 
                                 		enableHeater:
0002d4 9a18                      			sbi porte, heater_pin_number
0002d5 9819                      			cbi porte, cooler_pin_number
                                 
                                 		; TODO add hummidity sensor and regulate it
                                 
                                 		endUpdateConditioner: 
0002d6 940e 02db                 		call resolveEngineFlap
0002d8 940e 02f6                 		call resolveOutsideFlap
0002da 9508                      	ret
                                 
                                 	resolveEngineFlap:
0002db e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
0002dc e0a0                      		ldi xl, low(analogValuesTable)
0002dd 910c                      		ld temp, x
                                 
0002de e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
0002df e0a0                      		ldi xl, low(analogValuesTable)
0002e0 e032                      		ldi temp4, engineThermalSensorNum
0002e1 0fa3                      		add xl, temp4
0002e2 911c                      		ld temp2, x	
                                 
0002e3 1701                      		cp temp, temp2
0002e4 f038                      			brlo checkIfNeedWarmup
0002e5 940c 02e7                 			jmp checkIfNeedCooldown
                                 
                                 		checkIfNeedCooldown:
0002e7 9919                      			sbic porte, cooler_pin_number
0002e8 940c 02f1                 				jmp openEngineFlap
0002ea 940c 02f4                 				jmp closeEngineFlap
                                 
                                 		checkIfNeedWarmup:
0002ec 9918                      			sbic porte, heater_pin_number
0002ed 940c 02f1                 				jmp openEngineFlap
0002ef 940c 02f4                 				jmp closeEngineFlap
                                 
                                 		openEngineFlap:
0002f1 9a97                      			sbi portd, engine_flap_pin_num
0002f2 940c 02f5                 			jmp endResolveEngineFlap
                                 
                                 		closeEngineFlap:
0002f4 9897                      			cbi portd, engine_flap_pin_num
                                 
                                 		endResolveEngineFlap:
0002f5 9508                      	ret
                                 
                                 	resolveOutsideFlap:
0002f6 e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
0002f7 e0a0                      		ldi xl, low(analogValuesTable)
0002f8 910c                      		ld temp, x
                                 
0002f9 e0b1                      		ldi xh, high(analogValuesTable) ; get outside temperature from ram
0002fa e0a0                      		ldi xl, low(analogValuesTable)
0002fb e031                      		ldi temp4, outsideThermalSensorNum
0002fc 0fa3                      		add xl, temp4
0002fd 911c                      		ld temp2, x	
                                 
0002fe 1701                      		cp temp, temp2
0002ff f038                      			brlo checkIfNeedWarmupFromOutside
000300 940c 0302                 			jmp checkIfNeedCooldownFromOutside
                                 
                                 		checkIfNeedCooldownFromOutside:
000302 9919                      			sbic porte, cooler_pin_number
000303 940c 030c                 				jmp openOutsideFlap
000305 940c 030f                 				jmp closeOutsideFlap
                                 
                                 		checkIfNeedWarmupFromOutside:
000307 9918                      			sbic porte, heater_pin_number
000308 940c 030c                 				jmp openOutsideFlap
00030a 940c 030f                 				jmp closeOutsideFlap
                                 
                                 		openOutsideFlap:
00030c 9a96                      			sbi portd, outside_flap_pin_num
00030d 940c 0310                 			jmp endResolveOutsideFlap
                                 
                                 		closeOutsideFlap:
00030f 9896                      			cbi portd, outside_flap_pin_num
                                 
                                 		endResolveOutsideFlap:
                                 
000310 9508                      	ret
                                 
                                 	updateConditionerFan:
000311 e0f1                      		ldi zh, high(statesFlags0)
000312 e3e0                      		ldi zl, low(statesFlags0)
000313 8180                      		ld tempFlag2, z
000314 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000315 9508                      			ret
000316 7f5e                      		cbr eventsFlags0, ef_update_conditioner_fan
                                 
000317 e0b1                      		ldi xh, high(conditionerFanState) ; get fan state from ram
000318 e2a3                      		ldi xl, low(conditionerFanState)
000319 910c                      		ld temp, x
00031a 3000                      		cpi temp, 0
00031b f029                      			breq resetCondFanState
                                 
00031c 9506                      		lsr temp
00031d 3008                      		cpi temp, 0b00001000 ; if we are trying to lightup pin not connected to fan then reset it 
00031e f011                      			breq resetCondFanState
00031f 940c 0322                 			jmp saveCondFanState
                                 		resetCondFanState:
000321 e800                      			ldi temp, 0b10000000
                                 		saveCondFanState:
000322 9300 0123                 			sts conditionerFanState, temp ;and save it to ram	
000324 b113                      			in temp2, porte ; get current state of prote (to not broke other stuff connected to this port)
000325 701f                      			andi temp2, 0b00001111
000326 2b10                      			or temp2, temp ; out new fan state to porte
000327 b913                      			out porte, temp2
000328 9508                      	ret
                                 
                                 	updateFlaps:
000329 e0f1                      		ldi zh, high(statesFlags0)
00032a e3e0                      		ldi zl, low(statesFlags0)
00032b 8180                      		ld tempFlag2, z
00032c ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
00032d 9508                      			ret
00032e 7d6f                      		cbr eventsFlags1, ef_update_flaps
                                 
00032f e0f1                      		ldi zh, high(currentControlledFlap) ; get the number of a flap we wanna update now
000330 e2e0                      		ldi zl, low(currentControlledFlap)
000331 8100                      		ld temp, z
                                 
000332 e0b1                      		ldi xh, high(analogValuesTable) ; get current state of needed flap control from ram
000333 e0a0                      		ldi xl, low(analogValuesTable)
000334 e028                      		ldi temp3, 8 ; flaps controlls data begins from 8th byte
000335 0fa2                      		add xl, temp3 
000336 0fa0                      		add xl, temp ; ofset to current flap control byte
                                 	
000337 911c                      		ld temp2, x
                                 
000338 7c10                      		andi temp2, 0b11000000 ; leave only two most significant byts (every falp will have only 4 possible states)
000339 9512                      		swap temp2
                                 
00033a b121                      		in temp3, pine ; get the contents from porte
00033b 7f23                      		andi temp3, 0b11110011 ; clear two pins controlling the flaps to rewrite them in next two commands
00033c 2b21                      		or temp3, temp2 ; and combine it with the date we wanno output
00033d b923                      		out porte, temp3 ; then... output
                                 
00033e b120                      		in temp3, pinf ; the same trick with two pins of portf (selecting one of our 4 flaps)
00033f 732f                      		andi temp3, 0b00111111 
000340 2f10                      		mov temp2, temp
000341 9512                      		swap temp2
000342 0f11                      		lsl temp2
000343 0f11                      		lsl temp2
000344 2b21                      		or temp3, temp2
000345 9320 0062                 		sts portf, temp3
                                 
000347 9503                      		inc temp
                                 		
000348 3004                      		cpi temp, 4 ; if next selected falp as "non existing" 5th flap then fump to first one 
000349 f410                      			brsh jumpToFirstFlap
00034a 940c 034d                 			jmp saveNextFlapNum
                                 		
                                 		jumpToFirstFlap:
00034c e000                      			ldi temp, 0
                                 
                                 		saveNextFlapNum:
00034d 9300 0120                 			sts currentControlledFlap, temp
00034f 9508                      	ret
                                 
                                 
                                 	updateSoundType:
000350 7b5f                      		cbr eventsFlags0, ef_update_sound_type
                                 
000351 ef00                      		ldi temp, soundSignalsDelay ; reset timer immediately
000352 bf02                      		out tcnt0, temp
                                 		
000353 e0f1                      		ldi zh, high(statesFlags0)
000354 e3e0                      		ldi zl, low(statesFlags0)
000355 8180                      		ld tempFlag2, z
000356 fd86                      		sbrc tempFlag2, sf_warning_signal_enabled_n
000357 940c 0363                 			jmp updateWarningSignal ; if warning signal is enabled then update it
000359 fd85                      		sbrc tempFlag2, sf_click_signal_enabled_n
00035a 940c 0373                 			jmp updateClickSignal
00035c fd84                      		sbrc tempFlag2, sf_accept_signal_enabled_n
00035d 940c 0384                 			jmp updateAcceptSignal
00035f fd83                      		sbrc tempFlag2, sf_cancel_signal_enabled_n
000360 940c 03a0                 			jmp updateCancelSignal
000362 9508                      		ret	
                                 
                                 		updateWarningSignal:	
000363 ff87                      			sbrs tempFlag2, sf_sound_enabled_n
000364 940c 0368                 				jmp warningSound_case_0
000366 940c 036f                 				jmp warningSound_case_1
                                 				warningSound_case_0:
000368 ef0c                      					ldi temp, tone0
000369 9300 012b                 					sts currentTone, temp ; set sound tone
00036b 6880                      					sbr tempFlag2, sf_sound_enabled ; enable sound
00036c 9380 0130                 					sts statesFlags0, tempFlag2
00036e 9508                      				ret
                                 
                                 				warningSound_case_1:
00036f 778f                      					cbr tempFlag2, sf_sound_enabled ; disable sound
000370 9380 0130                 					sts statesFlags0, tempFlag2
000372 9508                      				ret
                                 
                                 		updateClickSignal:
000373 ff87                      			sbrs tempFlag2, sf_sound_enabled_n
000374 940c 0378                 				jmp clickSound_case_0 ; if we haven't clicked yet than click
000376 940c 037f                 				jmp clickSound_case_1 ; otherwise end lcick signal
                                 
                                 				clickSound_case_0:
000378 ef0c                      					ldi temp, tone0
000379 9300 012b                 					sts currentTone, temp ; set low sound tone  
00037b 6880                      					sbr tempFlag2, sf_sound_enabled ; enable sound
00037c 9380 0130                 					sts statesFlags0, tempFlag2
00037e 9508                      				ret
                                 
                                 				clickSound_case_1:
00037f 7d8f                      					cbr tempFlag2, sf_click_signal_enabled ; end click sound
000380 778f                      					cbr tempFlag2, sf_sound_enabled ; disable sound
000381 9380 0130                 					sts statesFlags0, tempFlag2
000383 9508                      				ret
                                 
                                 		updateAcceptSignal:
000384 ff87                      			sbrs tempFlag2, sf_sound_enabled_n
000385 940c 0389                 				jmp acceptSound_case0 ; if sound is not enabled yet than enable it and set tone low
000387 940c 0390                 				jmp acceptSound_case1 ; otherwise if tone low then make it high. if tone high than end accept signal
                                 
                                 				acceptSound_case0:	
000389 ef0c                      					ldi temp, tone0		
00038a 9300 012b                 					sts currentTone, temp ; set low sound tone  
00038c 6880                      					sbr tempFlag2, sf_sound_enabled ; enable sound
00038d 9380 0130                 					sts statesFlags0, tempFlag2
00038f 9508                      				ret
                                 
                                 				acceptSound_case1:
000390 e0b1                      					ldi xh, high(currentTone)
000391 e2ab                      					ldi xl, low(currentTone)
000392 910c                      					ld temp, x
                                 
000393 3f0c                      					cpi temp, tone0
000394 f011                      						breq acceptSound_case2 ; if tone is low make it high
000395 940c 039b                 						jmp acceptSound_case3 ; otherwise end signal
                                 						acceptSound_case2:
000397 ef0e                      							ldi temp, tone1
000398 9300 012b                 							sts currentTone, temp ; set high sound tone  
00039a 9508                      						ret
                                 						acceptSound_case3:
00039b 778f                      							cbr tempFlag2, sf_sound_enabled	; disable sound
00039c 7e8f                      							cbr tempFlag2, sf_accept_signal_enabled ; end accept signal
00039d 9380 0130                 							sts statesFlags0, tempFlag2
00039f 9508                      						ret
                                 
                                 		updateCancelSignal:
0003a0 ff87                      			sbrs tempFlag2, sf_sound_enabled_n
0003a1 940c 03a5                 				jmp cancelSound_case0 ; if sound is not enabled yet than enable it and set tone low
0003a3 940c 03ac                 				jmp cancelSound_case1 ; otherwise if tone low then make it high. if tone high than end accept signal
                                 
                                 				cancelSound_case0:
0003a5 ef0e                      					ldi temp, tone1			
0003a6 9300 012b                 					sts currentTone, temp ; set high sound tone  
0003a8 6880                      					sbr tempFlag2, sf_sound_enabled ; enable sound
0003a9 9380 0130                 					sts statesFlags0, tempFlag2
0003ab 9508                      				ret
                                 
                                 				cancelSound_case1:
0003ac e0b1                      					ldi xh, high(currentTone)
0003ad e2ab                      					ldi xl, low(currentTone)
0003ae 910c                      					ld temp, x
                                 
0003af 3f0e                      					cpi temp, tone1
0003b0 f011                      						breq cancelSound_case2 ; if tone high make it low
0003b1 940c 03b7                 						jmp cancelSound_case3 ; otherwise end signal
                                 						cancelSound_case2:
0003b3 ef0c                      							ldi temp, tone0
0003b4 9300 012b                 							sts currentTone, temp ; set sound tone  
0003b6 9508                      						ret
                                 						cancelSound_case3:
0003b7 778f                      							cbr tempFlag2, sf_sound_enabled	; disable sound
0003b8 7f87                      							cbr tempFlag2, sf_cancel_signal_enabled ; end accept signal
0003b9 9380 0130                 							sts statesFlags0, tempFlag2
0003bb 9508                      						ret
                                 
                                 
                                 
                                 	updateWaveState:
0003bc 775f                      		cbr eventsFlags0, ef_update_sound_wave_state
                                 
0003bd e0b1                      		ldi xh, high(currentTone)
0003be e2ab                      		ldi xl, low(currentTone)
0003bf 910c                      		ld temp, x
                                 
0003c0 bd04                      		out tcnt2, temp ; reset timer2 immediately to prevent bad sound
                                 
0003c1 e0f1                      		ldi zh, high(statesFlags0)
0003c2 e3e0                      		ldi zl, low(statesFlags0)
0003c3 8180                      		ld tempFlag2, z
0003c4 ff87                      		sbrs tempFlag2, sf_sound_enabled_n ; if we should not prodice some sound
0003c5 9518                      			reti ; do nothing
0003c6 9b95                      			sbis portd, speaker_pin_number ; if this pin is low
0003c7 940c 03cb                 				jmp speakerWaveUp ; then make it high
0003c9 940c 03cd                 				jmp speakerWaveDown ; otherwise make it low
                                 
                                 			speakerWaveUp:
0003cb 9a95                      				sbi portd, speaker_pin_number ; make it high
0003cc 9518                      				reti
                                 			speakerWaveDown:
0003cd 9895                      				cbi portd, speaker_pin_number ; make it low
0003ce 9518                      				reti
                                 				; result sound wave 				____	  ____	    ____	  ____
                                 				; will be something like that:	___|	|____|	  |____|    |____|    |____
                                 
                                 
                                 	readInput:
0003cf b709                      		in temp, eimsk ; disable external intrruption int0
0003d0 7f0e                      		andi temp, 0b11111110
0003d1 bf09                      		out eimsk, temp
                                 
0003d2 7d5f                      		cbr eventsFlags0, ef_handle_input
                                 		
0003d3 e000                      		ldi temp, 0b00000000 ; check first row
0003d4 bb0b                      		out porta, temp
0003d5 b309                      		in temp, pina ; get pressed button
                                 		
0003d6 940e 03e7                 		call checkInput
                                 
0003d8 e008                      		ldi temp, 0b00001000 ; check 2nd row
0003d9 bb0b                      		out porta, temp
0003da b309                      		in temp, pina 
                                 
0003db 940e 03e7                 		call checkInput
                                 
0003dd e100                      		ldi temp, 0b00010000 ; check third row
0003de bb0b                      		out porta, temp
0003df b309                      		in temp, pina 
                                 
0003e0 940e 03e7                 		call checkInput
                                 
0003e2 e108                      		ldi temp, 0b00011000 ; check the last row
0003e3 bb0b                      		out porta, temp
0003e4 b309                      		in temp, pina ; 
                                 
0003e5 940c 03ee                 		jmp endReadingInput
                                 
                                 		checkInput:
0003e7 2f10                      			mov temp2, temp
0003e8 7017                      			andi temp2, 0b00000111 ; check only three bits indicating pressed button
0003e9 3010                      			cpi temp2, 0
0003ea f409                      			brne clearReturnAddr	
0003eb 9508                      		ret
                                 
                                 		clearReturnAddr:
0003ec 911f                      			pop temp2 ; removing returning addr from stack
0003ed 911f                      			pop temp2
                                 		endReadingInput:
0003ee 9300 012c                 			sts currentKey, temp ; finally save pressed key
0003f0 e800                      			ldi temp, 0b10000000 ; enable continuous keyboard checking
0003f1 bb0b                      			out porta, temp 
                                 			
0003f2 b709                      			in temp, eimsk
0003f3 e011                      			ldi temp2, 0b00000001
0003f4 2b01                      			or temp, temp2 ; enable external intrruption int0
0003f5 bf09                      			out eimsk, temp
0003f6 9508                      	ret
                                 
                                 	switchDisplayData:
0003f7 7f6d                      		cbr eventsFlags1, ef_switch_display_data
                                 
0003f8 e0f1                      		ldi zh, high(statesFlags0)
0003f9 e3e0                      		ldi zl, low(statesFlags0)
0003fa 8180                      		ld tempFlag2, z
0003fb fd86                      		sbrc tempFlag2, sf_warning_signal_enabled_n
0003fc 940c 0403                 			jmp checkDisplayErrorMessage
0003fe 7f8e                      			cbr tempFlag2, sf_display_error_message
0003ff 9380 0130                 			sts statesFlags0, tempFlag2
000401 940c 040d                 			jmp normalDataSwitch
                                 
                                 		checkDisplayErrorMessage:
000403 ff80                      			sbrs tempFlag2, sf_display_error_message_n
000404 940c 0408                 				jmp switchThroughError
000406 940c 040d                 				jmp normalDataSwitch			
                                 
                                 		switchThroughError:
000408 6081                      			sbr tempFlag2, sf_display_error_message
000409 9380 0130                 			sts statesFlags0, tempFlag2
00040b 940c 041d                 			jmp endSwitchingDisplayData
                                 
                                 		normalDataSwitch:
00040d 7f8e                      			cbr tempFlag2, sf_display_error_message
00040e 9380 0130                 			sts statesFlags0, tempFlag2
000410 e0b1                      		ldi xh, high(currentDisplayData) ; get "number" of type of data we wanna to be displayed
000411 e1aa                      				ldi xl, low(currentDisplayData)
000412 910c                      				ld temp, x
                                 
000413 3001                      				cpi temp, 1
000414 f428                      					brsh goToFirstData
                                 					;else next data
000415 9503                      					inc temp
000416 9300 011a                 					sts currentDisplayData, temp
000418 940c 041d                 					jmp endSwitchingDisplayData
                                 
                                 					goToFirstData:
00041a e000                      						ldi temp, 0
00041b 9300 011a                 						sts currentDisplayData, temp
                                 		
                                 		endSwitchingDisplayData:
                                 
00041d 9508                      	ret
                                 
                                 	update7segScreen:
00041e 7e5f                      		cbr eventsFlags0, ef_update_7seg_screen
                                 
00041f ef0f                      		ldi temp, 0xff 
000420 ef10                      		ldi temp2, 0xf0
000421 bd0d                      		out tcnt1h, temp
000422 bd1c                      		out tcnt1l, temp2
                                 		
000423 e0b1                      		ldi xh, high(curPos7Seg) ; get pereviously printed display indicator from ram
000424 e1a9                      		ldi xl, low(curPos7Seg)
000425 912c                      		ld temp3, x
                                 
000426 9523                      		inc temp3
                                 
000427 3028                      		cpi temp3, 8
000428 f410                      			brsh jumpToFirst7seg
000429 940c 0449                 			jmp printGlyph
                                 
                                 		jumpToFirst7seg:
00042b e020                      			ldi temp3, 0 ; select first indicator
00042c 940e 045f                 			call clear7SegScrBuffer
00042e e0b1                      			ldi xh, high(currentDisplayData)
00042f e1aa                      			ldi xl, low(currentDisplayData)
000430 910c                      			ld temp, x
                                 				
000431 e0f1                      			ldi zh, high(statesFlags0)
000432 e3e0                      			ldi zl, low(statesFlags0)
000433 8180                      			ld tempFlag2, z
000434 fd80                      			sbrc tempFlag2, sf_display_error_message_n
000435 940c 0447                 				jmp selectErrorMessage
000437 3000                      			cpi temp, 0
000438 f011                      				breq selectTemperaturesData ; TODO prevent failing compairing after SBR command in interruption handler
000439 3001                      			cpi temp, 1
00043a f041                      				breq selectTachometerData
                                 
                                 			selectTemperaturesData:
00043b 940e 04ae                 				call printEngineTemperature
00043d 940e 0499                 				call printCurrentTemperature
00043f 940e 0486                 				call printTargetTemperature
000441 940c 0449                 				jmp endJumpToFirstSegment
                                 
                                 			selectTachometerData:
000443 940e 0473                 				call printTachometerValue
000445 940c 0449                 				jmp endJumpToFirstSegment
                                 
                                 			selectErrorMessage:
000447 940e 04c8                 				call printErrorMessage
                                 
                                 			endJumpToFirstSegment:
                                 
                                 
                                 		printGlyph:
000449 9320 0119                 			sts curPos7Seg, temp3
                                 
                                 			; get number of a glyph 
00044b e0b1                      			ldi xh, high(SevenSegScrBuff)
00044c e1a0                      			ldi xl, low(SevenSegScrBuff)
00044d 0fa2                      			add  xl, temp3
                                 
00044e 910c                      			ld temp, x
                                 
00044f e0f0                      			ldi zh,0
000450 eae0                      			ldi zl, charTable7seg * 2
                                 
000451 0fe0                      			add zl, temp
000452 9104                      			lpm temp, z
                                 
000453 3021                      			cpi temp3, 1
000454 f021                      				breq printDot
000455 3024                      			cpi temp3, 4
000456 f011                      				breq printDot
000457 940c 045a                 				jmp moveGlyphToscreen
                                 			
                                 			printDot:
000459 7f0e                      				andi temp, 0b11111110
                                 
                                 			moveGlyphToScreen:
00045a 9522                      			swap temp3
00045b 0f22                      			lsl temp3
00045c bb28                      			out portb, temp3 ; select place on display
                                 
00045d bb05                      			out portc, temp ; print glyph
00045e 9508                      	ret
                                 
                                 	clear7SegScrBuffer:
00045f e0f0                      		ldi zh, 0
000460 eae0                      		ldi zl, charTable7seg * 2
000461 e103                      		ldi temp, chSpace ; load space glyph
                                 		;add zl, temp
                                 		;lpm temp, z
                                 
000462 9300 0110                 		sts SevenSegScrBuff + 0, temp ; clear unused display indicators
000464 9300 0111                 		sts SevenSegScrBuff + 1, temp
000466 9300 0112                 		sts SevenSegScrBuff + 2, temp
000468 9300 0113                 		sts SevenSegScrBuff + 3, temp
00046a 9300 0114                 		sts SevenSegScrBuff + 4, temp
00046c 9300 0115                 		sts SevenSegScrBuff + 5, temp
00046e 9300 0116                 		sts SevenSegScrBuff + 6, temp
000470 9300 0117                 		sts SevenSegScrBuff + 7, temp
000472 9508                      	ret
                                 
                                 	printTachometerValue:
000473 e0b1                      		ldi xh, high(engineSpeed) ; get engineSpeed from ram
000474 e2a9                      		ldi xl, low(engineSpeed)
000475 910c                      		ld temp, x
                                 	
000476 940e 04d7                 		call convertBinToDec
000478 2f10                      		mov temp2, temp
000479 701f                      		andi temp2, 0b00001111 ; select low page
00047a 9310 0112                 		sts SevenSegScrBuff + 2 , temp2 ; place the actual glyph number in a buffer
                                 
00047c 7f00                      		andi temp, 0b11110000 ; select high page
00047d 9502                      		swap temp
00047e 9300 0111                 		sts SevenSegScrBuff + 1, temp ; place the actual glyph nubmer in a buffer
                                 
000480 e000                      		ldi temp, ch0
000481 9300 0113                 		sts SevenSegScrBuff + 3, temp
000483 9300 0114                 		sts SevenSegScrBuff + 4, temp
000485 9508                      	ret
                                 
                                 	
                                 	printTargetTemperature:
000486 e0f1                      		ldi zh, high(statesFlags0)
000487 e3e0                      		ldi zl, low(statesFlags0)
000488 8180                      		ld tempFlag2, z
000489 ff82                      		sbrs tempFlag2, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
00048a 9508                      			ret
00048b e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
00048c e1ad                      		ldi xl, low(targetTemperature)
00048d 910c                      		ld temp, x
                                 	
00048e 940e 04d7                 		call convertBinToDec
000490 2f10                      		mov temp2, temp
000491 701f                      		andi temp2, 0b00001111 ; select low page
000492 9310 0114                 		sts SevenSegScrBuff + 4, temp2 ; place the actual glyph number in a buffer
                                 
000494 7f00                      		andi temp, 0b11110000 ; select high page
000495 9502                      		swap temp
000496 9300 0113                 		sts SevenSegScrBuff + 3, temp ; place the actual glyph nubmer in a buffer
000498 9508                      	ret
                                 
                                 	printCurrentTemperature:
000499 e0b1                      		ldi xh, high(analogValuesTable) ; get temperature from ram
00049a e0a0                      		ldi xl, low(analogValuesTable)
00049b 910c                      		ld temp, x
                                 
00049c 3800                      		cpi temp, 128 ; check right at the beggining if this number negative
00049d f420                      			brsh convertTemperature
                                 
                                 		negateTemperature:
00049e e111                      			ldi temp2,  chMinus ; "-" glyph number in a table
00049f 9310 0115                 			sts SevenSegScrBuff + 5, temp2
0004a1 9500                      			com temp
                                 			
                                 		convertTemperature:
0004a2 5800                      			subi temp, 128
0004a3 940e 04d7                 			call convertBinToDec
                                 	
0004a5 2f10                      			mov temp2, temp
0004a6 701f                      			andi temp2, 0b00001111 ; select low page
0004a7 9310 0117                 			sts SevenSegScrBuff + 7, temp2 ; place the actual glyph number in a buffer
                                 
0004a9 7f00                      			andi temp, 0b11110000 ; select high page
0004aa 9502                      			swap temp
0004ab 9300 0116                 			sts SevenSegScrBuff + 6, temp ; place the actual glyph nubmer in a buffer
0004ad 9508                      	ret
                                 
                                 	printEngineTemperature:
0004ae e0b1                      		ldi xh, high(analogValuesTable) ; get temperature from ram
0004af e0a0                      		ldi xl, low(analogValuesTable)
0004b0 e002                      		ldi temp, 2
0004b1 0fa0                      		add xl, temp
0004b2 910c                      		ld temp, x
                                 		
0004b3 3800                      		cpi temp, 128
0004b4 f068                      		 brlo printEngineTempNegative
                                 
0004b5 5800                      		subi temp, 128
0004b6 940e 04d7                 		call convertBinToDec
                                 	
0004b8 2f10                      		mov temp2, temp
0004b9 701f                      		andi temp2, 0b00001111 ; select low page
0004ba 9310 0111                 		sts SevenSegScrBuff + 1, temp2 ; place the actual glyph number in a buffer
                                 
0004bc 7f00                      		andi temp, 0b11110000 ; select high page
0004bd 9502                      		swap temp
0004be 9300 0110                 		sts SevenSegScrBuff, temp ; place the actual glyph nubmer in a buffer
0004c0 940c 04c7                 		jmp endEngineTempPrinting
                                 
                                 		printEngineTempNegative:
0004c2 e101                      			ldi temp, chMinus ; load "minus" gliph number
0004c3 9300 0110                 			sts SevenSegScrBuff, temp
0004c5 9300 0111                 			sts SevenSegScrBuff + 1, temp
                                 
                                 		endEngineTempPrinting:
0004c7 9508                      	ret
                                 
                                 	printErrorMessage:	
0004c8 e00e                      		ldi temp, chE
0004c9 9300 0110                 		sts SevenSegScrBuff, temp
0004cb e102                      		ldi temp, chR
0004cc 9300 0111                 		sts SevenSegScrBuff + 1, temp
0004ce 9300 0112                 		sts SevenSegScrBuff + 2, temp
0004d0 e000                      		ldi temp, ch0
0004d1 9300 0113                 		sts sevenSegScrBuff + 3, temp
0004d3 e102                      		ldi temp, chR
0004d4 9300 0114                 		sts sevenSegScrBuff + 4, temp
0004d6 9508                      	ret
                                 
                                 	convertBinToDec:
0004d7 3604                      		cpi temp, 100 ; check right at the beggining if this number is to big to display it on the screen
0004d8 f5d8                      		brsh btdMax
0004d9 e010                      		ldi temp2, 0 ; yeeeeeee no looooopsss ahahahhachchahhhacha
0004da 300a                      			cpi temp, 10
0004db f414                      			brge increaseTens0
0004dc 940c 051a                 				jmp setLowPage
                                 		increaseTens0:
0004de 500a                      			subi temp, 10
0004df 9513                      			inc temp2
0004e0 300a                      			cpi temp, 10
0004e1 f414                      			brge increaseTens1
0004e2 940c 051a                 				jmp setLowPage
                                 		increaseTens1:
0004e4 500a                      			subi temp, 10
0004e5 9513                      			inc temp2
0004e6 300a                      			cpi temp, 10
0004e7 f414                      			brge increaseTens2
0004e8 940c 051a                 				jmp setLowPage
                                 		increaseTens2:
0004ea 500a                      			subi temp, 10
0004eb 9513                      			inc temp2
0004ec 300a                      			cpi temp, 10
0004ed f414                      			brge increaseTens3
0004ee 940c 051a                 				jmp setLowPage
                                 		increaseTens3:
0004f0 500a                      			subi temp, 10
0004f1 9513                      			inc temp2
0004f2 300a                      			cpi temp, 10
0004f3 f414                      			brge increaseTens4
0004f4 940c 051a                 				jmp setLowPage
                                 		increaseTens4:
0004f6 500a                      			subi temp, 10
0004f7 9513                      			inc temp2
0004f8 300a                      			cpi temp, 10
0004f9 f414                      			brge increaseTens5
0004fa 940c 051a                 				jmp setLowPage
                                 		increaseTens5:
0004fc 500a                      			subi temp, 10
0004fd 9513                      			inc temp2
0004fe 300a                      			cpi temp, 10
0004ff f414                      			brge increaseTens6
000500 940c 051a                 				jmp setLowPage
                                 		increaseTens6:
000502 500a                      			subi temp, 10
000503 9513                      			inc temp2
000504 300a                      			cpi temp, 10
000505 f414                      			brge increaseTens7
000506 940c 051a                 				jmp setLowPage
                                 		increaseTens7:
000508 500a                      			subi temp, 10
000509 9513                      			inc temp2
00050a 300a                      			cpi temp, 10
00050b f414                      			brge increaseTens8
00050c 940c 051a                 				jmp setLowPage
                                 		increaseTens8:
00050e 500a                      			subi temp, 10
00050f 9513                      			inc temp2
000510 301a                      			cpi temp2, 10
000511 f414                      				brge btdMax
000512 940c 051a                 				jmp setLowPage
                                 		btdMax:
000514 e019                      			ldi temp2, 9
000515 2f01                      			mov temp, temp2
000516 9502                      			swap temp
000517 0f01                      			add temp, temp2
                                 			
000518 940c 051d                 			jmp endBTDConv
                                 
                                 		setLowPage:
00051a 9502                      			swap temp ; move low number to high page
00051b 0f01                      			add temp, temp2 ; save hig number to low page
00051c 9502                      			swap temp
                                 
                                 		endBTDConv:	
00051d 9508                      	ret
                                 
                                 
                                 	readAnalogSensors:
00051e 7f57                      		cbr eventsFlags0, ef_read_analog_sensors
                                 
00051f e0b1                      		ldi xh, high(currentSensorNum) ; get the nubmer of thermal sensor we wanna read from
000520 e1a8                      		ldi xl, low(currentSensorNum)
000521 911c                      		ld temp2, x
                                 
000522 e0f1                      		ldi zh, high(analogValuesTable) ; seting up addres of the beginning of temperatuers table
000523 e0e0                      		ldi zl, low(analogValuesTable)
                                 
000524 0fe1                      		add zl, temp2 ; apply offset to store data to correct place in a table
                                 
000525 b104                      		in temp, adcl
000526 b105                      		in temp, adch
000527 8300                      		st z, temp ; and finally store it
                                 
000528 9513                      		inc temp2 ; select next sensor value to be readen in the next iterration
                                 
                                 		
000529 3110                      		cpi temp2, 16 ; if next sensor is "non existing" 17th sensor then return to first one
00052a f414                      			brge jumpToFirstSensor
00052b 940c 052e                 			jmp saveNextSensorNumber ; else just save the next sensor nubmer
                                 
                                 		jumpToFirstSensor:
00052d e010                      			ldi temp2, 0
                                 
                                 		saveNextSensorNumber:
00052e 9310 0118                 			sts currentSensorNum, temp2
000530 0f11                      			lsl temp2
000531 b100                      			in temp, pinf ; get content of portf
000532 7e01                      			andi temp, 0b11100001 ; clear 4 bits to rewrite them later
000533 2b10                      			or temp2, temp
000534 9310 0062                 			sts portf, temp2
                                 
000536 e600                      		ldi temp, 0b01100000 ; and restart adc after all
000537 b907                      		out admux, temp
000538 ed0e                      		ldi temp, 0b11011110
000539 b906                      		out adcsra, temp
00053a 9508                      	ret
                                 
                                 	updateTachometer:
00053b 7f67                      		cbr eventsFlags1, ef_update_tachometer
                                 		
00053c e0b1                      		ldi xh, high(tachometerCounter) ; get value counted by tachometer counter durring 0.1 sec
00053d e2a8                      		ldi xl, low(tachometerCounter)
00053e 910c                      		ld temp, x
                                 		;inc temp ; some kind of trikky compensation
                                 
00053f e016                      		ldi temp2, 6
000540 9f01                      		mul temp, temp2 ; because it is 6*10 seconds in one minute
000541 2d00                      		mov temp, r0 ; get product low (numbers will not be to big)
                                 
                                 		
                                 
000542 3600                      		cpi temp, 96
000543 f410                      			brsh tachometerMax
000544 940c 0547                 			jmp saveEngineSpeed
                                 
                                 		tachometerMax:
000546 e603                      			ldi temp, 99
                                 		saveEngineSpeed:
000547 9300 0129                 			sts engineSpeed, temp
000549 e000                      			ldi temp, 0
00054a 9300 0128                 			sts tachometerCounter, temp
00054c 9508                      	ret
                                 
                                 	incrementTachometerCounter:
00054d 7e6f                      		cbr eventsFlags1, ef_increment_tachometer
                                 
00054e b709                      		in temp, eimsk ; disable external intrruption int1
00054f 7f0d                      		andi temp, 0b11111101
000550 bf09                      		out eimsk, temp
                                 
000551 e0b1                      		ldi xh, high(tachometerCounter)
000552 e2a8                      		ldi xl, low(tachometerCounter)
000553 910c                      		ld temp, x
                                 		
000554 3f0f                      		cpi temp, 255
000555 f029                      			breq endIncTachCounter
000556 940c 0558                 			jmp incTachCounter
                                 
                                 		incTachCounter:
000558 9503                      			inc temp
000559 9300 0128                 			sts tachometerCounter, temp
                                 		
                                 		endIncTachCounter:
00055b b709                      			in temp, eimsk
00055c e012                      			ldi temp2, 0b00000010
00055d 2b01                      			or temp, temp2 ; enable external intrruption int1
00055e bf09                      			out eimsk, temp
00055f 9508                      	ret
                                 	
                                 
                                 	////////////INTERRUPTIONS HANDLERS/////////////
                                 	extInt0Handler:
000560 b74f                      		in tempInter, sreg
000561 6250                      		sbr eventsFlags0, ef_handle_input
000562 bf4f                      		out sreg, tempInter
000563 9518                      	reti
                                 
                                 	extInt1Handler:
000564 b74f                      		in tempInter, sreg
000565 6160                      		sbr eventsFlags1, ef_increment_tachometer
000566 bf4f                      		out sreg, tempInter
000567 9518                      	reti
                                 
                                 	timer0OvfHandler:
000568 b74f                      		in tempInter, sreg
000569 6450                      		sbr eventsFlags0, ef_update_sound_type
00056a bf4f                      		out sreg, tempInter
00056b 9518                      	reti
                                 
                                 	timer1OvfHandler:
00056c b74f                      		in tempInter, sreg
00056d 6150                      		sbr eventsFlags0, ef_update_7seg_screen
00056e bf4f                      		out sreg, tempInter
00056f 9518                      	reti
                                 
                                 	timer2OvfHandler: 
000570 b74f                      		in tempInter, sreg
000571 6850                      		sbr eventsFlags0, ef_update_sound_wave_state
000572 bf4f                      		out sreg, tempInter
000573 9518                      	reti
                                 
                                 	timer3OvfHandler:
000574 b74f                      		in tempInter, sreg
000575 6460                      		sbr eventsFlags1, ef_update_program_timers
000576 bf4f                      		out sreg, tempInter
000577 9518                      	reti
                                 
                                 	adcConvertionHandler:	
000578 b74f                      		in tempInter, sreg
000579 6058                      		sbr eventsFlags0, ef_read_analog_sensors
00057a bf4f                      		out sreg, tempInter


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :  47 y  :   0 z  :  21 r0 :   1 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 350 r17:  85 r18:  24 r19:  14 r20:  14 
r21:  25 r22:  24 r23:  12 r24:  84 r25:   0 r26:  59 r27:  47 r28:   0 
r29:   0 r30:  24 r31:  22 
Registers used: 16 out of 35 (45.7%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  16 adiw  :   0 and   :   0 
andi  :  17 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  24 brge  :  12 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  13 brlt  :   0 brmi  :   0 
brne  :   1 brpl  :   0 brsh  :  15 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  56 cbi   :   7 cbr   :  34 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   1 cp    :   3 cpc   :   0 
cpi   :  62 cpse  :   0 dec   :   1 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  22 inc   :  28 
jmp   : 105 ld    :  66 ldd   :   0 ldi   : 233 lds   :   0 lpm   :   2 
lsl   :   4 lsr   :   1 mov   :   8 movw  :   0 mul   :   1 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   8 ori   :   0 out   :  49 
pop   :   2 push  :   0 rcall :   0 ret   :  54 reti  :  10 rjmp  :   0 
rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 sbi   :  13 sbic  :   6 
sbis  :   1 sbiw  :   0 sbr   :  29 sbrc  :  26 sbrs  :  14 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   : 100 sub   :   0 subi  :  12 swap  :  10 tst   :   0 wdr   :   0 

Instructions used: 40 out of 114 (35.1%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000af8   2656     24   2680  131072   2.0%
[.dseg] 0x000100 0x000131      0     49     49    4096   1.2%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
