
AVRASM ver. 2.2.7  C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm Sun Dec 20 22:52:02 2020

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Jebbyk\Desktop\My dear Nesteruk\Automobile\Automobile\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
                                 
                                 .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 .def temp = r16 ; temporal registter for some actions
                                 .def temp2 = r17
                                 .def temp3 = r18
                                 .def temp4 = r19
                                 .def tempInter = r20
                                 .def eventsFlags0 = r21
                                 .def eventsFlags1 = r22
                                 .def eventsFlags2 = r23
                                 .def statesFlags0 = r24
                                 
                                 .equ speaker_pin_number = 5
                                 .equ speaker_pin_position = 0b00000100 ; speaker will be connected on 5th pin of portD
                                 
                                 .equ engine_flap_pin_num = 7 ; engine cooler flap will be contolled by the electrical magnet
                                 .equ engine_flap_pin_pos = 0b10000000
                                 
                                 .equ outside_flap_pin_num = 6 ; the same for outside flap
                                 .equ outside_flap_pin_pos = 0b01000000
                                 
                                 .equ debug_pin_position = 0b00100000 ; will use this pin to show something idk
                                 .equ debug_pin_number = 5
                                 
                                 .equ heater_pin_number = 0
                                 .equ heater_pin_position = 0b000000001
                                 .equ cooler_pin_number = 1
                                 .equ cooler_pin_position = 0b000000010
                                 
                                 .equ frontAirbagsTriggerPinNumber = 4
                                 .equ frontAirbagsTriggerPinPosition = 0b00010000
                                 .equ sideAirbagsTriggerPinNumber = 3
                                 .equ sideAirbagsTriggerPinPosition =  0b00001000
                                 .equ maxAllowedSideAcceleration = 40
                                 .equ maxAllowedForwardAcceleration = 100
                                 .equ maxAllowedBackwardAcceleration = 70
                                 .equ accelerationCheckingFreq = 128 + 64 + 32 + 16 + 8 + 4 + 2
                                 
                                 .equ insideThermalSensorNum = 0
                                 .equ outsideThermalSensorNum = 1
                                 .equ engineThermalSensorNum = 2
                                 .equ steeringWheelSensorNum = 3
                                 .equ seat0ThermalSensorNum = 4 ; TODO can be done without these 4 lines of code
                                 .equ seat1ThermalSensorNum = 5
                                 .equ seat2ThermalSensorNum = 6
                                 .equ seat3ThermalSensorNum = 7 
                                 .equ seat0FlapControl = 8
                                 .equ seat1FlapControl = 9
                                 .equ seat2FlapControl = 10
                                 .equ seat3FlapControl = 11
                                 .equ accelerationFrontSensorZ = 12
                                 .equ accelerationFrontSensorX = 13
                                 .equ accelerationRearSensorX = 14
                                 .equ lolkekcheburek = 15
                                 
                                 .equ tccr0_setup_byte = 0b00000101 ; select speed for timer0
                                 .equ assr_setup_byte =  0b00001000 ; select async oscilator (slower speed and independent from main clock)
                                 .equ tccr1b_setup_byte = 0b00000101 ; seelect speed for timer1
                                 .equ tccr2_setup_byte = 0b00000101 ; select speed for timer2
                                 .equ tccr3b_setup_byte = 0b00000011 ; select speed for timer3
                                 .equ timsk_setup_byte = 0b01000101 ; enable timer2, tiemr1 and timer0 interruption on overflowz
                                 .equ etimsk_setup_byte = 0b00000100 ; enable temer3 interruption on overflow
                                 
                                 .equ ch0 = 0
                                 .equ ch1 = 1
                                 .equ ch2 = 2
                                 .equ ch3 = 3
                                 .equ ch4 = 4
                                 .equ ch5 = 5
                                 .equ ch6 = 6
                                 .equ ch7 = 7
                                 .equ ch8 = 8
                                 .equ ch9 = 9
                                 .equ chA = 10
                                 .equ chB = 11
                                 .equ chC = 12
                                 .equ chD = 13
                                 .equ chE = 14
                                 .equ chF = 15
                                 .equ chGrad = 16
                                 .equ chMinus = 17
                                 .equ chR = 18
                                 .equ chSpace = 19
                                 
                                 .equ soundSignalsDelay = 128 + 64 + 32 + 16 ; (lower number bigger delays)
                                 	.equ tone0 = 0 + 128 + 64 + 32 + 16 + 8 + 4 ; (lower number -lower tone)
                                  	.equ tone1 = 0 + 128 + 64 + 32 + 16 + 8 + 4 + 2
                                 
                                 .equ displayDataSwitchingFreq = 128 + 64 + 32 ; bigger number - faster switching
                                 
                                 .equ checkOutsideTemperatureFreq = 128 + 64 + 32 + 16 
                                 
                                 .equ condFanSpeed = 249; higher number - higher speed
                                 	
                                 
                                 	; states flags 0
                                 	.equ sf_sound_enabled =				0b10000000
                                 	.equ sf_sound_enabled_n =			7
                                 	.equ sf_warning_signal_enabled =	0b01000000
                                 	.equ sf_warning_signal_enabled_n =  6
                                 	.equ sf_click_signal_enabled  =		0b00100000
                                 	.equ sf_click_signal_enabled_n =	5
                                 	.equ sf_accept_signal_enabled =		0b00010000
                                 	.equ sf_accept_signal_enabled_n =	4
                                 	.equ sf_cancel_signal_enabled =		0b00001000
                                 	.equ sf_cancel_signal_enabled_n =	3
                                 	.equ sf_conditioner_enabled =		0b00000100
                                 	.equ sf_conditioner_enabled_n =		2
                                 	.equ sf_engine_cooler_flap_state =	0b00000010
                                 	.equ sf_engine_cooler_flap_state_n = 1
                                 	.equ sf_display_error_message =		0b00000001
                                 	.equ sf_display_error_message_n =	0
                                 
                                 	; eventsFlags0
                                 	.equ ef_update_sound_wave_state =	0b10000000
                                 	.equ ef_update_sound_wave_state_n =	7
                                 	.equ ef_update_sound_type =			0b01000000
                                 	.equ ef_update_sound_type_n =		6
                                 	.equ ef_handle_input =				0b00100000
                                 	.equ ef_handle_input_n =			5
                                 	.equ ef_update_7seg_screen =		0b00010000
                                 	.equ ef_update_7seg_screen_n =		4
                                 	.equ ef_read_analog_sensors =		0b00001000
                                 	.equ ef_read_analog_sensors_n =		3
                                 	.equ ef_save_target_temperature =	0b00000100
                                 	.equ ef_save_target_temperature_n = 2
                                 	.equ ef_update_heater =				0b00000010
                                 	.equ ef_update_heater_n =			1
                                 	.equ ef_update_conditioner_fan =	0b00000001
                                 	.equ ef_update_conditioner_fan_n =	0
                                 
                                 
                                 	; events flags1
                                 	.equ ef_load_target_temp =			0b10000000
                                 	.equ ef_load_target_temp_n =		7
                                 	.equ ef_update_program_timers =		0b01000000
                                 	.equ ef_update_program_timers_n =	6
                                 	.equ ef_update_flaps =				0b00100000
                                 	.equ ef_update_flaps_n =			5
                                 	.equ ef_increment_tachometer =		0b00010000
                                 	.equ ef_increment_tachometer_n =	4
                                 	.equ ef_update_tachometer =			0b00001000
                                 	.equ ef_update_tachometer_n =		3
                                 	.equ ef_check_engine_temperature =	0b00000100
                                 	.equ ef_check_engine_temperature_n = 2
                                 	.equ ef_switch_display_data =		0b00000010
                                 	.equ ef_switch_display_data_n =		1
                                 	.equ ef_handle_current_key =		0b00000001
                                 	.equ ef_handle_current_key_n =		0
                                 
                                 	; events falgs 2
                                 	.equ ef_check_outside_temperature =		0b10000000
                                 	.equ ef_check_outside_temperature_n =   7
                                 	.equ ef_check_acceleration =			0b01000000
                                 	.equ ef_check_acceleration_n =			6
                                 
                                 
                                 //addreses in eeprom where usefull data will be saved
                                 .equ targetTempSavingAddr = 0
                                 
                                 
                                 .dseg
                                 	analogValuesTable:
000100                           		.byte 16 ; there will be stored all the data from all 8 thermal sensors
                                 	SevenSegScrBuff:
000110                           		.byte 8 ; reserve 8 bytes for 7 segment dysplay buffer
                                 	currentSensorNum:
000118                           		.byte 1 ; there will be stored number of thermalSensor we wanna save data from
                                 	curPos7Seg:
000119                           		.byte 1 ; position of currently printing glyph on 7seg display
                                 	
                                 	currentDisplayData:
00011a                           		.byte 1 ; 0 - temperatures, 1 - tachometer
                                 	switchDisplayDataTimerH:
00011b                           		.byte 1 ;
                                 	switchDisplayDataTimerL:
00011c                           		.byte 1 ;
                                 
                                 	targetTemperature:
00011d                           		.byte 1 ; reserve  1 byte to keep temperature while running\
                                 	updateConditionerTimer:
00011e                           		.byte 1
                                 	flapsUpdateTimer:
00011f                           		.byte 1
                                 	currentControlledFlap:
000120                           		.byte 1
                                 	conditionerFanTimer0:
000121                           		.byte 1 ; reserve 2 bytes to store current conditioner fan timer
                                 	conditionerFanTimer1:
000122                           		.byte 1
                                 	conditionerFanState:
000123                           		.byte 1 ; reserve 1 byte to know fan "rotation" (not quite but who cares)
                                 	checkOutsideTemperatureTimerH:
000124                           		.byte 1
                                 	checkOutsideTemperatureTimerL:
000125                           		.byte 1
                                 
                                 	tachometerTimerH:
000126                           		.byte 1
                                 	tachometerTimerL:
000127                           		.byte 1
                                 	tachometerCounter:
000128                           		.byte 1
                                 	engineSpeed:
000129                           		.byte 1
                                 	checkEngineTemperatureTimer:
00012a                           		.byte 1
                                 
                                 	currentTone:
00012b                           		.byte 1 ; there will be stored current note of sound
                                 
                                 	currentKey:
00012c                           		.byte 1 ; there will be storred a number of the last pressed key
                                 	handleCurrentKeyTimer:
00012d                           		.byte 1
                                 
                                 	checkAccelerationTimer:
00012e                           		.byte 1 
                                 
                                 .cseg
                                 	.org 0
000000 940c 005c                 		jmp reset
                                 
                                 	
                                 		.org $0002
000002 940c 04f4                 			jmp extInt0Handler
                                 		.org $0004
000004 940c 04f8                 			jmp extInt1Handler
                                 		.org $0014
000014 940c 0504                 			jmp timer2OvfHandler
                                 		.org $001C
00001c 940c 0500                 			jmp timer1OvfHandler
                                 		.org $0020
000020 940c 04fc                 			jmp timer0OvfHandler
                                 		.org $002a
00002a 940c 050c                 			jmp adcConvertionHandler
                                 		.org $003a 
00003a 940c 0508                 			jmp timer3OvfHandler
                                 
                                 
                                 	.org $0050 ; start program almost right after all intrruptions vectors
                                 
                                 	charTable7seg: 
                                 		//main simbols for 7seg display
000050 9f03
000051 0d25                      		.db 0b00000011 /*0*/, 0b10011111 /*1*/, 0b00100101 /*2*/, 0b00001101 /*3*/
000052 4999
000053 1f41                      		.db	0b10011001 /*4*/, 0b01001001 /*5*/, 0b01000001 /*6*/, 0b00011111 /*7*/
000054 0901
000055 c111                      		.db	0b00000001 /*8*/, 0b00001001 /*9*/, 0b00010001 /*a*/, 0b11000001 /*b*/
000056 8561
000057 7161                      		.db	0b01100001 /*c*/, 0b10000101 /*d*/, 0b01100001 /*e*/, 0b01110001 /*f*/
                                 
                                 		//extra simbols for 7seg display
000058 fd39
000059 ff73                      		.db	0b00111001 /*grad*/, 0b11111101 /*minus*/, 0b01110011 /*r*/, 0xff /*space*/
                                 
                                 	errorString7: 
00005a 120e
00005b 1312                      		.db chE, chR, chR, chSpace
                                 	
                                 
                                 	reset:
                                 
00005c e100                      		ldi temp, high(ramend) ; setting up stack pointer
00005d bf0e                      		out sph, temp
00005e ef0f                      		ldi temp, low(ramend)
00005f bf0d                      		out spl, temp
                                 
                                 		; setting up ports
000060 e908                      		ldi temp, 0b10011000 ; 0,1,2-in (read column), 3,4 - out (select row), 7 - out (check all buttons)
000061 bb0a                      		out ddra, temp
000062 e800                      		ldi temp, 0b10000000 ; enable continuous check if any button is pressed
000063 bb0b                      		out porta, temp
                                 
000064 ee00                      		ldi temp, 0b11100000 ; set last hree bits of portB to be output
000065 bb07                      		out ddrb, temp
                                 
000066 ef0f                      		ldi temp, 0b11111111 ; set all pins of portC to be output
000067 bb04                      		out ddrc, temp
                                 
000068 e004                      		ldi temp, speaker_pin_position
000069 e810                      		ldi temp2, engine_flap_pin_pos
00006a 2b01                      		or temp, temp2
00006b e410                      		ldi temp2, outside_flap_pin_pos
00006c 2b01                      		or temp, temp2
00006d bb01                      		out ddrd, temp
                                 
00006e ef0f                      		ldi temp, 0xff ;heater, cooler, 2,3 - flap state, 4-7 step engines (fans)
00006f b902                      		out ddre, temp
                                 
000070 ef0e                      		ldi temp, 0b11111110 ; 0 - thermSensors in, 1-4 selected thermalSensor, 6-7 selected flap
000071 9300 0061                 		sts ddrf, temp
                                 
                                 
                                 		//setting up external interrupts
000073 e003                      		ldi temp, 0b00000011 ; enable external intrruption int0, int1
000074 bf09                      		out eimsk, temp
                                 
000075 e00f                      		ldi temp, 0b00001111 ; set ext interrupt0 and interrupt1 on rising edge
000076 9300 006a                 		sts eicra, temp
                                 
                                 		//setting up timers
000078 e005                      		ldi temp, tccr0_setup_byte
000079 bf03                      		out tccr0, temp ; set timer0 speed
00007a e008                      		ldi temp, assr_setup_byte
00007b bf00                      		out assr, temp ; select async oscilator ( timer0 will be super slow and independent from main clock)
                                 
00007c e005                      		ldi temp, tccr1b_setup_byte ; setting up timer1 speed
00007d bd0e                      		out tccr1b, temp;
00007e ef0f                      		ldi temp, 0xff ; reset timer
00007f e010                      		ldi temp2, 0x00
000080 bd0d                      		out tcnt1h, temp
000081 bd1c                      		out tcnt1l, temp2
                                 
000082 e005                      		ldi temp, tccr2_setup_byte
000083 bd05                      		out tccr2, temp ; set timer2 speed
                                 
000084 e003                      		ldi temp, tccr3b_setup_byte ; setting up timer3 speed
000085 9300 008a                 		sts tccr3b, temp
                                 
000087 e405                      		ldi temp, timsk_setup_byte
000088 bf07                      		out timsk, temp ; enable interupts on timers overflowing
                                 
000089 e004                      		ldi temp, etimsk_setup_byte
00008a 9300 007d                 		sts etimsk, temp
                                 
                                 
00008c e600                      		ldi temp, 0b01100000 ; use external cap in adc, left adjust the result
00008d b907                      		out admux, temp
                                 
00008e ed0f                      		ldi temp, 0b11011111 ; en adc, start conv, , clear int flag, enable interuptions, setup prescaler
00008f b906                      		out adcsra, temp
                                 
                                 	
000090 6860                      		sbr eventsFlags1, ef_load_target_temp ; try to load target temp on start
                                 
000091 9478                      		sei ;  allow interrupts
                                 
                                 
                                 	backgroundProcess:
000092 fd56                      		sbrc eventsFlags0, ef_update_sound_type_n
000093 940e 0309                 			call updateSoundType
000095 fd57                      		sbrc eventsFlags0, ef_update_sound_wave_state_n
000096 940e 0362                 			call updateWaveState
000098 fd55                      		sbrc eventsFlags0, ef_handle_input_n
000099 940e 0372                 			call readInput
00009b fd54                      		sbrc eventsFlags0, ef_update_7seg_screen_n
00009c 940e 03b8                 			call update7segScreen
00009e fd53                      		sbrc eventsFlags0, ef_read_analog_sensors_n
00009f 940e 04b2                 			call readAnalogSensors
0000a1 fd52                      		sbrc eventsFlags0, ef_save_target_temperature_n
0000a2 940e 0238                 			call saveTargetTemperature
0000a4 fd51                      		sbrc eventsFlags0, ef_update_heater_n
0000a5 940e 026e                 			call updateConditioner
0000a7 fd50                      		sbrc eventsFlags0, ef_update_conditioner_fan_n
0000a8 940e 02d0                 			call updateConditionerFan
                                 
0000aa fd67                      		sbrc eventsFlags1, ef_load_target_temp_n
0000ab 940e 0246                 			call loadTargetTemperature
0000ad fd66                      		sbrc eventsFlags1, ef_update_program_timers_n
0000ae 940e 0146                 			call updateProgramTimers 
0000b0 fd65                      		sbrc eventsFlags1, ef_update_flaps_n
0000b1 940e 02e5                 			call updateFlaps
0000b3 fd63                      		sbrc eventsFlags1, ef_update_tachometer_n
0000b4 940e 04cf                 			call updateTachometer
0000b6 fd64                      		sbrc eventsFlags1, ef_increment_tachometer_n
0000b7 940e 04e1                 			call incrementTachometerCounter
0000b9 fd62                      		sbrc eventsFlags1, ef_check_engine_temperature_n
0000ba 940e 0252                 			call checkEngineTemperature
0000bc fd61                      		sbrc eventsFlags1, ef_switch_display_data_n
0000bd 940e 039a                 			call switchDisplayData
0000bf fd60                      		sbrc eventsFlags1, ef_handle_current_key_n
0000c0 940e 0104                 			call handleCurrentKey
                                 
0000c2 fd77                      		sbrc eventsFlags2, ef_check_outside_temperature_n
0000c3 940e 025f                 			call checkOutsideTemperature
0000c5 fd76                      		sbrc eventsFlags2, ef_check_acceleration_n
0000c6 940e 00ca                 			call checkAcceleration
                                 
0000c8 940c 0092                  	jmp backgroundProcess
                                 
                                 	checkAcceleration:
0000ca 7b7f                      		cbr eventsFlags2, ef_check_acceleration
                                 
0000cb e0b1                      		ldi xh, high(analogValuesTable)
0000cc e0a0                      		ldi xl, low(analogValuesTable)
0000cd e00c                      		ldi temp, accelerationFrontSensorZ
0000ce 0fa0                      		add xl, temp
0000cf 911c                      		ld temp2, x
                                 
0000d0 331a                      		cpi temp2, 128 - maxAllowedBackwardAcceleration
0000d1 f0b0                      			brlo frontCollision
                                 		
                                 		checkRearCollision:
0000d2 3e14                      			cpi temp2, 128 + maxAllowedForwardAcceleration
0000d3 f4c0                      				brsh rearCollision
                                 
                                 		
                                 
                                 		checkFrontLeftCollision:
0000d4 e0b1                      		ldi xh, high(analogValuesTable)
0000d5 e0a0                      		ldi xl, low(analogValuesTable)
0000d6 e00d                      		ldi temp, accelerationFrontSensorX
0000d7 0fa0                      		add xl, temp
0000d8 912c                      		ld temp3, x
                                 
                                 		
0000d9 3a28                      		cpi temp3, 128 + maxAllowedSideAcceleration
0000da f4b0                      			brsh frontLeftCollision
                                 		
                                 		checkFrontRightCollision:
0000db 3528                      			cpi temp3, 128 - maxAllowedSideAcceleration
0000dc f0c8                      				brlo frontRightCollision
                                 
                                 		checkBackLeftCollision:
0000dd e0b1                      		ldi xh, high(analogValuesTable)
0000de e0a0                      		ldi xl, low(analogValuesTable)
0000df e00e                      		ldi temp, accelerationRearSensorX
0000e0 0fa0                      		add xl, temp
0000e1 913c                      		ld temp4, x
                                 
0000e2 3a38                      		cpi temp4, 128 + maxAllowedSideAcceleration
0000e3 f4b8                      			brsh backLeftCollision
                                 
                                 		checkBackRightCollision:
0000e4 3538                      			cpi temp4, 128 - maxAllowedSideAcceleration
0000e5 f0d0                      				brlo backRightCollision
0000e6 940c 0103                 				jmp endCheckCollision
                                 
                                 		frontCollision:
0000e8 940e 0134                 			call enableWarningSignal
0000ea 940c 00d2                 			jmp checkRearCollision
                                 
                                 		rearCollision:
0000ec 9a94                      			sbi portd, frontAirbagsTriggerPinNumber
0000ed 940e 0134                 			call enableWarningSignal
0000ef 940c 00d4                 			jmp checkFrontLeftCollision
                                 
                                 		frontLeftCollision:
0000f1 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
0000f2 940e 0134                 			call enableWarningSignal
0000f4 940c 00db                 			jmp checkFrontRightCollision
                                 
                                 		frontRightCollision:
0000f6 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
0000f7 940e 0134                 			call enableWarningSignal
0000f9 940c 00dd                 			jmp checkBackLeftCollision
                                 
                                 		backLeftCollision:
0000fb 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
0000fc 940e 0134                 			call enableWarningSignal
0000fe 940c 00e4                 			jmp checkBackRightCollision
                                 
                                 		backRightCollision:
000100 9a93                      			sbi portd, sideAirbagsTriggerPinNumber
000101 940e 0134                 			call enableWarningSignal
                                 
                                 		endCheckCollision:
000103 9508                      	ret
                                 
                                 	handleCurrentKey:
000104 7f6e                      		cbr eventsFlags1, ef_handle_current_key
000105 e0b1                      		ldi xh, high(currentKey)
000106 e2ac                      		ldi xl, low(currentKey)
000107 910c                      		ld temp, x
000108 310c                      		cpi temp, 28
000109 f041                      			breq callRizeTemperature
00010a 3104                      		cpi temp, 20
00010b f051                      			breq callLowerTemperature
00010c 300c                      		cpi temp, 12
00010d f061                      			breq callHandleCancelKey
00010e 3109                      		cpi temp, 25
00010f f071                      			breq callSwitchConditioner
000110 940c 0120                 			jmp handleCurrentKeyEnd
                                 
                                 		callRizeTemperature:
000112 940e 01ff                 			call rizeTemperature
000114 940c 0120                 			jmp handleCurrentKeyEnd
                                 
                                 		callLowerTemperature:
000116 940e 0211                 			call lowerTemperature
000118 940c 0120                 			jmp handleCurrentKeyEnd
                                 
                                 		callHandleCancelKey:
00011a 940e 0121                 			call handleCancelKey
00011c 940c 0120                 			jmp handleCurrentKeyEnd
                                 
                                 		callSwitchConditioner:
00011e 940e 0223                 			call switchConditioner
                                 
                                 		handleCurrentKeyEnd:
000120 9508                      	ret
                                 
                                 
                                 	handleCancelKey:
000121 fd86                      		sbrc statesFlags0, sf_warning_signal_enabled_n
000122 940c 0126                 			jmp cancelWarning
000124 940c 012d                 			jmp endHandleCancelKey
                                 
                                 		cancelWarning:
000126 e000                      			ldi temp, 0
000127 9300 012c                 			sts currentKey, temp ; current key is handled. so clear it
000129 940e 0138                 			call disableWarningSignal
00012b 940e 0142                 			call enableCancelSignal
                                 
                                 		endHandleCancelKey:
                                 
00012d 9508                      	ret
                                 
                                 	resetSoundState:
00012e 7d8f                      		cbr statesFlags0, sf_click_signal_enabled
00012f 7e8f                      		cbr statesFlags0, sf_accept_signal_enabled
000130 7f87                      		cbr statesFlags0, sf_cancel_signal_enabled
000131 7b8f                      		cbr statesFlags0, sf_warning_signal_enabled
000132 778f                      		cbr statesFlags0, sf_sound_enabled
000133 9508                      	ret
                                 
                                 	enableWarningSignal:
000134 940e 012e                 		call resetSoundState
000136 6480                      		sbr statesFlags0, sf_warning_signal_enabled
000137 9508                      	ret
                                 
                                 	disableWarningSignal:
000138 7b8f                      		cbr statesFlags0, sf_warning_signal_enabled
000139 9508                      	ret
                                 
                                 	enableClickSignal:
00013a 940e 012e                 		call resetSoundState
00013c 6280                      		sbr statesFlags0, sf_click_signal_enabled
00013d 9508                      	ret
                                 
                                 	enableAcceptSignal:
00013e 940e 012e                 		call resetSoundState
000140 6180                      		sbr statesFlags0, sf_accept_signal_enabled
000141 9508                      	ret
                                 
                                 	enableCancelSignal:
000142 940e 012e                 		call resetSoundState
000144 6088                      		sbr statesFlags0, sf_cancel_signal_enabled
000145 9508                      	ret
                                 
                                 	updateProgramTimers:
000146 ef0f                      		ldi temp, 0xff ; preset timer to change overflowing freq
000147 ef10                      		ldi temp2, 0xf0
000148 9300 0089                 		sts tcnt3h, temp
00014a 9310 0088                 		sts tcnt3l, temp2
                                 
00014c 7b6f                      		cbr eventsFlags1, ef_update_program_timers
                                 
00014d ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
00014e 940c 0186                 			jmp updTachTimer
                                 		
000150 e0b1                      		ldi xh, high(updateConditionerTimer) ; get timer from ram
000151 e1ae                      		ldi xl, low(updateConditionerTimer)
000152 910c                      		ld temp, x
000153 9503                      		inc temp
000154 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
000155 f011                      			breq setConditionerFlag
000156 940c 015a                 			jmp saveConditionerTimer
                                 
                                 		setConditionerFlag:
000158 6052                      			sbr eventsFlags0, ef_update_heater ; create "update_heater" task
                                 
000159 e000                      			ldi temp, 0 ; reset heater update timer
                                 
                                 		saveConditionerTimer:
00015a 9300 011e                 			sts updateConditionerTimer, temp ;and save it to ram
                                 
                                 		; CONDITIONER FAN ;
00015c e0b1                      		ldi xh, high(conditionerFanTimer0) ; get temperature from ram
00015d e2a1                      		ldi xl, low(conditionerFanTimer0)
00015e 910c                      		ld temp, x
00015f 3f0f                      		cpi temp, 255 
000160 f029                      			breq checkCondFanTimer1	
000161 9503                      			inc temp
000162 9300 0121                 			sts conditionerFanTimer0, temp
000164 940c 017a                 			jmp endUpdateCondFanTimer
                                 
                                 		checkCondFanTimer1:
000166 ec00                      			ldi temp, 128 + 64
000167 9300 0121                 			sts conditionerFantimer0, temp
000169 e0b1                      			ldi xh, high(conditionerFanTimer1)
00016a e2a2                      			ldi xl, low(conditionerFanTimer1)
00016b 910c                      			ld temp, x
                                 
00016c 3f0f                      			cpi temp, 255
00016d f029                      				breq setUpdateCondFanFlag
00016e 9503                      				inc temp
00016f 9300 0122                 				sts conditionerFanTimer1, temp
000171 940c 017a                 				jmp endUpdateCondFanTimer
                                 				
                                 				
                                 
                                 		setUpdateCondFanFlag:
000173 6051                      			sbr eventsFlags0, ef_update_conditioner_fan ; start upate fan task
                                 
000174 ec00                      			ldi temp, 128 + 64
000175 9300 0121                 			sts conditionerFanTimer0, temp ; reset timer
000177 ef09                      			ldi temp, condFanSpeed
000178 9300 0122                 			sts conditionerFanTimer1, temp
                                 		
                                 		endUpdateCondFanTimer:
                                 
                                 
                                 
                                 		////////////udpate flaps timer ///////////
00017a e0b1                      		ldi xh, high(flapsUpdateTimer) ; get flaps timer from ram
00017b e1af                      		ldi xl, low(flapsUpdateTimer)
00017c 910c                      		ld temp, x
00017d 9503                      		inc temp
00017e 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
00017f f011                      			breq setUpdateFlapsFlag
000180 940c 0184                 			jmp saveUpdateFlapsTimer
                                 
                                 		setUpdateFlapsFlag:
000182 6260                      			sbr eventsFlags1, ef_update_flaps ; create "update_flaps" task
                                 
000183 e000                      			ldi temp, 0 ; reset flaps update timer
                                 
                                 		saveUpdateFlapsTimer:
000184 9300 011f                 			sts flapsUpdateTimer, temp ;and save it to ram
                                 
                                 
                                 		
                                 		updTachTimer:
000186 e0b1                      		ldi xh, high(tachometerTimerL)
000187 e2a7                      		ldi xl, low(tachometerTimerL)
000188 910c                      		ld temp, x
000189 9503                      		inc temp
00018a 3f0f                      		cpi temp, 255 
00018b f011                      			breq incrementTachTimerH
00018c 940c 0199                 			jmp saveTachTimerL
                                 
                                 		incrementTachTimerH:
00018e e000                      			ldi temp, 0
00018f 9300 0127                 			sts tachometerTimerL, temp
                                 
000191 e0b1                      			ldi xh, high(tachometerTimerH)
000192 e2a6                      			ldi xl, low(tachometerTimerH)
000193 910c                      			ld temp, x
000194 9503                      			inc temp
000195 3f0f                      			cpi temp, 255
000196 f051                      				breq resetTachTimer
000197 940c 019d                 				jmp saveTachTimerH
                                 
                                 		saveTachTimerL:
000199 9300 0127                 			sts tachometerTimerL, temp
00019b 940c 01a8                 			jmp endTachTimerUpdate
                                 
                                 		saveTachTimerH:
00019d 9300 0126                 			sts tachometerTimerH, temp
00019f 940c 01a8                 			jmp endTachTimerUpdate
                                 
                                 		resetTachTimer:
0001a1 ef0c                      			ldi temp, 128 + 64 + 32 + 16 + 8 + 4
0001a2 9300 0126                 			sts tachometerTimerH, temp
0001a4 e000                      			ldi temp, 0
0001a5 9300 0127                 			sts tachometerTimerL, temp
                                 			
0001a7 6068                      			sbr eventsFlags1, ef_update_tachometer
                                 		
                                 		endTachTimerUpdate:
                                 
                                 
                                 		//////////// switch displayed data timer ///////////////////
0001a8 e0b1                      		ldi xh, high(switchDisplayDataTimerL) ; get timer from ram
0001a9 e1ac                      		ldi xl, low(switchDisplayDataTimerL)
0001aa 910c                      		ld temp, x
0001ab 9503                      		inc temp
0001ac 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001ad f021                      			breq incSwitchDisplayDataTimerH
0001ae 9300 011c                 			sts switchDisplayDataTimerL, temp
0001b0 940c 01c1                 			jmp endDisplayDataTimerUpdate
                                 
                                 		incSwitchDisplayDataTimerH:
0001b2 e000                      			ldi temp, 0
0001b3 9300 011c                 			sts switchDisplayDataTimerL, temp
                                 
0001b5 e0b1                      			ldi xh, high(switchDisplayDataTimerH)
0001b6 e1ab                      			ldi xl, low(switchDisplayDataTimerH)
0001b7 910c                      			ld temp, x
0001b8 9503                      			inc temp
0001b9 3f0f                      			cpi temp, 255
0001ba f011                      				breq setSwitchDisplayDataFlag
0001bb 940c 01bf                 				jmp saveSwitchDisplayDataTimerH
                                 
                                 			setSwitchDisplayDataFlag:
0001bd 6062                      				sbr eventsFlags1, ef_switch_display_data
                                 
                                 				resetDisplayDataTimerH:
0001be ee00                      				ldi temp, displayDataSwitchingFreq ; reset  timer
                                 
                                 			saveSwitchDisplayDataTimerH:
0001bf 9300 011b                 				sts switchDisplayDataTimerH, temp ;and save it to ram
                                 		
                                 		endDisplayDataTimerUpdate:
                                 
                                 
                                 		
                                 		////////////udpate check engine temperature timer ///////////
0001c1 e0b1                      		ldi xh, high(checkEngineTemperatureTimer) ; get flaps timer from ram
0001c2 e2aa                      		ldi xl, low(checkEngineTemperatureTimer)
0001c3 910c                      		ld temp, x
0001c4 9503                      		inc temp
0001c5 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001c6 f011                      			breq setCheckEngineTemperatureFlag
0001c7 940c 01cb                 			jmp saveCheckEngineTemperatureTimer
                                 
                                 		setCheckEngineTemperatureFlag:
0001c9 6064                      			sbr eventsFlags1, ef_check_engine_temperature ; create "update_flaps" task
                                 
0001ca e000                      			ldi temp, 0 ; reset flaps update timer
                                 
                                 		saveCheckEngineTemperatureTimer:
0001cb 9300 012a                 			sts checkEngineTemperatureTimer, temp ;and save it to ram
                                 
                                 		endCheckEngineTemperatureTimerUpdate:
                                 
                                 		//////// handle the last pressed key timer //////////
0001cd e0b1                      		ldi xh, high(handleCurrentKeyTimer)
0001ce e2ad                      		ldi xl, low(handleCurrentKeyTimer)
0001cf 910c                      		ld temp, x
0001d0 9503                      		inc temp
0001d1 3f0e                      		cpi temp, 254
0001d2 f410                      			brsh setHandleCurrentKeyFlag
0001d3 940c 01d7                 			jmp saveHandleCurrentKeyTimer
                                 
                                 		setHandleCurrentKeyFlag:
0001d5 6061                      			sbr eventsFlags1, ef_handle_current_key
0001d6 e000                      			ldi temp, 0
                                 
                                 		saveHandleCurrentKeyTimer:
0001d7 9300 012d                 			sts handleCurrentKeyTimer, temp
                                 
                                 		endHandleCrrentKeyTimerUpdate:
                                 
                                 
                                 		////////// outside temp checking timer//////////
0001d9 e0b1                      		ldi xh, high(checkOutsideTemperatureTimerL) ; get timer from ram
0001da e2a5                      		ldi xl, low(checkOutsideTemperatureTimerL)
0001db 910c                      		ld temp, x
0001dc 9503                      		inc temp
0001dd 3f0f                      		cpi temp, 255 ; emulate ovf interruption lol kek ahhahaha :-)))))))
0001de f021                      			breq incCheckOutsideTemperatureTimerH
0001df 9300 0125                 			sts checkOutsideTemperatureTimerL, temp
0001e1 940c 01f2                 			jmp endCheckOutsideTemperatreTimerUpdate
                                 
                                 		incCheckOutsideTemperatureTimerH:
0001e3 e000                      			ldi temp, 0
0001e4 9300 0125                 			sts checkOutsideTemperatureTimerL, temp
                                 
0001e6 e0b1                      			ldi xh, high(CheckOutsideTemperatureTimerH)
0001e7 e2a4                      			ldi xl, low(CheckOutsideTemperatureTimerH)
0001e8 910c                      			ld temp, x
0001e9 9503                      			inc temp
0001ea 3f0f                      			cpi temp, 255
0001eb f011                      				breq setCheckOutsideTemperatreFlag
0001ec 940c 01f0                 				jmp saveCheckOutsideTemperatreTimerH
                                 
                                 			setCheckOutsideTemperatreFlag:
0001ee 6870                      				sbr eventsFlags2, ef_check_outside_temperature
                                 
                                 				resetCheckOutsideTemperatreTimerH:
0001ef ef00                      				ldi temp, checkOutsideTemperatureFreq ; reset  timer
                                 
                                 			saveCheckOutsideTemperatreTimerH:
0001f0 9300 0124                 				sts CheckOutsideTemperatureTimerH, temp ;and save it to ram
                                 		
                                 		endCheckOutsideTemperatreTimerUpdate:
                                 
                                 
                                 		//////// check accelerations timer //////////
0001f2 e0b1                      		ldi xh, high(checkAccelerationTimer)
0001f3 e2ae                      		ldi xl, low(checkAccelerationTimer)
0001f4 910c                      		ld temp, x
0001f5 9503                      		inc temp
0001f6 3f0e                      		cpi temp, 254
0001f7 f410                      			brsh setCheckAccelerationFlag
0001f8 940c 01fc                 			jmp saveCheckAccelerationTimer
                                 
                                 		setCheckAccelerationFlag:
0001fa 6470                      			sbr eventsFlags2, ef_check_acceleration
0001fb e000                      			ldi temp, 0
                                 
                                 		saveCheckAccelerationTimer:
0001fc 9300 012e                 			sts checkAccelerationTimer, temp
                                 
                                 		endCheckAccelerationUpdate:
                                 
                                 
0001fe 9508                      	ret
                                 
                                 
                                 	rizeTemperature:
0001ff ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000200 9508                      			ret
                                 		
000201 940e 013a                 		call enableClickSignal ; make click sound
000203 e000                      		ldi temp, 0
000204 9300 012c                 		sts currentKey, temp
000206 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000207 e1ad                      		ldi xl, low(targetTemperature)
000208 910c                      		ld temp, x
000209 9503                      		inc temp ; increment temperature
                                 		
00020a 310f                      		cpi temp, 31 ; limit temperature to 30 grad
00020b f008                      			brlo saveTemperatureToRam
00020c e10e                      			ldi temp, 30
                                 
                                 		saveTemperatureToRam:
00020d 9300 011d                 			sts targetTemperature, temp ;and save it to ram
                                 
00020f 6054                      		sbr eventsFlags0, ef_save_target_temperature
000210 9508                      	ret
                                 
                                 	lowerTemperature:
000211 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
000212 9508                      			ret
                                 		
000213 940e 013a                 		call enableClickSignal ; make click sound
                                 
000215 e000                      		ldi temp, 0
000216 9300 012c                 		sts currentKey, temp
000218 e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000219 e1ad                      		ldi xl, low(targetTemperature)
00021a 910c                      		ld temp, x
00021b 950a                      		dec temp ; decrement temperature
                                 
00021c 300a                      		cpi temp, 10 ; limit temperature to 30 grad
00021d f77c                      			brge saveTemperatureToRam
00021e e00a                      			ldi temp, 10
                                 
00021f 9300 011d                 		sts targetTemperature, temp ;and save it to ram
                                 
000221 6054                      		sbr eventsFlags0, ef_save_target_temperature
000222 9508                      	ret
                                 
                                 	switchConditioner:
000223 e000                      		ldi temp, 0
000224 9300 012c                 		sts currentKey, temp
000226 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n
000227 940c 022b                 			jmp cond_en
000229 940c 0230                 			jmp cond_dis
                                 
                                 		cond_en:
00022b 6084                      			sbr statesFlags0, sf_conditioner_enabled
00022c 940e 013e                 			call enableAcceptSignal
00022e 940c 0237                 			jmp endSwitchConditioner
                                 		cond_dis:
000230 7f8b                      			cbr statesFlags0, sf_conditioner_enabled
000231 940e 0142                 			call enableCancelSignal
000233 9818                      			cbi porte, heater_pin_number
000234 9819                      			cbi porte, cooler_pin_number
000235 940c 0237                 			jmp endSwitchConditioner
                                 		endSwitchConditioner:
000237 9508                      	ret
                                 
                                 
                                 
                                 	saveTargetTemperature:
000238 99e1                      		sbic eecr, eewe ; wait for completion of previous write
000239 940c 0245                 			jmp endWritingAttempt
00023b e000                      		ldi temp, targetTempSavingAddr ; setup address where to wirte
00023c bb0f                      		out eearh, temp
00023d bb0e                      		out eearl, temp
                                 		
00023e e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
00023f e1ad                      		ldi xl, low(targetTemperature)
000240 910c                      		ld temp, x
                                 
000241 bb0d                      		out eedr, temp ; store data to data register
000242 9ae2                      		sbi eecr, eemwe ; write logical one to eemwe
000243 9ae1                      		sbi eecr, eewe ; start eeprom write by setting eewe
                                 
000244 7f5b                      		cbr eventsFlags0, ef_save_target_temperature ; end writing task
                                 
                                 		endWritingAttempt:
                                 
000245 9508                      	ret
                                 
                                 	loadTargetTemperature:
000246 99e1                      		sbic eecr, eewe ; wait for completion of previous write
000247 940c 0251                 			jmp endReadAttempt
000249 e000                      		ldi temp, targetTempSavingAddr
00024a bb0f                      		out eearh, temp
00024b bb0e                      		out eearl, temp
00024c 9ae0                      		sbi  eecr, eere ; start eeprom read by writing eere
00024d b30d                      		in temp, eedr ; read data from data register
00024e 9300 011d                 		sts targetTemperature, temp
                                 
000250 776f                      		cbr eventsFlags1, ef_load_target_temp ; end loading task if it success
                                 		
                                 		endReadAttempt:
000251 9508                      	ret
                                 
                                 	checkEngineTemperature:
000252 7f6b                      		cbr eventsFlags1, ef_check_engine_temperature
000253 e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
000254 e0a0                      		ldi xl, low(analogValuesTable)
000255 e032                      		ldi temp4, engineThermalSensorNum
000256 0fa3                      		add xl, temp4
000257 910c                      		ld temp, x
                                 
000258 3f08                      		cpi temp, 128 + 120 ; if engine temperature is more than 120C
000259 f410                      			brsh enableEngineTempWarning
00025a 940c 025e                 			jmp endEngineTemperatureCheck
                                 			
                                 		enableEngineTempWarning:
00025c 940e 0134                 			call enableWarningSignal
                                 
                                 		endEngineTemperatureCheck:
00025e 9508                      	ret
                                 
                                 	checkOutsideTemperature:
00025f 777f                      		cbr eventsFlags2, ef_check_outside_temperature
                                 
000260 e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
000261 e0a0                      		ldi xl, low(analogValuesTable)
000262 e031                      		ldi temp4, outsideThermalSensorNum
000263 0fa3                      		add xl, temp4
000264 910c                      		ld temp, x
                                 
000265 3c06                      		cpi temp, 128 + 70 ; if  temperature is more then 70C than warning
000266 f420                      			brsh enableOutsideTempWarning
000267 3300                      		cpi temp, 128 - 80 ; if temperature lower then -80 than warning
000268 f010                      			brlo enableOutsideTempWarning
000269 940c 026d                 			jmp endOutsideTemperatureCheck
                                 			
                                 		enableOutsideTempWarning:
00026b 940e 0134                 			call enableWarningSignal
                                 
                                 		endOutsideTemperatureCheck:
00026d 9508                      	ret
                                 
                                 	updateConditioner:
00026e ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
00026f 9508                      			ret
000270 7f5d                      		cbr eventsFlags0, ef_update_heater
                                 
000271 e0b1                      		ldi xh, high(targetTemperature) ; get target temperature from ram
000272 e1ad                      		ldi xl, low(targetTemperature)
000273 910c                      		ld temp, x
                                 
000274 310f                      		cpi temp, 31
000275 f480                      			brsh condTemperatureWarning
000276 300a                      		cpi temp, 10
000277 f070                      			brlo condTemperatureWarning
                                 
000278 e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
000279 e0a0                      		ldi xl, low(analogValuesTable)
00027a 911c                      		ld temp2, x
                                 
                                 		
                                 
00027b e0b1                      		ldi xh, high(analogValuesTable) ; get outside temperature from ram
00027c e0a0                      		ldi xl, low(analogValuesTable)
00027d e031                      		ldi temp4, outsideThermalSensorNum
00027e 0fa3                      		add xl, temp4
00027f 913c                      		ld temp4, x
                                 
000280 3c16                      		cpi temp2, 128 + 70 ; + 70C
000281 f420                      			brsh condTemperatureWarning
000282 3310                      		cpi temp2, 128 - 80
000283 f010                      			brlo condTemperatureWarning ; -80C
000284 940c 0288                 		jmp updateHeater
                                 
                                 		condTemperatureWarning:
000286 940e 0134                 			call enableWarningSignal
                                 
                                 		updateHeater:
000288 3810                      		cpi temp2, 128 ; if temperature is minus then enable heater emmediately 
000289 f048                      			brlo enableHeater
00028a 5810                      			subi temp2, 128
                                 		
00028b 1710                      		cp temp2, temp
00028c f030                      			brlo enableHeater
00028d 940c 028f                 			jmp disableHeater
                                 
                                 		disableHeater: ; ye ye ye useless, but just for code readability
00028f 9818                      			cbi porte, heater_pin_number
000290 9a19                      			sbi porte, cooler_pin_number
000291 940c 0295                 			jmp endUpdateConditioner
                                 
                                 		enableHeater:
000293 9a18                      			sbi porte, heater_pin_number
000294 9819                      			cbi porte, cooler_pin_number
                                 
                                 		; TODO add hummidity sensor and regulate it
                                 
                                 		endUpdateConditioner: 
000295 940e 029a                 		call resolveEngineFlap
000297 940e 02b5                 		call resolveOutsideFlap
000299 9508                      	ret
                                 
                                 	resolveEngineFlap:
00029a e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
00029b e0a0                      		ldi xl, low(analogValuesTable)
00029c 910c                      		ld temp, x
                                 
00029d e0b1                      		ldi xh, high(analogValuesTable) ; get engine temperature from ram
00029e e0a0                      		ldi xl, low(analogValuesTable)
00029f e032                      		ldi temp4, engineThermalSensorNum
0002a0 0fa3                      		add xl, temp4
0002a1 911c                      		ld temp2, x	
                                 
0002a2 1701                      		cp temp, temp2
0002a3 f038                      			brlo checkIfNeedWarmup
0002a4 940c 02a6                 			jmp checkIfNeedCooldown
                                 
                                 		checkIfNeedCooldown:
0002a6 9919                      			sbic porte, cooler_pin_number
0002a7 940c 02b0                 				jmp openEngineFlap
0002a9 940c 02b3                 				jmp closeEngineFlap
                                 
                                 		checkIfNeedWarmup:
0002ab 9918                      			sbic porte, heater_pin_number
0002ac 940c 02b0                 				jmp openEngineFlap
0002ae 940c 02b3                 				jmp closeEngineFlap
                                 
                                 		openEngineFlap:
0002b0 9a97                      			sbi portd, engine_flap_pin_num
0002b1 940c 02b4                 			jmp endResolveEngineFlap
                                 
                                 		closeEngineFlap:
0002b3 9897                      			cbi portd, engine_flap_pin_num
                                 
                                 		endResolveEngineFlap:
0002b4 9508                      	ret
                                 
                                 	resolveOutsideFlap:
0002b5 e0b1                      		ldi xh, high(analogValuesTable) ; get current temperature from ram
0002b6 e0a0                      		ldi xl, low(analogValuesTable)
0002b7 910c                      		ld temp, x
                                 
0002b8 e0b1                      		ldi xh, high(analogValuesTable) ; get outside temperature from ram
0002b9 e0a0                      		ldi xl, low(analogValuesTable)
0002ba e031                      		ldi temp4, outsideThermalSensorNum
0002bb 0fa3                      		add xl, temp4
0002bc 911c                      		ld temp2, x	
                                 
0002bd 1701                      		cp temp, temp2
0002be f038                      			brlo checkIfNeedWarmupFromOutside
0002bf 940c 02c1                 			jmp checkIfNeedCooldownFromOutside
                                 
                                 		checkIfNeedCooldownFromOutside:
0002c1 9919                      			sbic porte, cooler_pin_number
0002c2 940c 02cb                 				jmp openOutsideFlap
0002c4 940c 02ce                 				jmp closeOutsideFlap
                                 
                                 		checkIfNeedWarmupFromOutside:
0002c6 9918                      			sbic porte, heater_pin_number
0002c7 940c 02cb                 				jmp openOutsideFlap
0002c9 940c 02ce                 				jmp closeOutsideFlap
                                 
                                 		openOutsideFlap:
0002cb 9a96                      			sbi portd, outside_flap_pin_num
0002cc 940c 02cf                 			jmp endResolveOutsideFlap
                                 
                                 		closeOutsideFlap:
0002ce 9896                      			cbi portd, outside_flap_pin_num
                                 
                                 		endResolveOutsideFlap:
                                 
0002cf 9508                      	ret
                                 
                                 	updateConditionerFan:
0002d0 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
0002d1 9508                      			ret
0002d2 7f5e                      		cbr eventsFlags0, ef_update_conditioner_fan
                                 
0002d3 e0b1                      		ldi xh, high(conditionerFanState) ; get fan state from ram
0002d4 e2a3                      		ldi xl, low(conditionerFanState)
0002d5 910c                      		ld temp, x
0002d6 3000                      		cpi temp, 0
0002d7 f029                      			breq resetCondFanState
                                 
0002d8 9506                      		lsr temp
0002d9 3008                      		cpi temp, 0b00001000 ; if we are trying to lightup pin not connected to fan then reset it 
0002da f011                      			breq resetCondFanState
0002db 940c 02de                 			jmp saveCondFanState
                                 		resetCondFanState:
0002dd e800                      			ldi temp, 0b10000000
                                 		saveCondFanState:
0002de 9300 0123                 			sts conditionerFanState, temp ;and save it to ram	
0002e0 b113                      			in temp2, porte ; get current state of prote (to not broke other stuff connected to this port)
0002e1 701f                      			andi temp2, 0b00001111
0002e2 2b10                      			or temp2, temp ; out new fan state to porte
0002e3 b913                      			out porte, temp2
0002e4 9508                      	ret
                                 
                                 	updateFlaps:
0002e5 ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
0002e6 9508                      			ret
0002e7 7d6f                      		cbr eventsFlags1, ef_update_flaps
                                 
0002e8 e0f1                      		ldi zh, high(currentControlledFlap) ; get the number of a flap we wanna update now
0002e9 e2e0                      		ldi zl, low(currentControlledFlap)
0002ea 8100                      		ld temp, z
                                 
0002eb e0b1                      		ldi xh, high(analogValuesTable) ; get current state of needed flap control from ram
0002ec e0a0                      		ldi xl, low(analogValuesTable)
0002ed e028                      		ldi temp3, 8 ; flaps controlls data begins from 8th byte
0002ee 0fa2                      		add xl, temp3 
0002ef 0fa0                      		add xl, temp ; ofset to current flap control byte
                                 	
0002f0 911c                      		ld temp2, x
                                 
0002f1 7c10                      		andi temp2, 0b11000000 ; leave only two most significant byts (every falp will have only 4 possible states)
0002f2 9512                      		swap temp2
                                 
0002f3 b121                      		in temp3, pine ; get the contents from porte
0002f4 7f23                      		andi temp3, 0b11110011 ; clear two pins controlling the flaps to rewrite them in next two commands
0002f5 2b21                      		or temp3, temp2 ; and combine it with the date we wanno output
0002f6 b923                      		out porte, temp3 ; then... output
                                 
0002f7 b120                      		in temp3, pinf ; the same trick with two pins of portf (selecting one of our 4 flaps)
0002f8 732f                      		andi temp3, 0b00111111 
0002f9 2f10                      		mov temp2, temp
0002fa 9512                      		swap temp2
0002fb 0f11                      		lsl temp2
0002fc 0f11                      		lsl temp2
0002fd 2b21                      		or temp3, temp2
0002fe 9320 0062                 		sts portf, temp3
                                 
000300 9503                      		inc temp
                                 		
000301 3004                      		cpi temp, 4 ; if next selected falp as "non existing" 5th flap then fump to first one 
000302 f410                      			brsh jumpToFirstFlap
000303 940c 0306                 			jmp saveNextFlapNum
                                 		
                                 		jumpToFirstFlap:
000305 e000                      			ldi temp, 0
                                 
                                 		saveNextFlapNum:
000306 9300 0120                 			sts currentControlledFlap, temp
000308 9508                      	ret
                                 
                                 
                                 	updateSoundType:
000309 7b5f                      		cbr eventsFlags0, ef_update_sound_type
                                 
00030a ef00                      		ldi temp, soundSignalsDelay ; reset timer immediately
00030b bf02                      		out tcnt0, temp
                                 		
00030c fd86                      		sbrc statesFlags0, sf_warning_signal_enabled_n
00030d 940c 0319                 			jmp updateWarningSignal ; if warning signal is enabled then update it
00030f fd85                      		sbrc statesFlags0, sf_click_signal_enabled_n
000310 940c 0325                 			jmp updateClickSignal
000312 fd84                      		sbrc statesFlags0, sf_accept_signal_enabled_n
000313 940c 0332                 			jmp updateAcceptSignal
000315 fd83                      		sbrc statesFlags0, sf_cancel_signal_enabled_n
000316 940c 034a                 			jmp updateCancelSignal
000318 9508                      		ret	
                                 
                                 		updateWarningSignal:	
000319 ff87                      			sbrs statesFlags0, sf_sound_enabled_n
00031a 940c 031e                 				jmp warningSound_case_0
00031c 940c 0323                 				jmp warningSound_case_1
                                 				warningSound_case_0:
00031e ef0c                      					ldi temp, tone0
00031f 9300 012b                 					sts currentTone, temp ; set sound tone
000321 6880                      					sbr statesFlags0, sf_sound_enabled ; enable sound
000322 9508                      				ret
                                 
                                 				warningSound_case_1:
000323 778f                      					cbr statesFlags0, sf_sound_enabled ; disable sound
000324 9508                      				ret
                                 
                                 		updateClickSignal:
000325 ff87                      			sbrs statesFlags0, sf_sound_enabled_n
000326 940c 032a                 				jmp clickSound_case_0 ; if we haven't clicked yet than click
000328 940c 032f                 				jmp clickSound_case_1 ; otherwise end lcick signal
                                 
                                 				clickSound_case_0:
00032a ef0c                      					ldi temp, tone0
00032b 9300 012b                 					sts currentTone, temp ; set low sound tone  
00032d 6880                      					sbr statesFlags0, sf_sound_enabled ; enable sound
00032e 9508                      				ret
                                 
                                 				clickSound_case_1:
00032f 7d8f                      					cbr statesFlags0, sf_click_signal_enabled ; end click sound
000330 778f                      					cbr statesFlags0, sf_sound_enabled ; disable sound
000331 9508                      				ret
                                 
                                 		updateAcceptSignal:
000332 ff87                      			sbrs statesFlags0, sf_sound_enabled_n
000333 940c 0337                 				jmp acceptSound_case0 ; if sound is not enabled yet than enable it and set tone low
000335 940c 033c                 				jmp acceptSound_case1 ; otherwise if tone low then make it high. if tone high than end accept signal
                                 
                                 				acceptSound_case0:	
000337 ef0c                      					ldi temp, tone0		
000338 9300 012b                 					sts currentTone, temp ; set low sound tone  
00033a 6880                      					sbr statesFlags0, sf_sound_enabled ; enable sound
00033b 9508                      				ret
                                 
                                 				acceptSound_case1:
00033c e0b1                      					ldi xh, high(currentTone)
00033d e2ab                      					ldi xl, low(currentTone)
00033e 910c                      					ld temp, x
                                 
00033f 3f0c                      					cpi temp, tone0
000340 f011                      						breq acceptSound_case2 ; if tone is low make it high
000341 940c 0347                 						jmp acceptSound_case3 ; otherwise end signal
                                 						acceptSound_case2:
000343 ef0e                      							ldi temp, tone1
000344 9300 012b                 							sts currentTone, temp ; set high sound tone  
000346 9508                      						ret
                                 						acceptSound_case3:
000347 778f                      							cbr statesFlags0, sf_sound_enabled	; disable sound
000348 7e8f                      							cbr statesFlags0, sf_accept_signal_enabled ; end accept signal
000349 9508                      						ret
                                 
                                 		updateCancelSignal:
00034a ff87                      			sbrs statesFlags0, sf_sound_enabled_n
00034b 940c 034f                 				jmp cancelSound_case0 ; if sound is not enabled yet than enable it and set tone low
00034d 940c 0354                 				jmp cancelSound_case1 ; otherwise if tone low then make it high. if tone high than end accept signal
                                 
                                 				cancelSound_case0:
00034f ef0e                      					ldi temp, tone1			
000350 9300 012b                 					sts currentTone, temp ; set high sound tone  
000352 6880                      					sbr statesFlags0, sf_sound_enabled ; enable sound
000353 9508                      				ret
                                 
                                 				cancelSound_case1:
000354 e0b1                      					ldi xh, high(currentTone)
000355 e2ab                      					ldi xl, low(currentTone)
000356 910c                      					ld temp, x
                                 
000357 3f0e                      					cpi temp, tone1
000358 f011                      						breq cancelSound_case2 ; if tone high make it low
000359 940c 035f                 						jmp cancelSound_case3 ; otherwise end signal
                                 						cancelSound_case2:
00035b ef0c                      							ldi temp, tone0
00035c 9300 012b                 							sts currentTone, temp ; set sound tone  
00035e 9508                      						ret
                                 						cancelSound_case3:
00035f 778f                      							cbr statesFlags0, sf_sound_enabled	; disable sound
000360 7f87                      							cbr statesFlags0, sf_cancel_signal_enabled ; end accept signal
000361 9508                      						ret
                                 
                                 
                                 
                                 	updateWaveState:
000362 775f                      		cbr eventsFlags0, ef_update_sound_wave_state
                                 
000363 e0b1                      		ldi xh, high(currentTone)
000364 e2ab                      		ldi xl, low(currentTone)
000365 910c                      		ld temp, x
                                 
000366 bd04                      		out tcnt2, temp ; reset timer2 immediately to prevent bad sound
                                 
000367 ff87                      		sbrs statesFlags0, sf_sound_enabled_n ; if we should not prodice some sound
000368 9518                      			reti ; do nothing
000369 9b95                      			sbis portd, speaker_pin_number ; if this pin is low
00036a 940c 036e                 				jmp speakerWaveUp ; then make it high
00036c 940c 0370                 				jmp speakerWaveDown ; otherwise make it low
                                 
                                 			speakerWaveUp:
00036e 9a95                      				sbi portd, speaker_pin_number ; make it high
00036f 9518                      				reti
                                 			speakerWaveDown:
000370 9895                      				cbi portd, speaker_pin_number ; make it low
000371 9518                      				reti
                                 				; result sound wave 				____	  ____	    ____	  ____
                                 				; will be something like that:	___|	|____|	  |____|    |____|    |____
                                 
                                 
                                 	readInput:
000372 b709                      		in temp, eimsk ; disable external intrruption int0
000373 7f0e                      		andi temp, 0b11111110
000374 bf09                      		out eimsk, temp
                                 
000375 7d5f                      		cbr eventsFlags0, ef_handle_input
                                 		
000376 e000                      		ldi temp, 0b00000000 ; check first row
000377 bb0b                      		out porta, temp
000378 b309                      		in temp, pina ; get pressed button
                                 		
000379 940e 038a                 		call checkInput
                                 
00037b e008                      		ldi temp, 0b00001000 ; check 2nd row
00037c bb0b                      		out porta, temp
00037d b309                      		in temp, pina 
                                 
00037e 940e 038a                 		call checkInput
                                 
000380 e100                      		ldi temp, 0b00010000 ; check third row
000381 bb0b                      		out porta, temp
000382 b309                      		in temp, pina 
                                 
000383 940e 038a                 		call checkInput
                                 
000385 e108                      		ldi temp, 0b00011000 ; check the last row
000386 bb0b                      		out porta, temp
000387 b309                      		in temp, pina ; 
                                 
000388 940c 0391                 		jmp endReadingInput
                                 
                                 		checkInput:
00038a 2f10                      			mov temp2, temp
00038b 7017                      			andi temp2, 0b00000111 ; check only three bits indicating pressed button
00038c 3010                      			cpi temp2, 0
00038d f409                      			brne clearReturnAddr	
00038e 9508                      		ret
                                 
                                 		clearReturnAddr:
00038f 911f                      			pop temp2 ; removing returning addr from stack
000390 911f                      			pop temp2
                                 		endReadingInput:
000391 9300 012c                 			sts currentKey, temp ; finally save pressed key
000393 e800                      			ldi temp, 0b10000000 ; enable continuous keyboard checking
000394 bb0b                      			out porta, temp 
                                 			
000395 b709                      			in temp, eimsk
000396 e011                      			ldi temp2, 0b00000001
000397 2b01                      			or temp, temp2 ; enable external intrruption int0
000398 bf09                      			out eimsk, temp
000399 9508                      	ret
                                 
                                 	switchDisplayData:
00039a 7f6d                      		cbr eventsFlags1, ef_switch_display_data
                                 
00039b fd86                      		sbrc statesFlags0, sf_warning_signal_enabled_n
00039c 940c 03a1                 			jmp checkDisplayErrorMessage
00039e 7f8e                      			cbr statesFlags0, sf_display_error_message
00039f 940c 03a9                 			jmp normalDataSwitch
                                 
                                 		checkDisplayErrorMessage:
0003a1 ff80                      			sbrs statesFlags0, sf_display_error_message_n
0003a2 940c 03a6                 				jmp switchThroughError
0003a4 940c 03a9                 				jmp normalDataSwitch			
                                 
                                 		switchThroughError:
0003a6 6081                      			sbr statesFlags0, sf_display_error_message
0003a7 940c 03b7                 			jmp endSwitchingDisplayData
                                 
                                 		normalDataSwitch:
0003a9 7f8e                      			cbr statesFlags0, sf_display_error_message
0003aa e0b1                      		ldi xh, high(currentDisplayData) ; get "number" of type of data we wanna to be displayed
0003ab e1aa                      				ldi xl, low(currentDisplayData)
0003ac 910c                      				ld temp, x
                                 
0003ad 3001                      				cpi temp, 1
0003ae f428                      					brsh goToFirstData
                                 					;else next data
0003af 9503                      					inc temp
0003b0 9300 011a                 					sts currentDisplayData, temp
0003b2 940c 03b7                 					jmp endSwitchingDisplayData
                                 
                                 					goToFirstData:
0003b4 e000                      						ldi temp, 0
0003b5 9300 011a                 						sts currentDisplayData, temp
                                 		
                                 		endSwitchingDisplayData:
                                 
0003b7 9508                      	ret
                                 
                                 	update7segScreen:
0003b8 7e5f                      		cbr eventsFlags0, ef_update_7seg_screen
                                 
0003b9 ef0f                      		ldi temp, 0xff 
0003ba ef10                      		ldi temp2, 0xf0
0003bb bd0d                      		out tcnt1h, temp
0003bc bd1c                      		out tcnt1l, temp2
                                 		
0003bd e0b1                      		ldi xh, high(curPos7Seg) ; get pereviously printed display indicator from ram
0003be e1a9                      		ldi xl, low(curPos7Seg)
0003bf 912c                      		ld temp3, x
                                 
0003c0 9523                      		inc temp3
                                 
0003c1 3028                      		cpi temp3, 8
0003c2 f410                      			brsh jumpToFirst7seg
0003c3 940c 03e0                 			jmp printGlyph
                                 
                                 		jumpToFirst7seg:
0003c5 e020                      			ldi temp3, 0 ; select first indicator
0003c6 940e 03f6                 			call clear7SegScrBuffer
0003c8 e0b1                      			ldi xh, high(currentDisplayData)
0003c9 e1aa                      			ldi xl, low(currentDisplayData)
0003ca 910c                      			ld temp, x
0003cb fd80                      			sbrc statesFlags0, sf_display_error_message_n
0003cc 940c 03de                 				jmp selectErrorMessage
0003ce 3000                      			cpi temp, 0
0003cf f011                      				breq selectTemperaturesData ; TODO prevent failing compairing after SBR command in interruption handler
0003d0 3001                      			cpi temp, 1
0003d1 f041                      				breq selectTachometerData
                                 
                                 			selectTemperaturesData:
0003d2 940e 0442                 				call printEngineTemperature
0003d4 940e 042d                 				call printCurrentTemperature
0003d6 940e 041d                 				call printTargetTemperature
0003d8 940c 03e0                 				jmp endJumpToFirstSegment
                                 
                                 			selectTachometerData:
0003da 940e 040a                 				call printTachometerValue
0003dc 940c 03e0                 				jmp endJumpToFirstSegment
                                 
                                 			selectErrorMessage:
0003de 940e 045c                 				call printErrorMessage
                                 
                                 			endJumpToFirstSegment:
                                 
                                 
                                 		printGlyph:
0003e0 9320 0119                 			sts curPos7Seg, temp3
                                 
                                 			; get number of a glyph 
0003e2 e0b1                      			ldi xh, high(SevenSegScrBuff)
0003e3 e1a0                      			ldi xl, low(SevenSegScrBuff)
0003e4 0fa2                      			add  xl, temp3
                                 
0003e5 910c                      			ld temp, x
                                 
0003e6 e0f0                      			ldi zh,0
0003e7 eae0                      			ldi zl, charTable7seg * 2
                                 
0003e8 0fe0                      			add zl, temp
0003e9 9104                      			lpm temp, z
                                 
0003ea 3021                      			cpi temp3, 1
0003eb f021                      				breq printDot
0003ec 3024                      			cpi temp3, 4
0003ed f011                      				breq printDot
0003ee 940c 03f1                 				jmp moveGlyphToscreen
                                 			
                                 			printDot:
0003f0 7f0e                      				andi temp, 0b11111110
                                 
                                 			moveGlyphToScreen:
0003f1 9522                      			swap temp3
0003f2 0f22                      			lsl temp3
0003f3 bb28                      			out portb, temp3 ; select place on display
                                 
0003f4 bb05                      			out portc, temp ; print glyph
0003f5 9508                      	ret
                                 
                                 	clear7SegScrBuffer:
0003f6 e0f0                      		ldi zh, 0
0003f7 eae0                      		ldi zl, charTable7seg * 2
0003f8 e103                      		ldi temp, chSpace ; load space glyph
                                 		;add zl, temp
                                 		;lpm temp, z
                                 
0003f9 9300 0110                 		sts SevenSegScrBuff + 0, temp ; clear unused display indicators
0003fb 9300 0111                 		sts SevenSegScrBuff + 1, temp
0003fd 9300 0112                 		sts SevenSegScrBuff + 2, temp
0003ff 9300 0113                 		sts SevenSegScrBuff + 3, temp
000401 9300 0114                 		sts SevenSegScrBuff + 4, temp
000403 9300 0115                 		sts SevenSegScrBuff + 5, temp
000405 9300 0116                 		sts SevenSegScrBuff + 6, temp
000407 9300 0117                 		sts SevenSegScrBuff + 7, temp
000409 9508                      	ret
                                 
                                 	printTachometerValue:
00040a e0b1                      		ldi xh, high(engineSpeed) ; get engineSpeed from ram
00040b e2a9                      		ldi xl, low(engineSpeed)
00040c 910c                      		ld temp, x
                                 	
00040d 940e 046b                 		call convertBinToDec
00040f 2f10                      		mov temp2, temp
000410 701f                      		andi temp2, 0b00001111 ; select low page
000411 9310 0112                 		sts SevenSegScrBuff + 2 , temp2 ; place the actual glyph number in a buffer
                                 
000413 7f00                      		andi temp, 0b11110000 ; select high page
000414 9502                      		swap temp
000415 9300 0111                 		sts SevenSegScrBuff + 1, temp ; place the actual glyph nubmer in a buffer
                                 
000417 e000                      		ldi temp, ch0
000418 9300 0113                 		sts SevenSegScrBuff + 3, temp
00041a 9300 0114                 		sts SevenSegScrBuff + 4, temp
00041c 9508                      	ret
                                 
                                 	
                                 	printTargetTemperature:
00041d ff82                      		sbrs statesFlags0, sf_conditioner_enabled_n ; if conditioner is not enabled then return emmidiately
00041e 9508                      			ret
00041f e0b1                      		ldi xh, high(targetTemperature) ; get temperature from ram
000420 e1ad                      		ldi xl, low(targetTemperature)
000421 910c                      		ld temp, x
                                 	
000422 940e 046b                 		call convertBinToDec
000424 2f10                      		mov temp2, temp
000425 701f                      		andi temp2, 0b00001111 ; select low page
000426 9310 0114                 		sts SevenSegScrBuff + 4, temp2 ; place the actual glyph number in a buffer
                                 
000428 7f00                      		andi temp, 0b11110000 ; select high page
000429 9502                      		swap temp
00042a 9300 0113                 		sts SevenSegScrBuff + 3, temp ; place the actual glyph nubmer in a buffer
00042c 9508                      	ret
                                 
                                 	printCurrentTemperature:
00042d e0b1                      		ldi xh, high(analogValuesTable) ; get temperature from ram
00042e e0a0                      		ldi xl, low(analogValuesTable)
00042f 910c                      		ld temp, x
                                 
000430 3800                      		cpi temp, 128 ; check right at the beggining if this number negative
000431 f420                      			brsh convertTemperature
                                 
                                 		negateTemperature:
000432 e111                      			ldi temp2,  chMinus ; "-" glyph number in a table
000433 9310 0115                 			sts SevenSegScrBuff + 5, temp2
000435 9500                      			com temp
                                 			
                                 		convertTemperature:
000436 5800                      			subi temp, 128
000437 940e 046b                 			call convertBinToDec
                                 	
000439 2f10                      			mov temp2, temp
00043a 701f                      			andi temp2, 0b00001111 ; select low page
00043b 9310 0117                 			sts SevenSegScrBuff + 7, temp2 ; place the actual glyph number in a buffer
                                 
00043d 7f00                      			andi temp, 0b11110000 ; select high page
00043e 9502                      			swap temp
00043f 9300 0116                 			sts SevenSegScrBuff + 6, temp ; place the actual glyph nubmer in a buffer
000441 9508                      	ret
                                 
                                 	printEngineTemperature:
000442 e0b1                      		ldi xh, high(analogValuesTable) ; get temperature from ram
000443 e0a0                      		ldi xl, low(analogValuesTable)
000444 e002                      		ldi temp, 2
000445 0fa0                      		add xl, temp
000446 910c                      		ld temp, x
                                 		
000447 3800                      		cpi temp, 128
000448 f068                      		 brlo printEngineTempNegative
                                 
000449 5800                      		subi temp, 128
00044a 940e 046b                 		call convertBinToDec
                                 	
00044c 2f10                      		mov temp2, temp
00044d 701f                      		andi temp2, 0b00001111 ; select low page
00044e 9310 0111                 		sts SevenSegScrBuff + 1, temp2 ; place the actual glyph number in a buffer
                                 
000450 7f00                      		andi temp, 0b11110000 ; select high page
000451 9502                      		swap temp
000452 9300 0110                 		sts SevenSegScrBuff, temp ; place the actual glyph nubmer in a buffer
000454 940c 045b                 		jmp endEngineTempPrinting
                                 
                                 		printEngineTempNegative:
000456 e101                      			ldi temp, chMinus ; load "minus" gliph number
000457 9300 0110                 			sts SevenSegScrBuff, temp
000459 9300 0111                 			sts SevenSegScrBuff + 1, temp
                                 
                                 		endEngineTempPrinting:
00045b 9508                      	ret
                                 
                                 	printErrorMessage:	
00045c e00e                      		ldi temp, chE
00045d 9300 0110                 		sts SevenSegScrBuff, temp
00045f e102                      		ldi temp, chR
000460 9300 0111                 		sts SevenSegScrBuff + 1, temp
000462 9300 0112                 		sts SevenSegScrBuff + 2, temp
000464 e000                      		ldi temp, ch0
000465 9300 0113                 		sts sevenSegScrBuff + 3, temp
000467 e102                      		ldi temp, chR
000468 9300 0114                 		sts sevenSegScrBuff + 4, temp
00046a 9508                      	ret
                                 
                                 	convertBinToDec:
00046b 3604                      		cpi temp, 100 ; check right at the beggining if this number is to big to display it on the screen
00046c f5d8                      		brsh btdMax
00046d e010                      		ldi temp2, 0 ; yeeeeeee no looooopsss ahahahhachchahhhacha
00046e 300a                      			cpi temp, 10
00046f f414                      			brge increaseTens0
000470 940c 04ae                 				jmp setLowPage
                                 		increaseTens0:
000472 500a                      			subi temp, 10
000473 9513                      			inc temp2
000474 300a                      			cpi temp, 10
000475 f414                      			brge increaseTens1
000476 940c 04ae                 				jmp setLowPage
                                 		increaseTens1:
000478 500a                      			subi temp, 10
000479 9513                      			inc temp2
00047a 300a                      			cpi temp, 10
00047b f414                      			brge increaseTens2
00047c 940c 04ae                 				jmp setLowPage
                                 		increaseTens2:
00047e 500a                      			subi temp, 10
00047f 9513                      			inc temp2
000480 300a                      			cpi temp, 10
000481 f414                      			brge increaseTens3
000482 940c 04ae                 				jmp setLowPage
                                 		increaseTens3:
000484 500a                      			subi temp, 10
000485 9513                      			inc temp2
000486 300a                      			cpi temp, 10
000487 f414                      			brge increaseTens4
000488 940c 04ae                 				jmp setLowPage
                                 		increaseTens4:
00048a 500a                      			subi temp, 10
00048b 9513                      			inc temp2
00048c 300a                      			cpi temp, 10
00048d f414                      			brge increaseTens5
00048e 940c 04ae                 				jmp setLowPage
                                 		increaseTens5:
000490 500a                      			subi temp, 10
000491 9513                      			inc temp2
000492 300a                      			cpi temp, 10
000493 f414                      			brge increaseTens6
000494 940c 04ae                 				jmp setLowPage
                                 		increaseTens6:
000496 500a                      			subi temp, 10
000497 9513                      			inc temp2
000498 300a                      			cpi temp, 10
000499 f414                      			brge increaseTens7
00049a 940c 04ae                 				jmp setLowPage
                                 		increaseTens7:
00049c 500a                      			subi temp, 10
00049d 9513                      			inc temp2
00049e 300a                      			cpi temp, 10
00049f f414                      			brge increaseTens8
0004a0 940c 04ae                 				jmp setLowPage
                                 		increaseTens8:
0004a2 500a                      			subi temp, 10
0004a3 9513                      			inc temp2
0004a4 301a                      			cpi temp2, 10
0004a5 f414                      				brge btdMax
0004a6 940c 04ae                 				jmp setLowPage
                                 		btdMax:
0004a8 e019                      			ldi temp2, 9
0004a9 2f01                      			mov temp, temp2
0004aa 9502                      			swap temp
0004ab 0f01                      			add temp, temp2
                                 			
0004ac 940c 04b1                 			jmp endBTDConv
                                 
                                 		setLowPage:
0004ae 9502                      			swap temp ; move low number to high page
0004af 0f01                      			add temp, temp2 ; save hig number to low page
0004b0 9502                      			swap temp
                                 
                                 		endBTDConv:	
0004b1 9508                      	ret
                                 
                                 
                                 	readAnalogSensors:
0004b2 7f57                      		cbr eventsFlags0, ef_read_analog_sensors
                                 
0004b3 e0b1                      		ldi xh, high(currentSensorNum) ; get the nubmer of thermal sensor we wanna read from
0004b4 e1a8                      		ldi xl, low(currentSensorNum)
0004b5 911c                      		ld temp2, x
                                 
0004b6 e0f1                      		ldi zh, high(analogValuesTable) ; seting up addres of the beginning of temperatuers table
0004b7 e0e0                      		ldi zl, low(analogValuesTable)
                                 
0004b8 0fe1                      		add zl, temp2 ; apply offset to store data to correct place in a table
                                 
0004b9 b104                      		in temp, adcl
0004ba b105                      		in temp, adch
0004bb 8300                      		st z, temp ; and finally store it
                                 
0004bc 9513                      		inc temp2 ; select next sensor value to be readen in the next iterration
                                 
                                 		
0004bd 3110                      		cpi temp2, 16 ; if next sensor is "non existing" 17th sensor then return to first one
0004be f414                      			brge jumpToFirstSensor
0004bf 940c 04c2                 			jmp saveNextSensorNumber ; else just save the next sensor nubmer
                                 
                                 		jumpToFirstSensor:
0004c1 e010                      			ldi temp2, 0
                                 
                                 		saveNextSensorNumber:
0004c2 9310 0118                 			sts currentSensorNum, temp2
0004c4 0f11                      			lsl temp2
0004c5 b100                      			in temp, pinf ; get content of portf
0004c6 7e01                      			andi temp, 0b11100001 ; clear 4 bits to rewrite them later
0004c7 2b10                      			or temp2, temp
0004c8 9310 0062                 			sts portf, temp2
                                 
0004ca e600                      		ldi temp, 0b01100000 ; and restart adc after all
0004cb b907                      		out admux, temp
0004cc ed0e                      		ldi temp, 0b11011110
0004cd b906                      		out adcsra, temp
0004ce 9508                      	ret
                                 
                                 	updateTachometer:
0004cf 7f67                      		cbr eventsFlags1, ef_update_tachometer
                                 		
0004d0 e0b1                      		ldi xh, high(tachometerCounter) ; get value counted by tachometer counter durring 0.1 sec
0004d1 e2a8                      		ldi xl, low(tachometerCounter)
0004d2 910c                      		ld temp, x
                                 		;inc temp ; some kind of trikky compensation
                                 
0004d3 e016                      		ldi temp2, 6
0004d4 9f01                      		mul temp, temp2 ; because it is 6*10 seconds in one minute
0004d5 2d00                      		mov temp, r0 ; get product low (numbers will not be to big)
                                 
                                 		
                                 
0004d6 3600                      		cpi temp, 96
0004d7 f410                      			brsh tachometerMax
0004d8 940c 04db                 			jmp saveEngineSpeed
                                 
                                 		tachometerMax:
0004da e603                      			ldi temp, 99
                                 		saveEngineSpeed:
0004db 9300 0129                 			sts engineSpeed, temp
0004dd e000                      			ldi temp, 0
0004de 9300 0128                 			sts tachometerCounter, temp
0004e0 9508                      	ret
                                 
                                 	incrementTachometerCounter:
0004e1 7e6f                      		cbr eventsFlags1, ef_increment_tachometer
                                 
0004e2 b709                      		in temp, eimsk ; disable external intrruption int1
0004e3 7f0d                      		andi temp, 0b11111101
0004e4 bf09                      		out eimsk, temp
                                 
0004e5 e0b1                      		ldi xh, high(tachometerCounter)
0004e6 e2a8                      		ldi xl, low(tachometerCounter)
0004e7 910c                      		ld temp, x
                                 		
0004e8 3f0f                      		cpi temp, 255
0004e9 f029                      			breq endIncTachCounter
0004ea 940c 04ec                 			jmp incTachCounter
                                 
                                 		incTachCounter:
0004ec 9503                      			inc temp
0004ed 9300 0128                 			sts tachometerCounter, temp
                                 		
                                 		endIncTachCounter:
0004ef b709                      			in temp, eimsk
0004f0 e012                      			ldi temp2, 0b00000010
0004f1 2b01                      			or temp, temp2 ; enable external intrruption int1
0004f2 bf09                      			out eimsk, temp
0004f3 9508                      	ret
                                 	
                                 
                                 	////////////INTERRUPTIONS HANDLERS/////////////
                                 	extInt0Handler:
0004f4 b74f                      		in tempInter, sreg
0004f5 6250                      		sbr eventsFlags0, ef_handle_input
0004f6 bf4f                      		out sreg, tempInter
0004f7 9518                      	reti
                                 
                                 	extInt1Handler:
0004f8 b74f                      		in tempInter, sreg
0004f9 6160                      		sbr eventsFlags1, ef_increment_tachometer
0004fa bf4f                      		out sreg, tempInter
0004fb 9518                      	reti
                                 
                                 	timer0OvfHandler:
0004fc b74f                      		in tempInter, sreg
0004fd 6450                      		sbr eventsFlags0, ef_update_sound_type
0004fe bf4f                      		out sreg, tempInter
0004ff 9518                      	reti
                                 
                                 	timer1OvfHandler:
000500 b74f                      		in tempInter, sreg
000501 6150                      		sbr eventsFlags0, ef_update_7seg_screen
000502 bf4f                      		out sreg, tempInter
000503 9518                      	reti
                                 
                                 	timer2OvfHandler: 
000504 b74f                      		in tempInter, sreg
000505 6850                      		sbr eventsFlags0, ef_update_sound_wave_state
000506 bf4f                      		out sreg, tempInter
000507 9518                      	reti
                                 
                                 	timer3OvfHandler:
000508 b74f                      		in tempInter, sreg
000509 6460                      		sbr eventsFlags1, ef_update_program_timers
00050a bf4f                      		out sreg, tempInter
00050b 9518                      	reti
                                 
                                 	adcConvertionHandler:	
00050c b74f                      		in tempInter, sreg
00050d 6058                      		sbr eventsFlags0, ef_read_analog_sensors
00050e bf4f                      		out sreg, tempInter


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :  45 y  :   0 z  :   3 r0 :   1 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 349 r17:  85 r18:  24 r19:  14 r20:  14 
r21:  25 r22:  24 r23:   6 r24:  47 r25:   0 r26:  57 r27:  45 r28:   0 
r29:   0 r30:   6 r31:   4 
Registers used: 16 out of 35 (45.7%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  16 adiw  :   0 and   :   0 
andi  :  17 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  24 brge  :  12 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  12 brlt  :   0 brmi  :   0 
brne  :   1 brpl  :   0 brsh  :  15 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  56 cbi   :   7 cbr   :  34 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   1 cp    :   3 cpc   :   0 
cpi   :  61 cpse  :   0 dec   :   1 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  22 inc   :  28 
jmp   : 105 ld    :  46 ldd   :   0 ldi   : 193 lds   :   0 lpm   :   2 
lsl   :   4 lsr   :   1 mov   :   8 movw  :   0 mul   :   1 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   8 ori   :   0 out   :  49 
pop   :   2 push  :   0 rcall :   0 ret   :  53 reti  :  10 rjmp  :   0 
rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 sbi   :  13 sbic  :   6 
sbis  :   1 sbiw  :   0 sbr   :  29 sbrc  :  25 sbrs  :  14 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   :  78 sub   :   0 subi  :  12 swap  :  10 tst   :   0 wdr   :   0 

Instructions used: 40 out of 114 (35.1%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000a20   2440     24   2464  131072   1.9%
[.dseg] 0x000100 0x00012f      0     47     47    4096   1.1%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
